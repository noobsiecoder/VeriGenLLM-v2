$date
	Sun Aug 24 21:32:12 2025
$end
$version
	Icarus Verilog
$end
$timescale
	1ps
$end
$scope module tb_vector_concat $end
$var wire 8 ! z [7:0] $end
$var wire 8 " y [7:0] $end
$var wire 8 # x [7:0] $end
$var wire 8 $ w [7:0] $end
$var reg 5 % a [4:0] $end
$var reg 5 & b [4:0] $end
$var reg 5 ' c [4:0] $end
$var reg 5 ( d [4:0] $end
$var reg 5 ) e [4:0] $end
$var reg 32 * expected_concat [31:0] $end
$var reg 8 + expected_w [7:0] $end
$var reg 8 , expected_x [7:0] $end
$var reg 8 - expected_y [7:0] $end
$var reg 8 . expected_z [7:0] $end
$var reg 5 / f [4:0] $end
$var integer 32 0 num_tests_passed [31:0] $end
$var integer 32 1 total_tests [31:0] $end
$scope module dut $end
$var wire 5 2 a [4:0] $end
$var wire 5 3 b [4:0] $end
$var wire 5 4 c [4:0] $end
$var wire 5 5 d [4:0] $end
$var wire 5 6 e [4:0] $end
$var wire 5 7 f [4:0] $end
$var wire 8 8 z [7:0] $end
$var wire 8 9 y [7:0] $end
$var wire 8 : x [7:0] $end
$var wire 8 ; w [7:0] $end
$var wire 32 < concat_out [31:0] $end
$upscope $end
$scope task display_and_check $end
$var reg 8 = exp_w [7:0] $end
$var reg 8 > exp_x [7:0] $end
$var reg 8 ? exp_y [7:0] $end
$var reg 8 @ exp_z [7:0] $end
$var reg 160 A test_name [160:1] $end
$upscope $end
$upscope $end
$enddefinitions $end
$comment Show the parameter values. $end
$dumpall
$end
#0
$dumpvars
bx A
bx @
bx ?
bx >
bx =
b11 <
b0 ;
b0 :
b0 9
b11 8
b0 7
b0 6
b0 5
b0 4
b0 3
b0 2
b0 1
b0 0
b0 /
b11 .
b0 -
b0 ,
b0 +
b11 *
b0 )
b0 (
b0 '
b0 &
b0 %
b0 $
b0 #
b0 "
b11 !
$end
#10000
b11111111 !
b11111111 8
b11111111 "
b11111111 9
b11111111 #
b11111111 :
b11111111 $
b11111111 ;
b11111111 .
b11111111 -
b11111111 ,
b11111111 +
b11111111111111111111111111111111 *
b11111 /
b11111 7
b11111 )
b11111 6
b11111 (
b11111 5
b11111 '
b11111 4
b11111 &
b11111 3
b11111111111111111111111111111111 <
b11111 %
b11111 2
b1 0
b1 1
b11 @
b0 ?
b0 >
b0 =
b10000010110110001101100001000000111101001100101011100100110111101110011 A
#20000
b10011011 !
b10011011 8
b1000010 "
b1000010 9
b10000110 #
b10000110 :
b1000 $
b1000 ;
b10011011 .
b1000010 -
b10000110 ,
b1000 +
b1000100001100100001010011011 *
b110 /
b110 7
b101 )
b101 6
b100 (
b100 5
b11 '
b11 4
b10 &
b10 3
b1000100001100100001010011011 <
b1 %
b1 2
b10 0
b10 1
b11111111 @
b11111111 ?
b11111111 >
b11111111 =
b100000101101100011011000010000001101111011011100110010101110011 A
#30000
b11 !
b11 8
b0 "
b0 9
b0 #
b0 :
b11111000 $
b11111000 ;
b0 /
b0 7
b0 )
b0 6
b0 (
b0 5
b0 '
b0 4
b0 &
b0 3
b11111000000000000000000000000011 <
b11111 %
b11111 2
b11 0
b11 1
b10011011 @
b1000010 ?
b10000110 >
b1000 =
b1010011011001010111000101110101011001010110111001110100011010010110000101101100 A
#40000
b11000000 #
b11000000 :
b111 $
b111 ;
b11111 &
b11111 3
b111110000000000000000000011 <
b0 %
b0 2
#50000
b11000111 !
b11000111 8
b100000 "
b100000 9
b1000 #
b1000 :
b10000010 $
b10000010 ;
b10000010000010000010000011000111 *
b10001 /
b10001 7
b1 )
b1 6
b10 (
b10 5
b100 '
b100 4
b1000 &
b1000 3
b10000010000010000010000011000111 <
b10000 %
b10000 2
#60000
b1111 !
b1111 8
b1101111 "
b1101111 9
b10110010 #
b10110010 :
b10101010 $
b10101010 ;
b1111 .
b1101111 -
b10110010 ,
b10101010 +
b10101010101100100110111100001111 *
b11 /
b11 7
b11110 )
b11110 6
b110 (
b110 5
b11001 '
b11001 4
b1010 &
b1010 3
b10101010101100100110111100001111 <
b10101 %
b10101 2
#70000
b110111 !
b110111 8
b11111001 "
b11111001 9
b11100000 #
b11100000 :
b11100001 $
b11100001 ;
b110111 .
b11111001 -
b11100000 ,
b11100001 +
b11100001111000001111100100110111 *
b1101 /
b1101 7
b10010 )
b10010 6
b1111 (
b1111 5
b10000 '
b10000 4
b111 &
b111 3
b11100001111000001111100100110111 <
b11100 %
b11100 2
b100 0
b100 1
b1111 @
b1101111 ?
b10110010 >
b10101010 =
b101001001100001011011100110010001101111011011010010000000110001 A
#80000
b11 !
b11 8
b0 "
b0 9
b0 #
b0 :
b0 $
b0 ;
b0 /
b0 7
b0 )
b0 6
b0 (
b0 5
b0 '
b0 4
b0 &
b0 3
b11 <
b0 %
b0 2
b101 0
b101 1
b110111 @
b11111001 ?
b11100000 >
b11100001 =
b101001001100001011011100110010001101111011011010010000000110010 A
#90000
