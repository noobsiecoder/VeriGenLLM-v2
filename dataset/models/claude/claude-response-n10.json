[
    {
        "question": "Verilog declaration with one wire.",
        "outputs": [
            "```verilog\nwire signal_name;\n```",
            "```verilog\nwire signal_name;\n```",
            "```verilog\nwire signal_name;\n```",
            "```verilog\nwire signal_name;\n```",
            "```verilog\nwire signal_name;\n```",
            "```verilog\nwire signal_name;\n```",
            "```verilog\nwire signal_name;\n```",
            "```verilog\nwire signal_name;\n```",
            "```verilog\nwire signal_name;\n```",
            "```verilog\nwire signal_name;\n```"
        ],
        "config": {
            "model": "claude-opus-4-20250514",
            "system_instruction": "You are a Verilog code generator. Output only synthesizable Verilog code.",
            "temperature": 0.2,
            "max_tokens": 1024,
            "samples": 10
        }
    },
    {
        "question": "Set a wire to logic high using assign in Verilog",
        "outputs": [
            "```verilog\nassign wire_name = 1'b1;\n```",
            "```verilog\nassign wire_name = 1'b1;\n```",
            "```verilog\nassign wire_name = 1'b1;\n```",
            "```verilog\nassign wire_name = 1'b1;\n```",
            "```verilog\nassign wire_name = 1'b1;\n```",
            "```verilog\nassign wire_name = 1'b1;\n```",
            "```verilog\nassign wire_name = 1'b1;\n```",
            "```verilog\nassign wire_name = 1'b1;\n```",
            "```verilog\nassign wire_name = 1'b1;\n```",
            "```verilog\nassign wire_name = 1'b1;\n```"
        ],
        "config": {
            "model": "claude-opus-4-20250514",
            "system_instruction": "You are a Verilog code generator. Output only synthesizable Verilog code.",
            "temperature": 0.2,
            "max_tokens": 1024,
            "samples": 10
        }
    },
    {
        "question": "A 2 input AND gate in Verilog",
        "outputs": [
            "```verilog\nmodule and_gate (\n    input wire a,\n    input wire b,\n    output wire y\n);\n\n    assign y = a & b;\n\nendmodule\n```",
            "```verilog\nmodule and_gate (\n    input wire a,\n    input wire b,\n    output wire y\n);\n\n    assign y = a & b;\n\nendmodule\n```",
            "```verilog\nmodule and_gate (\n    input wire a,\n    input wire b,\n    output wire y\n);\n\nassign y = a & b;\n\nendmodule\n```",
            "```verilog\nmodule and_gate (\n    input wire a,\n    input wire b,\n    output wire y\n);\n\n    assign y = a & b;\n\nendmodule\n```",
            "```verilog\nmodule and_gate (\n    input wire a,\n    input wire b,\n    output wire y\n);\n\n    assign y = a & b;\n\nendmodule\n```",
            "```verilog\nmodule and_gate (\n    input wire a,\n    input wire b,\n    output wire y\n);\n\n    assign y = a & b;\n\nendmodule\n```",
            "```verilog\nmodule and_gate (\n    input wire a,\n    input wire b,\n    output wire y\n);\n\n    assign y = a & b;\n\nendmodule\n```",
            "```verilog\nmodule and_gate (\n    input wire a,\n    input wire b,\n    output wire y\n);\n\nassign y = a & b;\n\nendmodule\n```",
            "```verilog\nmodule and_gate (\n    input wire a,\n    input wire b,\n    output wire y\n);\n\n    assign y = a & b;\n\nendmodule\n```",
            "```verilog\nmodule and_gate (\n    input wire a,\n    input wire b,\n    output wire y\n);\n\n    assign y = a & b;\n\nendmodule\n```"
        ],
        "config": {
            "model": "claude-opus-4-20250514",
            "system_instruction": "You are a Verilog code generator. Output only synthesizable Verilog code.",
            "temperature": 0.2,
            "max_tokens": 1024,
            "samples": 10
        }
    },
    {
        "question": "Three bit priority encoder in Verilog",
        "outputs": [
            "Here's a synthesizable Verilog code for a 3-bit priority encoder:\n\n```verilog\nmodule priority_encoder_3bit (\n    input  wire [2:0] in,      // 3-bit input\n    output reg  [1:0] out,     // 2-bit encoded output\n    output reg        valid    // Valid output signal\n);\n\n    always @(*) begin\n        if (in[2]) begin\n            out = 2'b10;       // Highest priority\n            valid = 1'b1;\n        end\n        else if (in[1]) begin\n            out = 2'b01;\n            valid = 1'b1;\n        end\n        else if (in[0]) begin\n            out = 2'b00;\n            valid = 1'b1;\n        end\n        else begin\n            out = 2'b00;       // Default value\n            valid = 1'b0;      // No input active\n        end\n    end\n\nendmodule\n```\n\nThis priority encoder:\n- Takes a 3-bit input where bit 2 has the highest priority\n- Outputs a 2-bit encoded value representing the highest priority active input\n- Includes a valid signal that indicates when at least one input is active\n- Priority order: in[2] > in[1] > in[0]",
            "Here's a synthesizable 3-bit priority encoder in Verilog:\n\n```verilog\nmodule priority_encoder_3bit (\n    input  wire [2:0] in,      // 3-bit input\n    output reg  [1:0] out,     // 2-bit encoded output\n    output reg        valid    // Valid output signal\n);\n\n    always @(*) begin\n        if (in[2]) begin\n            out = 2'b10;       // Highest priority\n            valid = 1'b1;\n        end\n        else if (in[1]) begin\n            out = 2'b01;\n            valid = 1'b1;\n        end\n        else if (in[0]) begin\n            out = 2'b00;\n            valid = 1'b1;\n        end\n        else begin\n            out = 2'b00;       // Default value\n            valid = 1'b0;      // No input active\n        end\n    end\n\nendmodule\n```\n\nThis priority encoder:\n- Takes a 3-bit input where bit 2 has the highest priority\n- Outputs a 2-bit encoded value representing the highest priority active input\n- Includes a valid signal that indicates when at least one input is active\n- Is fully synthesizable using combinational logic",
            "Here's a synthesizable Verilog code for a 3-bit priority encoder:\n\n```verilog\nmodule priority_encoder_3bit (\n    input  wire [2:0] in,      // 3-bit input\n    output reg  [1:0] out,     // 2-bit encoded output\n    output reg        valid    // Valid output signal\n);\n\n    always @(*) begin\n        if (in[2]) begin\n            out = 2'b10;       // Highest priority\n            valid = 1'b1;\n        end\n        else if (in[1]) begin\n            out = 2'b01;\n            valid = 1'b1;\n        end\n        else if (in[0]) begin\n            out = 2'b00;       // Lowest priority\n            valid = 1'b1;\n        end\n        else begin\n            out = 2'b00;       // Default\n            valid = 1'b0;      // No input active\n        end\n    end\n\nendmodule\n```",
            "Here's a synthesizable Verilog code for a 3-bit priority encoder:\n\n```verilog\nmodule priority_encoder_3bit (\n    input  wire [2:0] in,      // 3-bit input\n    output reg  [1:0] out,     // 2-bit encoded output\n    output reg        valid    // Valid output signal\n);\n\n    always @(*) begin\n        if (in[2]) begin\n            out = 2'b10;       // Highest priority\n            valid = 1'b1;\n        end\n        else if (in[1]) begin\n            out = 2'b01;\n            valid = 1'b1;\n        end\n        else if (in[0]) begin\n            out = 2'b00;       // Lowest priority\n            valid = 1'b1;\n        end\n        else begin\n            out = 2'b00;       // Default\n            valid = 1'b0;      // No input active\n        end\n    end\n\nendmodule\n```",
            "Here's a synthesizable 3-bit priority encoder in Verilog:\n\n```verilog\nmodule priority_encoder_3bit (\n    input  wire [2:0] in,      // 3-bit input\n    output reg  [1:0] out,     // 2-bit encoded output\n    output reg        valid    // Valid output signal\n);\n\n    always @(*) begin\n        if (in[2]) begin\n            out = 2'b10;       // Highest priority\n            valid = 1'b1;\n        end\n        else if (in[1]) begin\n            out = 2'b01;\n            valid = 1'b1;\n        end\n        else if (in[0]) begin\n            out = 2'b00;\n            valid = 1'b1;\n        end\n        else begin\n            out = 2'b00;       // Default value\n            valid = 1'b0;      // No input active\n        end\n    end\n\nendmodule\n```\n\nThis priority encoder:\n- Takes a 3-bit input where bit 2 has the highest priority\n- Outputs a 2-bit encoded value representing the highest priority active input\n- Includes a valid signal that indicates when at least one input is active\n- Is fully synthesizable using combinational logic",
            "Here's a synthesizable Verilog code for a 3-bit priority encoder:\n\n```verilog\nmodule priority_encoder_3bit (\n    input  wire [2:0] in,      // 3-bit input\n    output reg  [1:0] out,     // 2-bit encoded output\n    output reg        valid    // Valid output signal\n);\n\n    always @(*) begin\n        if (in[2]) begin\n            out = 2'b10;       // Highest priority\n            valid = 1'b1;\n        end\n        else if (in[1]) begin\n            out = 2'b01;\n            valid = 1'b1;\n        end\n        else if (in[0]) begin\n            out = 2'b00;       // Lowest priority\n            valid = 1'b1;\n        end\n        else begin\n            out = 2'b00;       // Default\n            valid = 1'b0;      // No input active\n        end\n    end\n\nendmodule\n```",
            "Here's a synthesizable 3-bit priority encoder in Verilog:\n\n```verilog\nmodule priority_encoder_3bit (\n    input  wire [2:0] in,      // 3-bit input\n    output reg  [1:0] out,     // 2-bit encoded output\n    output reg        valid    // Valid output signal\n);\n\n    always @(*) begin\n        if (in[2]) begin\n            out = 2'b10;       // Highest priority\n            valid = 1'b1;\n        end\n        else if (in[1]) begin\n            out = 2'b01;\n            valid = 1'b1;\n        end\n        else if (in[0]) begin\n            out = 2'b00;\n            valid = 1'b1;\n        end\n        else begin\n            out = 2'b00;       // Default value\n            valid = 1'b0;      // No input active\n        end\n    end\n\nendmodule\n```\n\nThis priority encoder:\n- Takes a 3-bit input where bit 2 has the highest priority\n- Outputs a 2-bit encoded value representing the highest priority active input\n- Includes a valid signal that indicates when at least one input is active\n- Is fully synthesizable using combinational logic",
            "Here's a synthesizable 3-bit priority encoder in Verilog:\n\n```verilog\nmodule priority_encoder_3bit (\n    input  wire [2:0] in,      // 3-bit input\n    output reg  [1:0] out,     // 2-bit encoded output\n    output reg        valid    // Valid output signal\n);\n\n    always @(*) begin\n        if (in[2]) begin\n            out = 2'b10;       // Highest priority\n            valid = 1'b1;\n        end\n        else if (in[1]) begin\n            out = 2'b01;\n            valid = 1'b1;\n        end\n        else if (in[0]) begin\n            out = 2'b00;\n            valid = 1'b1;\n        end\n        else begin\n            out = 2'b00;       // Default value\n            valid = 1'b0;      // No input active\n        end\n    end\n\nendmodule\n```\n\nThis priority encoder:\n- Takes a 3-bit input where bit 2 has the highest priority\n- Outputs a 2-bit encoded value representing the highest priority active input\n- Includes a valid signal that indicates when at least one input is active\n- Is fully synthesizable using combinational logic",
            "Here's a synthesizable Verilog code for a 3-bit priority encoder:\n\n```verilog\nmodule priority_encoder_3bit (\n    input  wire [2:0] in,      // 3-bit input\n    output reg  [1:0] out,     // 2-bit encoded output\n    output reg        valid    // Valid output signal\n);\n\n    always @(*) begin\n        if (in[2]) begin\n            out = 2'b10;       // Highest priority\n            valid = 1'b1;\n        end\n        else if (in[1]) begin\n            out = 2'b01;\n            valid = 1'b1;\n        end\n        else if (in[0]) begin\n            out = 2'b00;       // Lowest priority\n            valid = 1'b1;\n        end\n        else begin\n            out = 2'b00;       // Default\n            valid = 1'b0;      // No input active\n        end\n    end\n\nendmodule\n```",
            "Here's a synthesizable Verilog code for a 3-bit priority encoder:\n\n```verilog\nmodule priority_encoder_3bit (\n    input  wire [2:0] in,      // 3-bit input\n    output reg  [1:0] out,     // 2-bit encoded output\n    output reg        valid    // Valid output signal\n);\n\n    always @(*) begin\n        if (in[2]) begin\n            out = 2'b10;       // Highest priority\n            valid = 1'b1;\n        end\n        else if (in[1]) begin\n            out = 2'b01;\n            valid = 1'b1;\n        end\n        else if (in[0]) begin\n            out = 2'b00;       // Lowest priority\n            valid = 1'b1;\n        end\n        else begin\n            out = 2'b00;       // Default\n            valid = 1'b0;      // No input active\n        end\n    end\n\nendmodule\n```"
        ],
        "config": {
            "model": "claude-opus-4-20250514",
            "system_instruction": "You are a Verilog code generator. Output only synthesizable Verilog code.",
            "temperature": 0.2,
            "max_tokens": 1024,
            "samples": 10
        }
    },
    {
        "question": "Simple Verilog example of a two-input multiplexer",
        "outputs": [
            "```verilog\nmodule mux2to1 (\n    input wire a,      // Input 0\n    input wire b,      // Input 1\n    input wire sel,    // Select signal\n    output wire y      // Output\n);\n\n    assign y = sel ? b : a;\n\nendmodule\n```",
            "```verilog\nmodule mux2to1 (\n    input wire a,      // Input 0\n    input wire b,      // Input 1\n    input wire sel,    // Select signal\n    output wire y      // Output\n);\n\n    assign y = sel ? b : a;\n\nendmodule\n```",
            "```verilog\nmodule mux2to1 (\n    input wire a,      // Input 0\n    input wire b,      // Input 1\n    input wire sel,    // Select signal\n    output wire y      // Output\n);\n\n    assign y = sel ? b : a;\n\nendmodule\n```",
            "```verilog\nmodule mux2to1 (\n    input wire a,      // Input 0\n    input wire b,      // Input 1\n    input wire sel,    // Select signal\n    output wire y      // Output\n);\n\n    assign y = sel ? b : a;\n\nendmodule\n```",
            "```verilog\nmodule mux2to1 (\n    input wire a,      // Input 0\n    input wire b,      // Input 1\n    input wire sel,    // Select signal\n    output wire y      // Output\n);\n\n    assign y = sel ? b : a;\n\nendmodule\n```",
            "```verilog\nmodule mux2to1 (\n    input wire a,      // First data input\n    input wire b,      // Second data input\n    input wire sel,    // Select signal\n    output wire y      // Output\n);\n\n    assign y = sel ? b : a;\n\nendmodule\n```",
            "```verilog\nmodule mux2to1 (\n    input wire sel,      // Select signal\n    input wire a,        // Input 0\n    input wire b,        // Input 1\n    output wire y        // Output\n);\n\n    assign y = sel ? b : a;\n\nendmodule\n```",
            "```verilog\nmodule mux2to1 (\n    input wire a,      // Input 0\n    input wire b,      // Input 1\n    input wire sel,    // Select signal\n    output wire y      // Output\n);\n\n    assign y = sel ? b : a;\n\nendmodule\n```",
            "```verilog\nmodule mux2to1 (\n    input wire a,      // Input 0\n    input wire b,      // Input 1\n    input wire sel,    // Select signal\n    output wire y      // Output\n);\n\n    assign y = sel ? b : a;\n\nendmodule\n```",
            "```verilog\nmodule mux2to1 (\n    input wire a,      // Input 0\n    input wire b,      // Input 1\n    input wire sel,    // Select signal\n    output wire y      // Output\n);\n\n    assign y = sel ? b : a;\n\nendmodule\n```"
        ],
        "config": {
            "model": "claude-opus-4-20250514",
            "system_instruction": "You are a Verilog code generator. Output only synthesizable Verilog code.",
            "temperature": 0.2,
            "max_tokens": 1024,
            "samples": 10
        }
    },
    {
        "question": "Write Verilog code for a half adder",
        "outputs": [
            "```verilog\nmodule half_adder (\n    input  wire a,\n    input  wire b,\n    output wire sum,\n    output wire carry\n);\n\n    assign sum = a ^ b;\n    assign carry = a & b;\n\nendmodule\n```",
            "```verilog\nmodule half_adder (\n    input  wire a,\n    input  wire b,\n    output wire sum,\n    output wire carry\n);\n\n    assign sum = a ^ b;\n    assign carry = a & b;\n\nendmodule\n```",
            "```verilog\nmodule half_adder (\n    input  wire a,\n    input  wire b,\n    output wire sum,\n    output wire carry\n);\n\n    assign sum = a ^ b;\n    assign carry = a & b;\n\nendmodule\n```",
            "```verilog\nmodule half_adder (\n    input  wire a,\n    input  wire b,\n    output wire sum,\n    output wire carry\n);\n\n    assign sum = a ^ b;\n    assign carry = a & b;\n\nendmodule\n```",
            "```verilog\nmodule half_adder (\n    input  wire a,\n    input  wire b,\n    output wire sum,\n    output wire carry\n);\n\n    assign sum = a ^ b;\n    assign carry = a & b;\n\nendmodule\n```",
            "```verilog\nmodule half_adder (\n    input  wire a,\n    input  wire b,\n    output wire sum,\n    output wire carry\n);\n\n    assign sum = a ^ b;\n    assign carry = a & b;\n\nendmodule\n```",
            "```verilog\nmodule half_adder (\n    input  wire a,\n    input  wire b,\n    output wire sum,\n    output wire carry\n);\n\n    assign sum = a ^ b;\n    assign carry = a & b;\n\nendmodule\n```",
            "```verilog\nmodule half_adder (\n    input  wire a,\n    input  wire b,\n    output wire sum,\n    output wire carry\n);\n\n    assign sum = a ^ b;\n    assign carry = a & b;\n\nendmodule\n```",
            "```verilog\nmodule half_adder (\n    input  a,\n    input  b,\n    output sum,\n    output carry\n);\n\n    assign sum = a ^ b;\n    assign carry = a & b;\n\nendmodule\n```",
            "```verilog\nmodule half_adder (\n    input  wire a,\n    input  wire b,\n    output wire sum,\n    output wire carry\n);\n\n    assign sum = a ^ b;\n    assign carry = a & b;\n\nendmodule\n```"
        ],
        "config": {
            "model": "claude-opus-4-20250514",
            "system_instruction": "You are a Verilog code generator. Output only synthesizable Verilog code.",
            "temperature": 0.2,
            "max_tokens": 1024,
            "samples": 10
        }
    },
    {
        "question": "1 to 12 counter in Verilog",
        "outputs": [
            "Here's a synthesizable Verilog code for a 1 to 12 counter:\n\n```verilog\nmodule counter_1_to_12 (\n    input wire clk,\n    input wire rst,\n    output reg [3:0] count\n);\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            count <= 4'd1;\n        end\n        else begin\n            if (count == 4'd12)\n                count <= 4'd1;\n            else\n                count <= count + 4'd1;\n        end\n    end\n\nendmodule\n```\n\nThis counter:\n- Counts from 1 to 12 and then wraps back to 1\n- Uses a 4-bit register (supports values 0-15)\n- Has synchronous counting on positive clock edge\n- Has asynchronous reset that sets the counter to 1\n- When count reaches 12, it resets to 1 on the next clock cycle",
            "Here's a synthesizable Verilog code for a 1 to 12 counter:\n\n```verilog\nmodule counter_1_to_12 (\n    input wire clk,\n    input wire rst,\n    output reg [3:0] count\n);\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            count <= 4'd1;\n        end\n        else begin\n            if (count == 4'd12)\n                count <= 4'd1;\n            else\n                count <= count + 4'd1;\n        end\n    end\n\nendmodule\n```\n\nThis counter:\n- Counts from 1 to 12 and then wraps back to 1\n- Uses a 4-bit register (supports values 0-15)\n- Has synchronous counting on positive clock edge\n- Has asynchronous reset that sets the counter to 1\n- When count reaches 12, it resets to 1 on the next clock cycle",
            "Here's a synthesizable Verilog code for a 1 to 12 counter:\n\n```verilog\nmodule counter_1_to_12 (\n    input wire clk,\n    input wire rst,\n    output reg [3:0] count\n);\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            count <= 4'd1;\n        end\n        else begin\n            if (count == 4'd12)\n                count <= 4'd1;\n            else\n                count <= count + 4'd1;\n        end\n    end\n\nendmodule\n```\n\nThis counter:\n- Counts from 1 to 12 and then wraps back to 1\n- Uses a 4-bit register (supports values 0-15)\n- Has synchronous operation with clock (clk)\n- Has asynchronous reset (rst) that sets count to 1\n- Increments on each positive clock edge\n- Automatically rolls over from 12 back to 1",
            "Here's a synthesizable Verilog code for a 1 to 12 counter:\n\n```verilog\nmodule counter_1_to_12 (\n    input wire clk,\n    input wire rst,\n    output reg [3:0] count\n);\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            count <= 4'd1;\n        end\n        else begin\n            if (count == 4'd12)\n                count <= 4'd1;\n            else\n                count <= count + 4'd1;\n        end\n    end\n\nendmodule\n```\n\nThis counter:\n- Counts from 1 to 12 and then wraps back to 1\n- Uses a 4-bit output (supports values 0-15)\n- Has synchronous counting on positive clock edge\n- Has asynchronous reset that sets the counter to 1\n- When count reaches 12, it resets to 1 on the next clock cycle",
            "Here's a synthesizable Verilog code for a 1 to 12 counter:\n\n```verilog\nmodule counter_1_to_12 (\n    input wire clk,\n    input wire rst,\n    output reg [3:0] count\n);\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            count <= 4'd1;\n        end\n        else begin\n            if (count == 4'd12)\n                count <= 4'd1;\n            else\n                count <= count + 4'd1;\n        end\n    end\n\nendmodule\n```\n\nThis counter:\n- Counts from 1 to 12 and then wraps back to 1\n- Uses a 4-bit register (supports values 0-15)\n- Has synchronous counting on positive clock edge\n- Has asynchronous reset that sets the counter to 1\n- When count reaches 12, it resets to 1 on the next clock cycle",
            "Here's a synthesizable Verilog code for a 1 to 12 counter:\n\n```verilog\nmodule counter_1_to_12 (\n    input wire clk,\n    input wire rst,\n    output reg [3:0] count\n);\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            count <= 4'd1;\n        end\n        else begin\n            if (count == 4'd12)\n                count <= 4'd1;\n            else\n                count <= count + 4'd1;\n        end\n    end\n\nendmodule\n```\n\nThis counter:\n- Counts from 1 to 12 and then wraps back to 1\n- Uses a 4-bit register (supports values 0-15)\n- Has synchronous counting on positive clock edge\n- Has asynchronous reset that sets the counter to 1\n- When count reaches 12, it resets to 1 on the next clock cycle",
            "Here's a synthesizable Verilog code for a 1 to 12 counter:\n\n```verilog\nmodule counter_1_to_12 (\n    input wire clk,\n    input wire rst,\n    output reg [3:0] count\n);\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            count <= 4'd1;\n        end\n        else begin\n            if (count == 4'd12)\n                count <= 4'd1;\n            else\n                count <= count + 4'd1;\n        end\n    end\n\nendmodule\n```\n\nThis counter:\n- Counts from 1 to 12 and then wraps back to 1\n- Uses a 4-bit register (supports values 0-15)\n- Has synchronous counting on positive clock edge\n- Has asynchronous reset that sets the counter to 1\n- When count reaches 12, it resets to 1 on the next clock cycle",
            "Here's a synthesizable Verilog code for a 1 to 12 counter:\n\n```verilog\nmodule counter_1_to_12 (\n    input wire clk,\n    input wire rst,\n    output reg [3:0] count\n);\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            count <= 4'd1;\n        end\n        else begin\n            if (count == 4'd12)\n                count <= 4'd1;\n            else\n                count <= count + 4'd1;\n        end\n    end\n\nendmodule\n```\n\nThis counter:\n- Counts from 1 to 12 and then wraps back to 1\n- Uses a 4-bit register (supports values 0-15)\n- Has synchronous counting on positive clock edge\n- Has asynchronous reset that sets the counter to 1\n- When count reaches 12, it resets to 1 on the next clock cycle",
            "Here's a synthesizable Verilog code for a 1 to 12 counter:\n\n```verilog\nmodule counter_1_to_12 (\n    input wire clk,\n    input wire rst,\n    output reg [3:0] count\n);\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            count <= 4'd1;\n        end\n        else begin\n            if (count == 4'd12)\n                count <= 4'd1;\n            else\n                count <= count + 4'd1;\n        end\n    end\n\nendmodule\n```\n\nThis counter:\n- Counts from 1 to 12 and then wraps back to 1\n- Uses a 4-bit register (supports values 0-15)\n- Has synchronous counting on positive clock edge\n- Has asynchronous reset that sets the counter to 1\n- When count reaches 12, it resets to 1 on the next clock cycle",
            "Here's a synthesizable Verilog code for a 1 to 12 counter:\n\n```verilog\nmodule counter_1_to_12 (\n    input wire clk,\n    input wire rst,\n    output reg [3:0] count\n);\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            count <= 4'd1;\n        end\n        else begin\n            if (count == 4'd12)\n                count <= 4'd1;\n            else\n                count <= count + 4'd1;\n        end\n    end\n\nendmodule\n```\n\nThis counter:\n- Counts from 1 to 12 and then wraps back to 1\n- Uses a 4-bit register (supports values 0-15)\n- Has synchronous counting on positive clock edge\n- Has asynchronous reset that sets the counter to 1\n- When count reaches 12, it resets to 1 on the next clock cycle"
        ],
        "config": {
            "model": "claude-opus-4-20250514",
            "system_instruction": "You are a Verilog code generator. Output only synthesizable Verilog code.",
            "temperature": 0.2,
            "max_tokens": 1024,
            "samples": 10
        }
    },
    {
        "question": "Implement a pseudo-random LFSR in Verilog with taps on bit 3 and bit 5",
        "outputs": [
            "Here's a synthesizable Verilog implementation of a pseudo-random LFSR with taps on bits 3 and 5:\n\n```verilog\nmodule lfsr_random (\n    input wire clk,\n    input wire rst_n,\n    input wire enable,\n    output reg [7:0] lfsr_out\n);\n\n    wire feedback;\n    \n    // XOR feedback from bit positions 3 and 5 (0-indexed)\n    assign feedback = lfsr_out[3] ^ lfsr_out[5];\n    \n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            // Initialize with non-zero seed value\n            lfsr_out <= 8'b10101010;\n        end\n        else if (enable) begin\n            // Shift left and insert feedback bit at LSB\n            lfsr_out <= {lfsr_out[6:0], feedback};\n        end\n    end\n\nendmodule\n```\n\nThis implementation features:\n- 8-bit LFSR register\n- Taps at bit positions 3 and 5 (0-indexed)\n- Active-low asynchronous reset\n- Enable signal to control when the LFSR updates\n- Non-zero seed value (8'b10101010) to ensure the LFSR doesn't get stuck at zero\n- Left-shift operation with feedback bit inserted at the LSB\n\nThe feedback is calculated using XOR of the tapped bits, creating a maximal-length sequence for proper tap selection.",
            "Here's a synthesizable Verilog implementation of a pseudo-random LFSR with taps on bits 3 and 5:\n\n```verilog\nmodule lfsr_random (\n    input  wire       clk,\n    input  wire       rst_n,\n    input  wire       enable,\n    output reg  [7:0] lfsr_out\n);\n\n    wire feedback;\n    \n    // XOR feedback from taps at bit positions 3 and 5\n    assign feedback = lfsr_out[3] ^ lfsr_out[5];\n    \n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            // Initialize with non-zero seed value\n            lfsr_out <= 8'b10101010;\n        end\n        else if (enable) begin\n            // Shift left and insert feedback bit at LSB\n            lfsr_out <= {lfsr_out[6:0], feedback};\n        end\n    end\n\nendmodule\n```\n\nThis implementation features:\n- 8-bit LFSR register\n- Taps at bit positions 3 and 5 (0-indexed)\n- Active-low asynchronous reset\n- Enable signal to control when the LFSR updates\n- Non-zero seed value (8'b10101010) to ensure the LFSR doesn't get stuck at all zeros\n- Left shift operation with feedback bit inserted at the LSB\n\nThe feedback is calculated by XORing bits 3 and 5, creating a maximal-length sequence for proper tap selection.",
            "Here's a synthesizable Verilog implementation of a pseudo-random LFSR with taps on bits 3 and 5:\n\n```verilog\nmodule lfsr_random (\n    input wire clk,\n    input wire rst_n,\n    input wire enable,\n    output reg [7:0] lfsr_out\n);\n\n    wire feedback;\n    \n    // XOR feedback from bit positions 3 and 5 (0-indexed)\n    assign feedback = lfsr_out[3] ^ lfsr_out[5];\n    \n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            // Initialize with non-zero seed value\n            lfsr_out <= 8'b10101010;\n        end\n        else if (enable) begin\n            // Shift left and insert feedback bit at LSB\n            lfsr_out <= {lfsr_out[6:0], feedback};\n        end\n    end\n\nendmodule\n```\n\nThis implementation features:\n- 8-bit LFSR register\n- Taps at bit positions 3 and 5 (0-indexed)\n- Active-low asynchronous reset with non-zero seed value\n- Enable signal to control when the LFSR updates\n- Feedback generated by XORing the tapped bits\n- Left shift operation with feedback inserted at the LSB\n\nThe LFSR will generate a pseudo-random sequence with a period of up to 2^8-1 = 255 states (excluding the all-zeros state).",
            "Here's a synthesizable Verilog implementation of a pseudo-random LFSR with taps on bits 3 and 5:\n\n```verilog\nmodule lfsr_random (\n    input wire clk,\n    input wire rst_n,\n    input wire enable,\n    output reg [7:0] lfsr_out\n);\n\n    wire feedback;\n    \n    // XOR feedback from bit positions 3 and 5 (0-indexed)\n    assign feedback = lfsr_out[3] ^ lfsr_out[5];\n    \n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            // Initialize with non-zero seed value\n            lfsr_out <= 8'b10101010;\n        end\n        else if (enable) begin\n            // Shift left and insert feedback bit at LSB\n            lfsr_out <= {lfsr_out[6:0], feedback};\n        end\n    end\n\nendmodule\n```\n\nThis implementation features:\n- 8-bit LFSR register\n- Taps at bit positions 3 and 5 (0-indexed)\n- Active-low asynchronous reset\n- Enable signal to control when the LFSR updates\n- Non-zero seed value (8'b10101010) to ensure the LFSR doesn't get stuck at zero\n- Left-shift operation with feedback bit inserted at the LSB",
            "Here's a synthesizable Verilog implementation of a pseudo-random LFSR with taps on bits 3 and 5:\n\n```verilog\nmodule lfsr_random (\n    input wire clk,\n    input wire rst_n,\n    input wire enable,\n    output reg [7:0] lfsr_out\n);\n\n    wire feedback;\n    \n    // XOR feedback from bit positions 3 and 5 (0-indexed)\n    assign feedback = lfsr_out[3] ^ lfsr_out[5];\n    \n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            // Initialize with non-zero seed value\n            lfsr_out <= 8'b10101010;\n        end\n        else if (enable) begin\n            // Shift left and insert feedback bit at LSB\n            lfsr_out <= {lfsr_out[6:0], feedback};\n        end\n    end\n\nendmodule\n```\n\nThis implementation features:\n- 8-bit LFSR register\n- Taps at bit positions 3 and 5 (0-indexed)\n- Active-low asynchronous reset with non-zero seed value\n- Enable signal to control when the LFSR updates\n- Feedback generated by XORing the tapped bits\n- Left shift operation with feedback inserted at the LSB\n\nThe non-zero seed value (8'b10101010) ensures the LFSR doesn't get stuck in an all-zeros state. You can modify the seed value as needed for your application.",
            "Here's a synthesizable Verilog implementation of a pseudo-random LFSR with taps on bits 3 and 5:\n\n```verilog\nmodule lfsr (\n    input wire clk,\n    input wire rst_n,\n    input wire enable,\n    output reg [7:0] lfsr_out\n);\n\n    wire feedback;\n    \n    // XOR feedback from bit positions 3 and 5 (0-indexed)\n    assign feedback = lfsr_out[3] ^ lfsr_out[5];\n    \n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            // Initialize with non-zero seed value\n            lfsr_out <= 8'b10101010;\n        end\n        else if (enable) begin\n            // Shift left and insert feedback bit at LSB\n            lfsr_out <= {lfsr_out[6:0], feedback};\n        end\n    end\n\nendmodule\n```\n\nThis implementation features:\n- 8-bit LFSR register\n- Taps at bit positions 3 and 5 (0-indexed)\n- Active-low asynchronous reset\n- Enable signal to control when the LFSR updates\n- Non-zero seed value (8'b10101010) to ensure proper operation\n- Left shift with feedback inserted at the LSB\n\nThe feedback is calculated by XORing bits 3 and 5, creating a maximal-length sequence generator.",
            "Here's a synthesizable Verilog implementation of a pseudo-random LFSR with taps on bits 3 and 5:\n\n```verilog\nmodule lfsr_random (\n    input wire clk,\n    input wire rst_n,\n    input wire enable,\n    output reg [7:0] lfsr_out\n);\n\n    wire feedback;\n    \n    // XOR feedback from bit 3 and bit 5 (0-indexed)\n    assign feedback = lfsr_out[3] ^ lfsr_out[5];\n    \n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            // Initialize with non-zero seed value\n            lfsr_out <= 8'b10101010;\n        end\n        else if (enable) begin\n            // Shift left and insert feedback bit at LSB\n            lfsr_out <= {lfsr_out[6:0], feedback};\n        end\n    end\n\nendmodule\n```\n\nThis implementation features:\n- 8-bit LFSR register\n- Taps at positions 3 and 5 (0-indexed)\n- Active-low asynchronous reset\n- Enable signal to control when the LFSR updates\n- Non-zero seed value (8'b10101010) to ensure the LFSR doesn't get stuck at all zeros\n- Left shift with feedback inserted at the LSB\n\nThe feedback is generated by XORing bits 3 and 5, creating a maximal-length sequence for proper tap selection.",
            "Here's a synthesizable Verilog implementation of a pseudo-random LFSR with taps on bits 3 and 5:\n\n```verilog\nmodule lfsr_random (\n    input wire clk,\n    input wire rst_n,\n    input wire enable,\n    output reg [7:0] lfsr_out\n);\n\n    wire feedback;\n    \n    // XOR feedback from bit positions 3 and 5 (0-indexed)\n    assign feedback = lfsr_out[3] ^ lfsr_out[5];\n    \n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            // Initialize with non-zero seed value\n            lfsr_out <= 8'b10101010;\n        end\n        else if (enable) begin\n            // Shift left and insert feedback bit at LSB\n            lfsr_out <= {lfsr_out[6:0], feedback};\n        end\n    end\n\nendmodule\n```\n\nThis implementation features:\n- 8-bit LFSR register\n- Taps at bit positions 3 and 5 (0-indexed)\n- Active-low asynchronous reset\n- Enable signal to control when the LFSR updates\n- Non-zero seed value (8'b10101010) to ensure the LFSR doesn't get stuck at zero\n- Left-shift operation with feedback bit inserted at the LSB\n\nThe feedback is calculated using XOR of the tapped bits, which creates the pseudo-random sequence.",
            "Here's a synthesizable Verilog implementation of a pseudo-random LFSR with taps on bits 3 and 5:\n\n```verilog\nmodule lfsr_random (\n    input wire clk,\n    input wire rst_n,\n    input wire enable,\n    output reg [7:0] lfsr_out\n);\n\n    wire feedback;\n    \n    // XOR feedback from bit positions 3 and 5 (0-indexed)\n    assign feedback = lfsr_out[3] ^ lfsr_out[5];\n    \n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            // Initialize with non-zero seed value\n            lfsr_out <= 8'b10101010;\n        end\n        else if (enable) begin\n            // Shift left and insert feedback bit at LSB\n            lfsr_out <= {lfsr_out[6:0], feedback};\n        end\n    end\n\nendmodule\n```\n\nThis implementation features:\n- 8-bit LFSR register\n- Taps at bit positions 3 and 5 (0-indexed)\n- Active-low asynchronous reset with non-zero seed value\n- Enable signal to control when the LFSR updates\n- Feedback generated by XORing the tapped bits\n- Left shift operation with feedback inserted at the LSB\n\nThe LFSR will generate a pseudo-random sequence with a period of up to 2^8-1 = 255 states (excluding the all-zeros state).",
            "Here's a synthesizable Verilog implementation of a pseudo-random LFSR with taps on bits 3 and 5:\n\n```verilog\nmodule lfsr_random (\n    input wire clk,\n    input wire rst_n,\n    input wire enable,\n    output reg [7:0] lfsr_out\n);\n\n    wire feedback;\n    \n    // XOR feedback from taps at bit positions 3 and 5\n    assign feedback = lfsr_out[3] ^ lfsr_out[5];\n    \n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            // Initialize with non-zero seed value\n            lfsr_out <= 8'b10101010;\n        end\n        else if (enable) begin\n            // Shift left and insert feedback bit at LSB\n            lfsr_out <= {lfsr_out[6:0], feedback};\n        end\n    end\n\nendmodule\n```\n\nThis implementation features:\n- 8-bit LFSR register\n- Taps at bit positions 3 and 5 (0-indexed)\n- Active-low asynchronous reset\n- Enable signal to control when the LFSR updates\n- Non-zero seed value (8'b10101010) to ensure the LFSR doesn't get stuck at all zeros\n- Left shift operation with feedback bit inserted at the LSB position\n\nThe feedback is calculated by XORing bits 3 and 5, creating a maximal-length sequence generator that will cycle through pseudo-random values."
        ],
        "config": {
            "model": "claude-opus-4-20250514",
            "system_instruction": "You are a Verilog code generator. Output only synthesizable Verilog code.",
            "temperature": 0.2,
            "max_tokens": 1024,
            "samples": 10
        }
    },
    {
        "question": "FSM with two states in Verilog",
        "outputs": [
            "Here's a simple two-state FSM in Verilog:\n\n```verilog\nmodule two_state_fsm (\n    input wire clk,\n    input wire rst,\n    input wire in,\n    output reg out\n);\n\n    // State encoding\n    parameter STATE_A = 1'b0;\n    parameter STATE_B = 1'b1;\n    \n    // State register\n    reg current_state, next_state;\n    \n    // State register (sequential logic)\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            current_state <= STATE_A;\n        else\n            current_state <= next_state;\n    end\n    \n    // Next state logic (combinational)\n    always @(*) begin\n        case (current_state)\n            STATE_A: begin\n                if (in)\n                    next_state = STATE_B;\n                else\n                    next_state = STATE_A;\n            end\n            \n            STATE_B: begin\n                if (in)\n                    next_state = STATE_A;\n                else\n                    next_state = STATE_B;\n            end\n            \n            default: next_state = STATE_A;\n        endcase\n    end\n    \n    // Output logic (combinational)\n    always @(*) begin\n        case (current_state)\n            STATE_A: out = 1'b0;\n            STATE_B: out = 1'b1;\n            default: out = 1'b0;\n        endcase\n    end\n\nendmodule\n```",
            "Here's a simple two-state FSM in Verilog:\n\n```verilog\nmodule two_state_fsm (\n    input wire clk,\n    input wire rst,\n    input wire in,\n    output reg out\n);\n\n    // State encoding\n    parameter STATE_A = 1'b0;\n    parameter STATE_B = 1'b1;\n    \n    // State register\n    reg current_state, next_state;\n    \n    // State register (sequential logic)\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            current_state <= STATE_A;\n        else\n            current_state <= next_state;\n    end\n    \n    // Next state logic (combinational)\n    always @(*) begin\n        case (current_state)\n            STATE_A: begin\n                if (in)\n                    next_state = STATE_B;\n                else\n                    next_state = STATE_A;\n            end\n            \n            STATE_B: begin\n                if (in)\n                    next_state = STATE_A;\n                else\n                    next_state = STATE_B;\n            end\n            \n            default: next_state = STATE_A;\n        endcase\n    end\n    \n    // Output logic (combinational)\n    always @(*) begin\n        case (current_state)\n            STATE_A: out = 1'b0;\n            STATE_B: out = 1'b1;\n            default: out = 1'b0;\n        endcase\n    end\n\nendmodule\n```",
            "Here's a simple two-state FSM in Verilog:\n\n```verilog\nmodule two_state_fsm (\n    input wire clk,\n    input wire rst,\n    input wire in,\n    output reg out\n);\n\n    // State encoding\n    parameter STATE_A = 1'b0;\n    parameter STATE_B = 1'b1;\n    \n    // State register\n    reg current_state, next_state;\n    \n    // State register (sequential logic)\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            current_state <= STATE_A;\n        else\n            current_state <= next_state;\n    end\n    \n    // Next state logic (combinational)\n    always @(*) begin\n        case (current_state)\n            STATE_A: begin\n                if (in)\n                    next_state = STATE_B;\n                else\n                    next_state = STATE_A;\n            end\n            \n            STATE_B: begin\n                if (in)\n                    next_state = STATE_A;\n                else\n                    next_state = STATE_B;\n            end\n            \n            default: next_state = STATE_A;\n        endcase\n    end\n    \n    // Output logic (combinational)\n    always @(*) begin\n        case (current_state)\n            STATE_A: out = 1'b0;\n            STATE_B: out = 1'b1;\n            default: out = 1'b0;\n        endcase\n    end\n\nendmodule\n```",
            "Here's a simple two-state FSM in Verilog:\n\n```verilog\nmodule two_state_fsm (\n    input wire clk,\n    input wire rst,\n    input wire in,\n    output reg out\n);\n\n    // State encoding\n    parameter STATE_A = 1'b0;\n    parameter STATE_B = 1'b1;\n    \n    // State register\n    reg current_state, next_state;\n    \n    // State register (sequential logic)\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            current_state <= STATE_A;\n        else\n            current_state <= next_state;\n    end\n    \n    // Next state logic (combinational)\n    always @(*) begin\n        case (current_state)\n            STATE_A: begin\n                if (in)\n                    next_state = STATE_B;\n                else\n                    next_state = STATE_A;\n            end\n            \n            STATE_B: begin\n                if (in)\n                    next_state = STATE_A;\n                else\n                    next_state = STATE_B;\n            end\n            \n            default: next_state = STATE_A;\n        endcase\n    end\n    \n    // Output logic (combinational)\n    always @(*) begin\n        case (current_state)\n            STATE_A: out = 1'b0;\n            STATE_B: out = 1'b1;\n            default: out = 1'b0;\n        endcase\n    end\n\nendmodule\n```",
            "Here's a simple two-state FSM in Verilog:\n\n```verilog\nmodule two_state_fsm (\n    input wire clk,\n    input wire rst,\n    input wire in,\n    output reg out\n);\n\n    // State encoding\n    parameter STATE_A = 1'b0;\n    parameter STATE_B = 1'b1;\n    \n    // State register\n    reg current_state, next_state;\n    \n    // State register (sequential logic)\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            current_state <= STATE_A;\n        else\n            current_state <= next_state;\n    end\n    \n    // Next state logic (combinational)\n    always @(*) begin\n        case (current_state)\n            STATE_A: begin\n                if (in)\n                    next_state = STATE_B;\n                else\n                    next_state = STATE_A;\n            end\n            \n            STATE_B: begin\n                if (in)\n                    next_state = STATE_A;\n                else\n                    next_state = STATE_B;\n            end\n            \n            default: next_state = STATE_A;\n        endcase\n    end\n    \n    // Output logic (combinational)\n    always @(*) begin\n        case (current_state)\n            STATE_A: out = 1'b0;\n            STATE_B: out = 1'b1;\n            default: out = 1'b0;\n        endcase\n    end\n\nendmodule\n```",
            "Here's a simple two-state FSM in Verilog:\n\n```verilog\nmodule two_state_fsm (\n    input wire clk,\n    input wire rst,\n    input wire in,\n    output reg out\n);\n\n    // State encoding\n    parameter STATE_A = 1'b0;\n    parameter STATE_B = 1'b1;\n    \n    // State register\n    reg current_state, next_state;\n    \n    // State register (sequential logic)\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            current_state <= STATE_A;\n        else\n            current_state <= next_state;\n    end\n    \n    // Next state logic (combinational)\n    always @(*) begin\n        case (current_state)\n            STATE_A: begin\n                if (in)\n                    next_state = STATE_B;\n                else\n                    next_state = STATE_A;\n            end\n            \n            STATE_B: begin\n                if (in)\n                    next_state = STATE_A;\n                else\n                    next_state = STATE_B;\n            end\n            \n            default: next_state = STATE_A;\n        endcase\n    end\n    \n    // Output logic (combinational)\n    always @(*) begin\n        case (current_state)\n            STATE_A: out = 1'b0;\n            STATE_B: out = 1'b1;\n            default: out = 1'b0;\n        endcase\n    end\n\nendmodule\n```",
            "Here's a simple two-state FSM in Verilog:\n\n```verilog\nmodule two_state_fsm (\n    input wire clk,\n    input wire rst,\n    input wire in,\n    output reg out\n);\n\n    // State encoding\n    parameter STATE_A = 1'b0;\n    parameter STATE_B = 1'b1;\n    \n    // State register\n    reg current_state, next_state;\n    \n    // State register (sequential logic)\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            current_state <= STATE_A;\n        else\n            current_state <= next_state;\n    end\n    \n    // Next state logic (combinational)\n    always @(*) begin\n        case (current_state)\n            STATE_A: begin\n                if (in)\n                    next_state = STATE_B;\n                else\n                    next_state = STATE_A;\n            end\n            \n            STATE_B: begin\n                if (in)\n                    next_state = STATE_A;\n                else\n                    next_state = STATE_B;\n            end\n            \n            default: next_state = STATE_A;\n        endcase\n    end\n    \n    // Output logic (combinational)\n    always @(*) begin\n        case (current_state)\n            STATE_A: out = 1'b0;\n            STATE_B: out = 1'b1;\n            default: out = 1'b0;\n        endcase\n    end\n\nendmodule\n```",
            "Here's a simple two-state FSM in Verilog:\n\n```verilog\nmodule two_state_fsm (\n    input wire clk,\n    input wire rst,\n    input wire in,\n    output reg out\n);\n\n    // State encoding\n    parameter STATE_A = 1'b0;\n    parameter STATE_B = 1'b1;\n    \n    // State register\n    reg current_state, next_state;\n    \n    // State register (sequential logic)\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            current_state <= STATE_A;\n        else\n            current_state <= next_state;\n    end\n    \n    // Next state logic (combinational)\n    always @(*) begin\n        case (current_state)\n            STATE_A: begin\n                if (in)\n                    next_state = STATE_B;\n                else\n                    next_state = STATE_A;\n            end\n            \n            STATE_B: begin\n                if (in)\n                    next_state = STATE_A;\n                else\n                    next_state = STATE_B;\n            end\n            \n            default: next_state = STATE_A;\n        endcase\n    end\n    \n    // Output logic (combinational)\n    always @(*) begin\n        case (current_state)\n            STATE_A: out = 1'b0;\n            STATE_B: out = 1'b1;\n            default: out = 1'b0;\n        endcase\n    end\n\nendmodule\n```",
            "Here's a simple two-state FSM in Verilog:\n\n```verilog\nmodule two_state_fsm (\n    input wire clk,\n    input wire rst,\n    input wire in,\n    output reg out\n);\n\n    // State encoding\n    parameter STATE_A = 1'b0;\n    parameter STATE_B = 1'b1;\n    \n    // State register\n    reg current_state, next_state;\n    \n    // State register (sequential logic)\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            current_state <= STATE_A;\n        else\n            current_state <= next_state;\n    end\n    \n    // Next state logic (combinational)\n    always @(*) begin\n        case (current_state)\n            STATE_A: begin\n                if (in)\n                    next_state = STATE_B;\n                else\n                    next_state = STATE_A;\n            end\n            \n            STATE_B: begin\n                if (in)\n                    next_state = STATE_A;\n                else\n                    next_state = STATE_B;\n            end\n            \n            default: next_state = STATE_A;\n        endcase\n    end\n    \n    // Output logic (combinational)\n    always @(*) begin\n        case (current_state)\n            STATE_A: out = 1'b0;\n            STATE_B: out = 1'b1;\n            default: out = 1'b0;\n        endcase\n    end\n\nendmodule\n```",
            "Here's a simple two-state FSM in Verilog:\n\n```verilog\nmodule two_state_fsm (\n    input wire clk,\n    input wire rst,\n    input wire in,\n    output reg out\n);\n\n    // State encoding\n    parameter STATE_A = 1'b0;\n    parameter STATE_B = 1'b1;\n    \n    // State register\n    reg current_state, next_state;\n    \n    // State register (sequential logic)\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            current_state <= STATE_A;\n        else\n            current_state <= next_state;\n    end\n    \n    // Next state logic (combinational)\n    always @(*) begin\n        case (current_state)\n            STATE_A: begin\n                if (in)\n                    next_state = STATE_B;\n                else\n                    next_state = STATE_A;\n            end\n            \n            STATE_B: begin\n                if (in)\n                    next_state = STATE_A;\n                else\n                    next_state = STATE_B;\n            end\n            \n            default: next_state = STATE_A;\n        endcase\n    end\n    \n    // Output logic (combinational)\n    always @(*) begin\n        case (current_state)\n            STATE_A: out = 1'b0;\n            STATE_B: out = 1'b1;\n            default: out = 1'b0;\n        endcase\n    end\n\nendmodule\n```"
        ],
        "config": {
            "model": "claude-opus-4-20250514",
            "system_instruction": "You are a Verilog code generator. Output only synthesizable Verilog code.",
            "temperature": 0.2,
            "max_tokens": 1024,
            "samples": 10
        }
    },
    {
        "question": "Implement left shift and left rotate using Verilog",
        "outputs": [
            "Here's synthesizable Verilog code implementing both left shift and left rotate operations:\n\n```verilog\nmodule shift_rotate_left #(\n    parameter WIDTH = 8\n)(\n    input  wire [WIDTH-1:0] data_in,\n    input  wire [2:0]       shift_amount,  // Supports shift/rotate up to 7 positions\n    input  wire             mode,           // 0: shift, 1: rotate\n    output wire [WIDTH-1:0] data_out\n);\n\n    // Left shift with zero fill\n    wire [WIDTH-1:0] shifted;\n    assign shifted = data_in << shift_amount;\n    \n    // Left rotate\n    wire [WIDTH-1:0] rotated;\n    assign rotated = (data_in << shift_amount) | (data_in >> (WIDTH - shift_amount));\n    \n    // Select output based on mode\n    assign data_out = mode ? rotated : shifted;\n\nendmodule\n```\n\nAlternative implementation with explicit bit manipulation:\n\n```verilog\nmodule shift_rotate_left_explicit #(\n    parameter WIDTH = 8\n)(\n    input  wire [WIDTH-1:0] data_in,\n    input  wire [2:0]       shift_amount,\n    input  wire             mode,           // 0: shift, 1: rotate\n    output reg  [WIDTH-1:0] data_out\n);\n\n    integer i;\n    \n    always @(*) begin\n        if (mode == 1'b0) begin\n            // Left shift\n            for (i = 0; i < WIDTH; i = i + 1) begin\n                if (i < shift_amount)\n                    data_out[i] = 1'b0;\n                else\n                    data_out[i] = data_in[i - shift_amount];\n            end\n        end\n        else begin\n            // Left rotate\n            for (i = 0; i < WIDTH; i = i + 1) begin\n                data_out[i] = data_in[(i - shift_amount) % WIDTH];\n            end\n        end\n    end\n\nendmodule\n```\n\nParameterized version with variable shift width:\n\n```verilog\nmodule shift_rotate_left_param #(\n    parameter DATA_WIDTH = 8,\n    parameter SHIFT_WIDTH = 3  // log2(DATA_WIDTH)\n)(\n    input  wire [DATA_WIDTH-1:0]  data_in,\n    input  wire [SHIFT_WIDTH-1:0] shift_amount,\n    input  wire                   mode,\n    output wire [DATA_WIDTH-1:0]  data_out\n);\n\n    wire [DATA_WIDTH-1:0] shift_result;\n    wire [DATA_WIDTH-1:0] rotate_result;\n    \n    // Left shift\n    assign shift_result = data_in << shift_amount;\n    \n    // Left rotate using concatenation\n    wire [2*DATA_WIDTH-1:0] double_data;\n    assign double_data = {data_in, data_in};\n    assign rotate_result = double_data[DATA_WIDTH + shift_amount -: DATA_WIDTH];\n    \n    // Output multiplexer\n    assign data_out = mode ? rotate_result : shift_result;\n\nendmodule\n```",
            "Here's synthesizable Verilog code implementing both left shift and left rotate operations:\n\n```verilog\n// Left Shift Module\nmodule left_shift #(\n    parameter WIDTH = 8\n)(\n    input  wire [WIDTH-1:0] data_in,\n    input  wire [2:0]       shift_amount,  // Can shift 0-7 positions\n    output wire [WIDTH-1:0] data_out\n);\n    \n    assign data_out = data_in << shift_amount;\n    \nendmodule\n\n// Left Rotate Module\nmodule left_rotate #(\n    parameter WIDTH = 8\n)(\n    input  wire [WIDTH-1:0] data_in,\n    input  wire [2:0]       rotate_amount,  // Can rotate 0-7 positions\n    output wire [WIDTH-1:0] data_out\n);\n    \n    wire [WIDTH*2-1:0] temp;\n    \n    // Concatenate input with itself\n    assign temp = {data_in, data_in};\n    \n    // Extract rotated result\n    assign data_out = temp[WIDTH + rotate_amount -: WIDTH];\n    \nendmodule\n\n// Combined Module with Both Operations\nmodule shift_rotate_unit #(\n    parameter WIDTH = 8\n)(\n    input  wire             clk,\n    input  wire             rst_n,\n    input  wire [WIDTH-1:0] data_in,\n    input  wire [2:0]       amount,        // Shift/rotate amount\n    input  wire             op_select,     // 0: shift, 1: rotate\n    input  wire             enable,\n    output reg  [WIDTH-1:0] data_out\n);\n    \n    wire [WIDTH-1:0] shift_result;\n    wire [WIDTH-1:0] rotate_result;\n    \n    // Instantiate shift module\n    left_shift #(.WIDTH(WIDTH)) shift_inst (\n        .data_in(data_in),\n        .shift_amount(amount),\n        .data_out(shift_result)\n    );\n    \n    // Instantiate rotate module\n    left_rotate #(.WIDTH(WIDTH)) rotate_inst (\n        .data_in(data_in),\n        .rotate_amount(amount),\n        .data_out(rotate_result)\n    );\n    \n    // Registered output with operation selection\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            data_out <= {WIDTH{1'b0}};\n        end\n        else if (enable) begin\n            data_out <= op_select ? rotate_result : shift_result;\n        end\n    end\n    \nendmodule\n\n// Alternative implementation using case statement\nmodule shift_rotate_alt #(\n    parameter WIDTH = 8\n)(\n    input  wire [WIDTH-1:0] data_in,\n    input  wire [2:0]       amount,\n    input  wire             op_select,     // 0: shift, 1: rotate\n    output reg  [WIDTH-1:0] data_out\n);\n    \n    always @(*) begin\n        if (op_select) begin\n            // Left rotate\n            case (amount)\n                3'd0: data_out = data_in;\n                3'd1: data_out = {data_in[WIDTH-2:0], data_in[WIDTH-1]};\n                3'd2: data_out = {data_in[WIDTH-3:0], data_in[WIDTH-1:WIDTH-2]};\n                3'd3: data_out = {data_in[WIDTH-4:0], data_in[WIDTH-1:WIDTH-3]};\n                3'd4: data_out = {data_in[WIDTH-5:0], data_in[WIDTH-1:WIDTH-4]};\n                3'd5: data_out = {data_in[WIDTH-6:0], data_in[WIDTH-1:WIDTH-5]};\n                3'd6: data_out = {data_in[WIDTH-7:0], data_in[WIDTH-1:WIDTH-6]};\n                3'd7: data_out = {data_in[0], data_in[WIDTH-1:1]};\n            endcase\n        end\n        else begin\n            //",
            "Here's synthesizable Verilog code implementing both left shift and left rotate operations:\n\n```verilog\n// Left Shift Module\nmodule left_shift #(\n    parameter WIDTH = 8\n)(\n    input  wire [WIDTH-1:0] data_in,\n    input  wire [2:0]       shift_amount,  // Can shift 0-7 positions\n    output wire [WIDTH-1:0] data_out\n);\n    \n    assign data_out = data_in << shift_amount;\n    \nendmodule\n\n// Left Rotate Module\nmodule left_rotate #(\n    parameter WIDTH = 8\n)(\n    input  wire [WIDTH-1:0] data_in,\n    input  wire [2:0]       rotate_amount,  // Can rotate 0-7 positions\n    output wire [WIDTH-1:0] data_out\n);\n    \n    wire [WIDTH*2-1:0] temp;\n    \n    // Concatenate input with itself\n    assign temp = {data_in, data_in};\n    \n    // Extract rotated result\n    assign data_out = temp[WIDTH + rotate_amount -: WIDTH];\n    \nendmodule\n\n// Combined Module with Both Operations\nmodule shift_rotate_unit #(\n    parameter WIDTH = 8\n)(\n    input  wire             clk,\n    input  wire             rst_n,\n    input  wire [WIDTH-1:0] data_in,\n    input  wire [2:0]       amount,        // Shift/rotate amount\n    input  wire             operation,      // 0: shift, 1: rotate\n    input  wire             enable,\n    output reg  [WIDTH-1:0] data_out\n);\n    \n    wire [WIDTH-1:0] shift_result;\n    wire [WIDTH-1:0] rotate_result;\n    \n    // Instantiate shift module\n    left_shift #(.WIDTH(WIDTH)) shift_inst (\n        .data_in(data_in),\n        .shift_amount(amount),\n        .data_out(shift_result)\n    );\n    \n    // Instantiate rotate module\n    left_rotate #(.WIDTH(WIDTH)) rotate_inst (\n        .data_in(data_in),\n        .rotate_amount(amount),\n        .data_out(rotate_result)\n    );\n    \n    // Registered output with operation selection\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            data_out <= {WIDTH{1'b0}};\n        end\n        else if (enable) begin\n            data_out <= operation ? rotate_result : shift_result;\n        end\n    end\n    \nendmodule\n\n// Alternative implementation using case statement\nmodule shift_rotate_alt #(\n    parameter WIDTH = 8\n)(\n    input  wire [WIDTH-1:0] data_in,\n    input  wire [2:0]       amount,\n    input  wire             operation,      // 0: shift, 1: rotate\n    output reg  [WIDTH-1:0] data_out\n);\n    \n    always @(*) begin\n        if (operation == 1'b0) begin\n            // Left shift\n            data_out = data_in << amount;\n        end\n        else begin\n            // Left rotate\n            case (amount)\n                3'd0: data_out = data_in;\n                3'd1: data_out = {data_in[WIDTH-2:0], data_in[WIDTH-1]};\n                3'd2: data_out = {data_in[WIDTH-3:0], data_in[WIDTH-1:WIDTH-2]};\n                3'd3: data_out = {data_in[WIDTH-4:0], data_in[WIDTH-1:WIDTH-3]};\n                3'd4: data_out = {data_in[WIDTH-5:0], data_in[WIDTH-1:WIDTH-4]};\n                3'd5: data_out = {data_in[WIDTH-6:0], data_in[WIDTH-1:WIDTH-5]};\n                3'd6: data_out = {data_in[WIDTH-7:0], data_in[WIDTH-1:WIDTH-6]};\n                3'd7: data_out = {data_in[WIDTH-8:0",
            "Here's synthesizable Verilog code implementing both left shift and left rotate operations:\n\n```verilog\n// Left Shift Module\nmodule left_shift #(\n    parameter WIDTH = 8\n)(\n    input  [WIDTH-1:0] data_in,\n    input  [2:0]       shift_amount,  // Can shift 0-7 positions\n    output [WIDTH-1:0] data_out\n);\n    \n    assign data_out = data_in << shift_amount;\n    \nendmodule\n\n// Left Rotate Module\nmodule left_rotate #(\n    parameter WIDTH = 8\n)(\n    input  [WIDTH-1:0] data_in,\n    input  [2:0]       rotate_amount,  // Can rotate 0-7 positions\n    output [WIDTH-1:0] data_out\n);\n    \n    wire [WIDTH*2-1:0] temp;\n    \n    // Concatenate input twice and extract rotated portion\n    assign temp = {data_in, data_in};\n    assign data_out = temp[WIDTH-1-rotate_amount -: WIDTH];\n    \nendmodule\n\n// Combined Module with Selection\nmodule shift_rotate_unit #(\n    parameter WIDTH = 8\n)(\n    input  [WIDTH-1:0] data_in,\n    input  [2:0]       amount,      // Shift/rotate amount\n    input              mode,        // 0: shift, 1: rotate\n    output [WIDTH-1:0] data_out\n);\n    \n    wire [WIDTH-1:0] shifted_data;\n    wire [WIDTH-1:0] rotated_data;\n    \n    // Left shift\n    assign shifted_data = data_in << amount;\n    \n    // Left rotate using concatenation method\n    wire [WIDTH*2-1:0] temp;\n    assign temp = {data_in, data_in};\n    assign rotated_data = temp[WIDTH-1-amount -: WIDTH];\n    \n    // Select output based on mode\n    assign data_out = mode ? rotated_data : shifted_data;\n    \nendmodule\n\n// Alternative Left Rotate Implementation using case statement\nmodule left_rotate_case #(\n    parameter WIDTH = 8\n)(\n    input  [WIDTH-1:0] data_in,\n    input  [2:0]       rotate_amount,\n    output reg [WIDTH-1:0] data_out\n);\n    \n    always @(*) begin\n        case(rotate_amount)\n            3'd0: data_out = data_in;\n            3'd1: data_out = {data_in[WIDTH-2:0], data_in[WIDTH-1]};\n            3'd2: data_out = {data_in[WIDTH-3:0], data_in[WIDTH-1:WIDTH-2]};\n            3'd3: data_out = {data_in[WIDTH-4:0], data_in[WIDTH-1:WIDTH-3]};\n            3'd4: data_out = {data_in[WIDTH-5:0], data_in[WIDTH-1:WIDTH-4]};\n            3'd5: data_out = {data_in[WIDTH-6:0], data_in[WIDTH-1:WIDTH-5]};\n            3'd6: data_out = {data_in[WIDTH-7:0], data_in[WIDTH-1:WIDTH-6]};\n            3'd7: data_out = {data_in[WIDTH-8:0], data_in[WIDTH-1:WIDTH-7]};\n        endcase\n    end\n    \nendmodule\n\n// Parameterized version with variable shift width\nmodule shift_rotate_param #(\n    parameter DATA_WIDTH = 32,\n    parameter SHIFT_WIDTH = 5  // log2(DATA_WIDTH)\n)(\n    input  [DATA_WIDTH-1:0]  data_in,\n    input  [SHIFT_WIDTH-1:0] amount,\n    input                    mode,      // 0: shift, 1: rotate\n    output [DATA_WIDTH-1:0]  data_out\n);\n    \n    wire [DATA_WIDTH-1:0] shifted_data;\n    wire [DATA_WIDTH-1:0] rotated_data;\n    \n    // Left shift\n    assign shifted_data = data",
            "Here's synthesizable Verilog code implementing both left shift and left rotate operations:\n\n```verilog\n// Left Shift Module\nmodule left_shift #(\n    parameter WIDTH = 8\n)(\n    input  wire [WIDTH-1:0] data_in,\n    input  wire [2:0]       shift_amount,  // Can shift 0-7 positions\n    output wire [WIDTH-1:0] data_out\n);\n    \n    assign data_out = data_in << shift_amount;\n    \nendmodule\n\n// Left Rotate Module\nmodule left_rotate #(\n    parameter WIDTH = 8\n)(\n    input  wire [WIDTH-1:0] data_in,\n    input  wire [2:0]       rotate_amount,  // Can rotate 0-7 positions\n    output wire [WIDTH-1:0] data_out\n);\n    \n    wire [WIDTH*2-1:0] temp;\n    \n    // Concatenate input with itself\n    assign temp = {data_in, data_in};\n    \n    // Extract rotated result\n    assign data_out = temp[WIDTH + rotate_amount -: WIDTH];\n    \nendmodule\n\n// Combined Module with Both Operations\nmodule shift_rotate_unit #(\n    parameter WIDTH = 8\n)(\n    input  wire             clk,\n    input  wire             rst_n,\n    input  wire [WIDTH-1:0] data_in,\n    input  wire [2:0]       amount,        // Shift/rotate amount\n    input  wire             op_select,     // 0: shift, 1: rotate\n    input  wire             enable,\n    output reg  [WIDTH-1:0] data_out\n);\n    \n    wire [WIDTH-1:0] shift_result;\n    wire [WIDTH-1:0] rotate_result;\n    \n    // Instantiate shift module\n    left_shift #(.WIDTH(WIDTH)) shift_inst (\n        .data_in(data_in),\n        .shift_amount(amount),\n        .data_out(shift_result)\n    );\n    \n    // Instantiate rotate module\n    left_rotate #(.WIDTH(WIDTH)) rotate_inst (\n        .data_in(data_in),\n        .rotate_amount(amount),\n        .data_out(rotate_result)\n    );\n    \n    // Registered output with operation selection\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            data_out <= {WIDTH{1'b0}};\n        end\n        else if (enable) begin\n            data_out <= op_select ? rotate_result : shift_result;\n        end\n    end\n    \nendmodule\n\n// Alternative implementation using case statement\nmodule shift_rotate_alt #(\n    parameter WIDTH = 8\n)(\n    input  wire [WIDTH-1:0] data_in,\n    input  wire [2:0]       amount,\n    input  wire             op_select,     // 0: shift, 1: rotate\n    output reg  [WIDTH-1:0] data_out\n);\n    \n    always @(*) begin\n        if (op_select) begin\n            // Left rotate\n            case (amount)\n                3'd0: data_out = data_in;\n                3'd1: data_out = {data_in[WIDTH-2:0], data_in[WIDTH-1]};\n                3'd2: data_out = {data_in[WIDTH-3:0], data_in[WIDTH-1:WIDTH-2]};\n                3'd3: data_out = {data_in[WIDTH-4:0], data_in[WIDTH-1:WIDTH-3]};\n                3'd4: data_out = {data_in[WIDTH-5:0], data_in[WIDTH-1:WIDTH-4]};\n                3'd5: data_out = {data_in[WIDTH-6:0], data_in[WIDTH-1:WIDTH-5]};\n                3'd6: data_out = {data_in[WIDTH-7:0], data_in[WIDTH-1:WIDTH-6]};\n                3'd7: data_out = {data_in[0], data_in[WIDTH-1:1]};\n            endcase\n        end\n        else begin\n            //",
            "Here's synthesizable Verilog code implementing both left shift and left rotate operations:\n\n```verilog\n// Left Shift Module\nmodule left_shift #(\n    parameter WIDTH = 8\n)(\n    input  wire [WIDTH-1:0] data_in,\n    input  wire [2:0]       shift_amount,  // Can shift 0-7 positions\n    output wire [WIDTH-1:0] data_out\n);\n    \n    assign data_out = data_in << shift_amount;\n    \nendmodule\n\n// Left Rotate Module\nmodule left_rotate #(\n    parameter WIDTH = 8\n)(\n    input  wire [WIDTH-1:0] data_in,\n    input  wire [2:0]       rotate_amount,  // Can rotate 0-7 positions\n    output wire [WIDTH-1:0] data_out\n);\n    \n    wire [WIDTH*2-1:0] temp;\n    \n    // Concatenate input twice and extract rotated portion\n    assign temp = {data_in, data_in} << rotate_amount;\n    assign data_out = temp[WIDTH*2-1:WIDTH];\n    \nendmodule\n\n// Combined Module with Operation Select\nmodule shift_rotate_unit #(\n    parameter WIDTH = 8\n)(\n    input  wire             clk,\n    input  wire             rst_n,\n    input  wire [WIDTH-1:0] data_in,\n    input  wire [2:0]       amount,        // Shift/rotate amount\n    input  wire             op_select,     // 0: shift, 1: rotate\n    input  wire             enable,\n    output reg  [WIDTH-1:0] data_out\n);\n    \n    wire [WIDTH-1:0] shifted_data;\n    wire [WIDTH-1:0] rotated_data;\n    \n    // Instantiate shift module\n    left_shift #(.WIDTH(WIDTH)) shift_inst (\n        .data_in(data_in),\n        .shift_amount(amount),\n        .data_out(shifted_data)\n    );\n    \n    // Instantiate rotate module\n    left_rotate #(.WIDTH(WIDTH)) rotate_inst (\n        .data_in(data_in),\n        .rotate_amount(amount),\n        .data_out(rotated_data)\n    );\n    \n    // Registered output with operation select\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            data_out <= {WIDTH{1'b0}};\n        end else if (enable) begin\n            data_out <= op_select ? rotated_data : shifted_data;\n        end\n    end\n    \nendmodule\n\n// Alternative implementation using case statement\nmodule shift_rotate_alt #(\n    parameter WIDTH = 8\n)(\n    input  wire [WIDTH-1:0] data_in,\n    input  wire [2:0]       amount,\n    input  wire             op_select,     // 0: shift, 1: rotate\n    output reg  [WIDTH-1:0] data_out\n);\n    \n    always @(*) begin\n        if (op_select) begin\n            // Left rotate\n            case (amount)\n                3'd0: data_out = data_in;\n                3'd1: data_out = {data_in[WIDTH-2:0], data_in[WIDTH-1]};\n                3'd2: data_out = {data_in[WIDTH-3:0], data_in[WIDTH-1:WIDTH-2]};\n                3'd3: data_out = {data_in[WIDTH-4:0], data_in[WIDTH-1:WIDTH-3]};\n                3'd4: data_out = {data_in[WIDTH-5:0], data_in[WIDTH-1:WIDTH-4]};\n                3'd5: data_out = {data_in[WIDTH-6:0], data_in[WIDTH-1:WIDTH-5]};\n                3'd6: data_out = {data_in[WIDTH-7:0], data_in[WIDTH-1:WIDTH-6]};\n                3'd7: data_out = {data_in[0], data_in[WIDTH-1:1]};\n            endcase\n        end else begin\n            // Left shift",
            "Here's synthesizable Verilog code implementing both left shift and left rotate operations:\n\n```verilog\nmodule shift_rotate_left #(\n    parameter WIDTH = 8\n)(\n    input  wire [WIDTH-1:0] data_in,\n    input  wire [2:0]       shift_amount,  // Supports shift/rotate up to 7 positions\n    input  wire             mode,           // 0: shift, 1: rotate\n    output wire [WIDTH-1:0] data_out\n);\n\n    // Left shift with zero fill\n    wire [WIDTH-1:0] shifted;\n    assign shifted = data_in << shift_amount;\n    \n    // Left rotate\n    wire [WIDTH-1:0] rotated;\n    assign rotated = (data_in << shift_amount) | (data_in >> (WIDTH - shift_amount));\n    \n    // Select output based on mode\n    assign data_out = mode ? rotated : shifted;\n\nendmodule\n```\n\nHere's an alternative implementation with explicit bit manipulation:\n\n```verilog\nmodule shift_rotate_left_explicit #(\n    parameter WIDTH = 8\n)(\n    input  wire [WIDTH-1:0] data_in,\n    input  wire [2:0]       shift_amount,\n    input  wire             mode,           // 0: shift, 1: rotate\n    output reg  [WIDTH-1:0] data_out\n);\n\n    integer i;\n    \n    always @(*) begin\n        if (mode == 1'b0) begin\n            // Left shift\n            for (i = 0; i < WIDTH; i = i + 1) begin\n                if (i < shift_amount)\n                    data_out[i] = 1'b0;\n                else\n                    data_out[i] = data_in[i - shift_amount];\n            end\n        end\n        else begin\n            // Left rotate\n            for (i = 0; i < WIDTH; i = i + 1) begin\n                data_out[i] = data_in[(i - shift_amount) % WIDTH];\n            end\n        end\n    end\n\nendmodule\n```\n\nAnd here's a registered version with clock:\n\n```verilog\nmodule shift_rotate_left_reg #(\n    parameter WIDTH = 8\n)(\n    input  wire             clk,\n    input  wire             rst_n,\n    input  wire             enable,\n    input  wire [WIDTH-1:0] data_in,\n    input  wire [2:0]       shift_amount,\n    input  wire             mode,           // 0: shift, 1: rotate\n    output reg  [WIDTH-1:0] data_out\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            data_out <= {WIDTH{1'b0}};\n        end\n        else if (enable) begin\n            if (mode == 1'b0)\n                // Left shift\n                data_out <= data_in << shift_amount;\n            else\n                // Left rotate\n                data_out <= (data_in << shift_amount) | (data_in >> (WIDTH - shift_amount));\n        end\n    end\n\nendmodule\n```",
            "Here's synthesizable Verilog code implementing both left shift and left rotate operations:\n\n```verilog\n// Left Shift Module\nmodule left_shift #(\n    parameter WIDTH = 8\n)(\n    input  wire [WIDTH-1:0] data_in,\n    input  wire [2:0]       shift_amount,  // Can shift 0-7 positions\n    output wire [WIDTH-1:0] data_out\n);\n    \n    assign data_out = data_in << shift_amount;\n    \nendmodule\n\n// Left Rotate Module\nmodule left_rotate #(\n    parameter WIDTH = 8\n)(\n    input  wire [WIDTH-1:0] data_in,\n    input  wire [2:0]       rotate_amount,  // Can rotate 0-7 positions\n    output wire [WIDTH-1:0] data_out\n);\n    \n    wire [WIDTH*2-1:0] temp;\n    \n    // Concatenate input with itself\n    assign temp = {data_in, data_in};\n    \n    // Extract rotated result\n    assign data_out = temp[WIDTH + rotate_amount -: WIDTH];\n    \nendmodule\n\n// Combined Module with Both Operations\nmodule shift_rotate_unit #(\n    parameter WIDTH = 8\n)(\n    input  wire             clk,\n    input  wire             rst_n,\n    input  wire [WIDTH-1:0] data_in,\n    input  wire [2:0]       amount,        // Shift/rotate amount\n    input  wire             op_select,     // 0: shift, 1: rotate\n    input  wire             enable,\n    output reg  [WIDTH-1:0] data_out\n);\n    \n    wire [WIDTH-1:0] shift_result;\n    wire [WIDTH-1:0] rotate_result;\n    \n    // Instantiate shift module\n    left_shift #(.WIDTH(WIDTH)) shift_inst (\n        .data_in(data_in),\n        .shift_amount(amount),\n        .data_out(shift_result)\n    );\n    \n    // Instantiate rotate module\n    left_rotate #(.WIDTH(WIDTH)) rotate_inst (\n        .data_in(data_in),\n        .rotate_amount(amount),\n        .data_out(rotate_result)\n    );\n    \n    // Registered output with operation selection\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            data_out <= {WIDTH{1'b0}};\n        end\n        else if (enable) begin\n            data_out <= op_select ? rotate_result : shift_result;\n        end\n    end\n    \nendmodule\n\n// Alternative implementation using case statement\nmodule shift_rotate_alt #(\n    parameter WIDTH = 8\n)(\n    input  wire [WIDTH-1:0] data_in,\n    input  wire [2:0]       amount,\n    input  wire             op_select,     // 0: shift, 1: rotate\n    output reg  [WIDTH-1:0] data_out\n);\n    \n    always @(*) begin\n        if (op_select) begin\n            // Left rotate\n            case (amount)\n                3'd0: data_out = data_in;\n                3'd1: data_out = {data_in[WIDTH-2:0], data_in[WIDTH-1]};\n                3'd2: data_out = {data_in[WIDTH-3:0], data_in[WIDTH-1:WIDTH-2]};\n                3'd3: data_out = {data_in[WIDTH-4:0], data_in[WIDTH-1:WIDTH-3]};\n                3'd4: data_out = {data_in[WIDTH-5:0], data_in[WIDTH-1:WIDTH-4]};\n                3'd5: data_out = {data_in[WIDTH-6:0], data_in[WIDTH-1:WIDTH-5]};\n                3'd6: data_out = {data_in[WIDTH-7:0], data_in[WIDTH-1:WIDTH-6]};\n                3'd7: data_out = {data_in[WIDTH-8:0], data_in[WIDTH-1:WIDTH-7]};\n            endcase\n        end",
            "Here's synthesizable Verilog code implementing both left shift and left rotate operations:\n\n```verilog\nmodule shift_rotate_left #(\n    parameter WIDTH = 8\n)(\n    input  wire [WIDTH-1:0] data_in,\n    input  wire [2:0]       shift_amount,  // Supports shift/rotate up to 7 positions\n    input  wire             mode,           // 0: shift, 1: rotate\n    output wire [WIDTH-1:0] data_out\n);\n\n    // Left shift with zero fill\n    wire [WIDTH-1:0] shifted;\n    assign shifted = data_in << shift_amount;\n    \n    // Left rotate\n    wire [WIDTH-1:0] rotated;\n    assign rotated = (data_in << shift_amount) | (data_in >> (WIDTH - shift_amount));\n    \n    // Select output based on mode\n    assign data_out = mode ? rotated : shifted;\n\nendmodule\n```\n\nAlternative implementation with explicit bit manipulation:\n\n```verilog\nmodule shift_rotate_left_explicit #(\n    parameter WIDTH = 8\n)(\n    input  wire [WIDTH-1:0] data_in,\n    input  wire [2:0]       shift_amount,\n    input  wire             mode,           // 0: shift, 1: rotate\n    output reg  [WIDTH-1:0] data_out\n);\n\n    integer i;\n    \n    always @(*) begin\n        if (mode == 1'b0) begin\n            // Left shift\n            for (i = 0; i < WIDTH; i = i + 1) begin\n                if (i < shift_amount)\n                    data_out[i] = 1'b0;\n                else\n                    data_out[i] = data_in[i - shift_amount];\n            end\n        end\n        else begin\n            // Left rotate\n            for (i = 0; i < WIDTH; i = i + 1) begin\n                data_out[i] = data_in[(i - shift_amount) % WIDTH];\n            end\n        end\n    end\n\nendmodule\n```\n\nParameterized version with variable width support:\n\n```verilog\nmodule shift_rotate_unit #(\n    parameter DATA_WIDTH = 8,\n    parameter SHIFT_WIDTH = $clog2(DATA_WIDTH)\n)(\n    input  wire [DATA_WIDTH-1:0]  data_in,\n    input  wire [SHIFT_WIDTH-1:0] shift_amount,\n    input  wire                   mode,         // 0: shift, 1: rotate\n    input  wire                   direction,    // 0: left, 1: right\n    output reg  [DATA_WIDTH-1:0]  data_out\n);\n\n    always @(*) begin\n        case ({direction, mode})\n            2'b00: data_out = data_in << shift_amount;                                              // Left shift\n            2'b01: data_out = (data_in << shift_amount) | (data_in >> (DATA_WIDTH - shift_amount)); // Left rotate\n            2'b10: data_out = data_in >> shift_amount;                                              // Right shift\n            2'b11: data_out = (data_in >> shift_amount) | (data_in << (DATA_WIDTH - shift_amount)); // Right rotate\n        endcase\n    end\n\nendmodule\n```",
            "Here's synthesizable Verilog code implementing both left shift and left rotate operations:\n\n```verilog\n// Left Shift Module\nmodule left_shift #(\n    parameter WIDTH = 8\n)(\n    input  wire [WIDTH-1:0] data_in,\n    input  wire [2:0]       shift_amount,  // Can shift 0-7 positions\n    output wire [WIDTH-1:0] data_out\n);\n    \n    assign data_out = data_in << shift_amount;\n    \nendmodule\n\n// Left Rotate Module\nmodule left_rotate #(\n    parameter WIDTH = 8\n)(\n    input  wire [WIDTH-1:0] data_in,\n    input  wire [2:0]       rotate_amount,  // Can rotate 0-7 positions\n    output wire [WIDTH-1:0] data_out\n);\n    \n    wire [WIDTH*2-1:0] temp;\n    \n    // Concatenate input with itself\n    assign temp = {data_in, data_in};\n    \n    // Extract rotated result\n    assign data_out = temp[WIDTH + rotate_amount -: WIDTH];\n    \nendmodule\n\n// Combined Module with Both Operations\nmodule shift_rotate_unit #(\n    parameter WIDTH = 8\n)(\n    input  wire             clk,\n    input  wire             rst_n,\n    input  wire [WIDTH-1:0] data_in,\n    input  wire [2:0]       amount,        // Shift/rotate amount\n    input  wire             operation,      // 0: shift, 1: rotate\n    input  wire             enable,\n    output reg  [WIDTH-1:0] data_out\n);\n    \n    wire [WIDTH-1:0] shifted_data;\n    wire [WIDTH-1:0] rotated_data;\n    \n    // Instantiate shift module\n    left_shift #(.WIDTH(WIDTH)) shift_inst (\n        .data_in(data_in),\n        .shift_amount(amount),\n        .data_out(shifted_data)\n    );\n    \n    // Instantiate rotate module\n    left_rotate #(.WIDTH(WIDTH)) rotate_inst (\n        .data_in(data_in),\n        .rotate_amount(amount),\n        .data_out(rotated_data)\n    );\n    \n    // Registered output with operation selection\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            data_out <= {WIDTH{1'b0}};\n        end else if (enable) begin\n            data_out <= operation ? rotated_data : shifted_data;\n        end\n    end\n    \nendmodule\n\n// Alternative implementation using case statement\nmodule shift_rotate_alt #(\n    parameter WIDTH = 8\n)(\n    input  wire [WIDTH-1:0] data_in,\n    input  wire [2:0]       amount,\n    input  wire             operation,      // 0: shift, 1: rotate\n    output reg  [WIDTH-1:0] data_out\n);\n    \n    always @(*) begin\n        if (operation == 1'b0) begin\n            // Left shift\n            case (amount)\n                3'd0: data_out = data_in;\n                3'd1: data_out = {data_in[WIDTH-2:0], 1'b0};\n                3'd2: data_out = {data_in[WIDTH-3:0], 2'b00};\n                3'd3: data_out = {data_in[WIDTH-4:0], 3'b000};\n                3'd4: data_out = {data_in[WIDTH-5:0], 4'b0000};\n                3'd5: data_out = {data_in[WIDTH-6:0], 5'b00000};\n                3'd6: data_out = {data_in[WIDTH-7:0], 6'b000000};\n                3'd7: data_out = {data_in[WIDTH-8:0], 7'b0000000};\n            endcase\n        end else begin\n            // Left rotate\n            case (amount)\n                3'd0: data_out = data_in;\n                3'd1: data_out = {data_in["
        ],
        "config": {
            "model": "claude-opus-4-20250514",
            "system_instruction": "You are a Verilog code generator. Output only synthesizable Verilog code.",
            "temperature": 0.2,
            "max_tokens": 1024,
            "samples": 10
        }
    },
    {
        "question": "Verilog code for RAM with read and write control",
        "outputs": [
            "Here's synthesizable Verilog code for a RAM with read and write control:\n\n```verilog\nmodule ram #(\n    parameter DATA_WIDTH = 8,\n    parameter ADDR_WIDTH = 10,\n    parameter DEPTH = 1024\n)(\n    input wire clk,\n    input wire rst_n,\n    \n    // Write interface\n    input wire wr_en,\n    input wire [ADDR_WIDTH-1:0] wr_addr,\n    input wire [DATA_WIDTH-1:0] wr_data,\n    \n    // Read interface\n    input wire rd_en,\n    input wire [ADDR_WIDTH-1:0] rd_addr,\n    output reg [DATA_WIDTH-1:0] rd_data\n);\n\n    // Memory array\n    reg [DATA_WIDTH-1:0] mem [0:DEPTH-1];\n    \n    // Write operation\n    always @(posedge clk) begin\n        if (wr_en) begin\n            mem[wr_addr] <= wr_data;\n        end\n    end\n    \n    // Read operation\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            rd_data <= {DATA_WIDTH{1'b0}};\n        end\n        else if (rd_en) begin\n            rd_data <= mem[rd_addr];\n        end\n    end\n\nendmodule\n```\n\nThis RAM module features:\n- Parameterizable data width, address width, and memory depth\n- Synchronous write operation\n- Synchronous read operation with output register\n- Separate read and write enable signals\n- Separate read and write addresses (allows simultaneous read/write to different locations)\n- Reset signal for read data output",
            "Here's synthesizable Verilog code for a RAM with read and write control:\n\n```verilog\nmodule ram #(\n    parameter DATA_WIDTH = 8,\n    parameter ADDR_WIDTH = 10,\n    parameter DEPTH = 1 << ADDR_WIDTH\n)(\n    input  wire                     clk,\n    input  wire                     rst_n,\n    \n    // Write interface\n    input  wire                     wr_en,\n    input  wire [ADDR_WIDTH-1:0]    wr_addr,\n    input  wire [DATA_WIDTH-1:0]    wr_data,\n    \n    // Read interface\n    input  wire                     rd_en,\n    input  wire [ADDR_WIDTH-1:0]    rd_addr,\n    output reg  [DATA_WIDTH-1:0]    rd_data\n);\n\n    // Memory array\n    reg [DATA_WIDTH-1:0] mem_array [0:DEPTH-1];\n    \n    // Write operation\n    always @(posedge clk) begin\n        if (wr_en) begin\n            mem_array[wr_addr] <= wr_data;\n        end\n    end\n    \n    // Read operation\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            rd_data <= {DATA_WIDTH{1'b0}};\n        end\n        else if (rd_en) begin\n            rd_data <= mem_array[rd_addr];\n        end\n    end\n\nendmodule\n```",
            "Here's synthesizable Verilog code for a RAM with read and write control:\n\n```verilog\nmodule ram #(\n    parameter DATA_WIDTH = 8,\n    parameter ADDR_WIDTH = 10,\n    parameter DEPTH = 1024\n)(\n    input wire clk,\n    input wire rst_n,\n    \n    // Write interface\n    input wire wr_en,\n    input wire [ADDR_WIDTH-1:0] wr_addr,\n    input wire [DATA_WIDTH-1:0] wr_data,\n    \n    // Read interface\n    input wire rd_en,\n    input wire [ADDR_WIDTH-1:0] rd_addr,\n    output reg [DATA_WIDTH-1:0] rd_data\n);\n\n    // Memory array\n    reg [DATA_WIDTH-1:0] mem [0:DEPTH-1];\n    \n    // Write operation\n    always @(posedge clk) begin\n        if (wr_en) begin\n            mem[wr_addr] <= wr_data;\n        end\n    end\n    \n    // Read operation\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            rd_data <= {DATA_WIDTH{1'b0}};\n        end\n        else if (rd_en) begin\n            rd_data <= mem[rd_addr];\n        end\n    end\n\nendmodule\n```",
            "Here's synthesizable Verilog code for a RAM with read and write control:\n\n```verilog\nmodule ram #(\n    parameter DATA_WIDTH = 8,\n    parameter ADDR_WIDTH = 10,\n    parameter DEPTH = 1024\n)(\n    input wire clk,\n    input wire rst_n,\n    \n    // Write interface\n    input wire wr_en,\n    input wire [ADDR_WIDTH-1:0] wr_addr,\n    input wire [DATA_WIDTH-1:0] wr_data,\n    \n    // Read interface\n    input wire rd_en,\n    input wire [ADDR_WIDTH-1:0] rd_addr,\n    output reg [DATA_WIDTH-1:0] rd_data\n);\n\n    // Memory array\n    reg [DATA_WIDTH-1:0] mem [0:DEPTH-1];\n    \n    // Write operation\n    always @(posedge clk) begin\n        if (wr_en) begin\n            mem[wr_addr] <= wr_data;\n        end\n    end\n    \n    // Read operation\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            rd_data <= {DATA_WIDTH{1'b0}};\n        end\n        else if (rd_en) begin\n            rd_data <= mem[rd_addr];\n        end\n    end\n\nendmodule\n```",
            "Here's synthesizable Verilog code for a RAM with read and write control:\n\n```verilog\nmodule ram #(\n    parameter DATA_WIDTH = 8,\n    parameter ADDR_WIDTH = 10,\n    parameter DEPTH = 1024\n)(\n    input wire clk,\n    input wire rst_n,\n    \n    // Write interface\n    input wire wr_en,\n    input wire [ADDR_WIDTH-1:0] wr_addr,\n    input wire [DATA_WIDTH-1:0] wr_data,\n    \n    // Read interface\n    input wire rd_en,\n    input wire [ADDR_WIDTH-1:0] rd_addr,\n    output reg [DATA_WIDTH-1:0] rd_data\n);\n\n    // Memory array\n    reg [DATA_WIDTH-1:0] mem [0:DEPTH-1];\n    \n    // Write operation\n    always @(posedge clk) begin\n        if (wr_en) begin\n            mem[wr_addr] <= wr_data;\n        end\n    end\n    \n    // Read operation\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            rd_data <= {DATA_WIDTH{1'b0}};\n        end\n        else if (rd_en) begin\n            rd_data <= mem[rd_addr];\n        end\n    end\n\nendmodule\n```",
            "Here's synthesizable Verilog code for a RAM with read and write control:\n\n```verilog\nmodule ram #(\n    parameter DATA_WIDTH = 8,\n    parameter ADDR_WIDTH = 10,\n    parameter DEPTH = 1024\n)(\n    input wire clk,\n    input wire rst_n,\n    \n    // Write interface\n    input wire wr_en,\n    input wire [ADDR_WIDTH-1:0] wr_addr,\n    input wire [DATA_WIDTH-1:0] wr_data,\n    \n    // Read interface\n    input wire rd_en,\n    input wire [ADDR_WIDTH-1:0] rd_addr,\n    output reg [DATA_WIDTH-1:0] rd_data\n);\n\n    // Memory array\n    reg [DATA_WIDTH-1:0] mem [0:DEPTH-1];\n    \n    // Write operation\n    always @(posedge clk) begin\n        if (wr_en) begin\n            mem[wr_addr] <= wr_data;\n        end\n    end\n    \n    // Read operation\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            rd_data <= {DATA_WIDTH{1'b0}};\n        end\n        else if (rd_en) begin\n            rd_data <= mem[rd_addr];\n        end\n    end\n\nendmodule\n```",
            "Here's synthesizable Verilog code for a RAM with read and write control:\n\n```verilog\nmodule ram #(\n    parameter DATA_WIDTH = 8,\n    parameter ADDR_WIDTH = 10,\n    parameter DEPTH = 1 << ADDR_WIDTH\n)(\n    input  wire                     clk,\n    input  wire                     rst_n,\n    \n    // Write interface\n    input  wire                     wr_en,\n    input  wire [ADDR_WIDTH-1:0]    wr_addr,\n    input  wire [DATA_WIDTH-1:0]    wr_data,\n    \n    // Read interface\n    input  wire                     rd_en,\n    input  wire [ADDR_WIDTH-1:0]    rd_addr,\n    output reg  [DATA_WIDTH-1:0]    rd_data\n);\n\n    // Memory array\n    reg [DATA_WIDTH-1:0] mem_array [0:DEPTH-1];\n    \n    // Write operation\n    always @(posedge clk) begin\n        if (wr_en) begin\n            mem_array[wr_addr] <= wr_data;\n        end\n    end\n    \n    // Read operation\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            rd_data <= {DATA_WIDTH{1'b0}};\n        end\n        else if (rd_en) begin\n            rd_data <= mem_array[rd_addr];\n        end\n    end\n\nendmodule\n```",
            "Here's synthesizable Verilog code for a RAM with read and write control:\n\n```verilog\nmodule ram #(\n    parameter DATA_WIDTH = 8,\n    parameter ADDR_WIDTH = 10,\n    parameter DEPTH = 1024\n)(\n    input wire clk,\n    input wire rst_n,\n    \n    // Write interface\n    input wire wr_en,\n    input wire [ADDR_WIDTH-1:0] wr_addr,\n    input wire [DATA_WIDTH-1:0] wr_data,\n    \n    // Read interface\n    input wire rd_en,\n    input wire [ADDR_WIDTH-1:0] rd_addr,\n    output reg [DATA_WIDTH-1:0] rd_data\n);\n\n    // Memory array\n    reg [DATA_WIDTH-1:0] mem [0:DEPTH-1];\n    \n    // Write operation\n    always @(posedge clk) begin\n        if (wr_en) begin\n            mem[wr_addr] <= wr_data;\n        end\n    end\n    \n    // Read operation\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            rd_data <= {DATA_WIDTH{1'b0}};\n        end\n        else if (rd_en) begin\n            rd_data <= mem[rd_addr];\n        end\n    end\n\nendmodule\n```",
            "Here's synthesizable Verilog code for a RAM with read and write control:\n\n```verilog\nmodule ram #(\n    parameter DATA_WIDTH = 8,\n    parameter ADDR_WIDTH = 10,\n    parameter DEPTH = 1024\n)(\n    input wire clk,\n    input wire rst_n,\n    \n    // Write interface\n    input wire wr_en,\n    input wire [ADDR_WIDTH-1:0] wr_addr,\n    input wire [DATA_WIDTH-1:0] wr_data,\n    \n    // Read interface\n    input wire rd_en,\n    input wire [ADDR_WIDTH-1:0] rd_addr,\n    output reg [DATA_WIDTH-1:0] rd_data\n);\n\n    // Memory array\n    reg [DATA_WIDTH-1:0] mem [0:DEPTH-1];\n    \n    // Write operation\n    always @(posedge clk) begin\n        if (wr_en) begin\n            mem[wr_addr] <= wr_data;\n        end\n    end\n    \n    // Read operation\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            rd_data <= {DATA_WIDTH{1'b0}};\n        end\n        else if (rd_en) begin\n            rd_data <= mem[rd_addr];\n        end\n    end\n\nendmodule\n```",
            "Here's synthesizable Verilog code for a RAM with read and write control:\n\n```verilog\nmodule ram #(\n    parameter DATA_WIDTH = 8,\n    parameter ADDR_WIDTH = 10,\n    parameter DEPTH = 1 << ADDR_WIDTH\n)(\n    input  wire                     clk,\n    input  wire                     rst_n,\n    \n    // Write interface\n    input  wire                     wr_en,\n    input  wire [ADDR_WIDTH-1:0]    wr_addr,\n    input  wire [DATA_WIDTH-1:0]    wr_data,\n    \n    // Read interface\n    input  wire                     rd_en,\n    input  wire [ADDR_WIDTH-1:0]    rd_addr,\n    output reg  [DATA_WIDTH-1:0]    rd_data\n);\n\n    // Memory array\n    reg [DATA_WIDTH-1:0] mem_array [0:DEPTH-1];\n    \n    // Write operation\n    always @(posedge clk) begin\n        if (wr_en) begin\n            mem_array[wr_addr] <= wr_data;\n        end\n    end\n    \n    // Read operation\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            rd_data <= {DATA_WIDTH{1'b0}};\n        end\n        else if (rd_en) begin\n            rd_data <= mem_array[rd_addr];\n        end\n    end\n\nendmodule\n```"
        ],
        "config": {
            "model": "claude-opus-4-20250514",
            "system_instruction": "You are a Verilog code generator. Output only synthesizable Verilog code.",
            "temperature": 0.2,
            "max_tokens": 1024,
            "samples": 10
        }
    },
    {
        "question": "Permutation in Verilog",
        "outputs": [
            "Here's a synthesizable Verilog module that performs permutation on input data:\n\n```verilog\nmodule permutation #(\n    parameter DATA_WIDTH = 8,\n    parameter NUM_ELEMENTS = 8\n)(\n    input wire clk,\n    input wire rst_n,\n    input wire enable,\n    input wire [DATA_WIDTH*NUM_ELEMENTS-1:0] data_in,\n    input wire [NUM_ELEMENTS*$clog2(NUM_ELEMENTS)-1:0] perm_pattern,\n    output reg [DATA_WIDTH*NUM_ELEMENTS-1:0] data_out,\n    output reg valid_out\n);\n\n    // Calculate index width\n    localparam INDEX_WIDTH = $clog2(NUM_ELEMENTS);\n    \n    // Internal signals\n    reg [DATA_WIDTH-1:0] data_array [0:NUM_ELEMENTS-1];\n    reg [DATA_WIDTH-1:0] permuted_array [0:NUM_ELEMENTS-1];\n    reg [INDEX_WIDTH-1:0] perm_indices [0:NUM_ELEMENTS-1];\n    \n    integer i;\n    \n    // Unpack input data into array\n    always @(*) begin\n        for (i = 0; i < NUM_ELEMENTS; i = i + 1) begin\n            data_array[i] = data_in[i*DATA_WIDTH +: DATA_WIDTH];\n        end\n    end\n    \n    // Unpack permutation pattern\n    always @(*) begin\n        for (i = 0; i < NUM_ELEMENTS; i = i + 1) begin\n            perm_indices[i] = perm_pattern[i*INDEX_WIDTH +: INDEX_WIDTH];\n        end\n    end\n    \n    // Perform permutation\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            valid_out <= 1'b0;\n            data_out <= {(DATA_WIDTH*NUM_ELEMENTS){1'b0}};\n        end\n        else if (enable) begin\n            // Apply permutation\n            for (i = 0; i < NUM_ELEMENTS; i = i + 1) begin\n                permuted_array[i] <= data_array[perm_indices[i]];\n            end\n            valid_out <= 1'b1;\n        end\n        else begin\n            valid_out <= 1'b0;\n        end\n    end\n    \n    // Pack output data\n    always @(*) begin\n        for (i = 0; i < NUM_ELEMENTS; i = i + 1) begin\n            data_out[i*DATA_WIDTH +: DATA_WIDTH] = permuted_array[i];\n        end\n    end\n\nendmodule\n```\n\nHere's also a fixed permutation example (like for cryptographic S-boxes):\n\n```verilog\nmodule fixed_permutation_8bit (\n    input wire [7:0] data_in,\n    output wire [7:0] data_out\n);\n\n    // Fixed bit permutation pattern\n    // Example: bit 0 -> bit 4, bit 1 -> bit 7, etc.\n    assign data_out[0] = data_in[4];\n    assign data_out[1] = data_in[7];\n    assign data_out[2] = data_in[1];\n    assign data_out[3] = data_in[6];\n    assign data_out[4] = data_in[0];\n    assign data_out[5] = data_in[2];\n    assign data_out[6] = data_in[5];\n    assign data_out[7] = data_in[3];\n\nendmodule\n```\n\nAnd here's a configurable bit-level permutation module:\n\n```verilog\nmodule bit_permutation #(\n    parameter WIDTH = 32\n)(\n    input wire clk,\n    input wire rst_n,\n    input wire [WIDTH-1:0] data_in,\n    input wire [WIDTH*$clog2(WIDTH)-1:0] perm_config,\n    output reg [WIDTH-1:0] data_out\n);\n\n    localparam INDEX_BITS = $clog2(WIDTH);\n    \n    reg [INDEX",
            "Here's a synthesizable Verilog module that performs permutation on input data:\n\n```verilog\nmodule permutation #(\n    parameter DATA_WIDTH = 8,\n    parameter NUM_ELEMENTS = 8\n)(\n    input wire clk,\n    input wire rst_n,\n    input wire enable,\n    input wire [DATA_WIDTH*NUM_ELEMENTS-1:0] data_in,\n    input wire [NUM_ELEMENTS*$clog2(NUM_ELEMENTS)-1:0] perm_pattern,\n    output reg [DATA_WIDTH*NUM_ELEMENTS-1:0] data_out,\n    output reg valid_out\n);\n\n    // Calculate index width\n    localparam INDEX_WIDTH = $clog2(NUM_ELEMENTS);\n    \n    // Internal signals\n    reg [DATA_WIDTH-1:0] data_array [0:NUM_ELEMENTS-1];\n    reg [DATA_WIDTH-1:0] permuted_array [0:NUM_ELEMENTS-1];\n    reg [INDEX_WIDTH-1:0] perm_indices [0:NUM_ELEMENTS-1];\n    \n    integer i;\n    \n    // Unpack input data into array\n    always @(*) begin\n        for (i = 0; i < NUM_ELEMENTS; i = i + 1) begin\n            data_array[i] = data_in[i*DATA_WIDTH +: DATA_WIDTH];\n        end\n    end\n    \n    // Unpack permutation pattern\n    always @(*) begin\n        for (i = 0; i < NUM_ELEMENTS; i = i + 1) begin\n            perm_indices[i] = perm_pattern[i*INDEX_WIDTH +: INDEX_WIDTH];\n        end\n    end\n    \n    // Perform permutation\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            data_out <= {(DATA_WIDTH*NUM_ELEMENTS){1'b0}};\n            valid_out <= 1'b0;\n        end\n        else if (enable) begin\n            // Apply permutation\n            for (i = 0; i < NUM_ELEMENTS; i = i + 1) begin\n                permuted_array[i] <= data_array[perm_indices[i]];\n            end\n            \n            // Pack output\n            for (i = 0; i < NUM_ELEMENTS; i = i + 1) begin\n                data_out[i*DATA_WIDTH +: DATA_WIDTH] <= permuted_array[i];\n            end\n            \n            valid_out <= 1'b1;\n        end\n        else begin\n            valid_out <= 1'b0;\n        end\n    end\n\nendmodule\n```\n\nHere's also a simpler combinational version:\n\n```verilog\nmodule permutation_comb #(\n    parameter DATA_WIDTH = 8,\n    parameter NUM_ELEMENTS = 8\n)(\n    input wire [DATA_WIDTH*NUM_ELEMENTS-1:0] data_in,\n    input wire [NUM_ELEMENTS*$clog2(NUM_ELEMENTS)-1:0] perm_pattern,\n    output wire [DATA_WIDTH*NUM_ELEMENTS-1:0] data_out\n);\n\n    localparam INDEX_WIDTH = $clog2(NUM_ELEMENTS);\n    \n    genvar g;\n    generate\n        for (g = 0; g < NUM_ELEMENTS; g = g + 1) begin : perm_gen\n            wire [INDEX_WIDTH-1:0] src_index;\n            assign src_index = perm_pattern[g*INDEX_WIDTH +: INDEX_WIDTH];\n            \n            // Multiplexer to select source element\n            assign data_out[g*DATA_WIDTH +: DATA_WIDTH] = \n                data_in[src_index*DATA_WIDTH +: DATA_WIDTH];\n        end\n    endgenerate\n\nendmodule\n```\n\nAnd here's a fixed permutation example (e.g., bit reversal):\n\n```verilog\nmodule fixed_permutation_8bit (\n    input wire [63:0] data_in,  // 8 elements of 8 bits each\n    output wire [63:0] data_out\n);\n\n    // Example: Bit rever",
            "Here's a synthesizable Verilog module that performs permutation on input data:\n\n```verilog\nmodule permutation #(\n    parameter DATA_WIDTH = 8,\n    parameter NUM_ELEMENTS = 8\n)(\n    input wire clk,\n    input wire rst_n,\n    input wire enable,\n    input wire [DATA_WIDTH*NUM_ELEMENTS-1:0] data_in,\n    input wire [NUM_ELEMENTS*$clog2(NUM_ELEMENTS)-1:0] perm_pattern,\n    output reg [DATA_WIDTH*NUM_ELEMENTS-1:0] data_out,\n    output reg valid_out\n);\n\n    // Calculate index width\n    localparam INDEX_WIDTH = $clog2(NUM_ELEMENTS);\n    \n    // Internal signals\n    reg [DATA_WIDTH-1:0] data_array [0:NUM_ELEMENTS-1];\n    reg [DATA_WIDTH-1:0] permuted_array [0:NUM_ELEMENTS-1];\n    reg [INDEX_WIDTH-1:0] perm_indices [0:NUM_ELEMENTS-1];\n    \n    integer i;\n    \n    // Unpack input data into array\n    always @(*) begin\n        for (i = 0; i < NUM_ELEMENTS; i = i + 1) begin\n            data_array[i] = data_in[i*DATA_WIDTH +: DATA_WIDTH];\n        end\n    end\n    \n    // Unpack permutation pattern\n    always @(*) begin\n        for (i = 0; i < NUM_ELEMENTS; i = i + 1) begin\n            perm_indices[i] = perm_pattern[i*INDEX_WIDTH +: INDEX_WIDTH];\n        end\n    end\n    \n    // Perform permutation\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            data_out <= {(DATA_WIDTH*NUM_ELEMENTS){1'b0}};\n            valid_out <= 1'b0;\n        end\n        else if (enable) begin\n            // Apply permutation\n            for (i = 0; i < NUM_ELEMENTS; i = i + 1) begin\n                permuted_array[i] <= data_array[perm_indices[i]];\n            end\n            \n            // Pack output\n            for (i = 0; i < NUM_ELEMENTS; i = i + 1) begin\n                data_out[i*DATA_WIDTH +: DATA_WIDTH] <= permuted_array[i];\n            end\n            \n            valid_out <= 1'b1;\n        end\n        else begin\n            valid_out <= 1'b0;\n        end\n    end\n\nendmodule\n```\n\nHere's also a fixed permutation example (like for cryptographic S-boxes):\n\n```verilog\nmodule fixed_permutation_8bit (\n    input wire [7:0] data_in,\n    output wire [7:0] data_out\n);\n\n    // Fixed bit permutation pattern\n    // Example: bit 0 -> bit 4, bit 1 -> bit 7, etc.\n    assign data_out[0] = data_in[4];\n    assign data_out[1] = data_in[7];\n    assign data_out[2] = data_in[1];\n    assign data_out[3] = data_in[6];\n    assign data_out[4] = data_in[0];\n    assign data_out[5] = data_in[2];\n    assign data_out[6] = data_in[5];\n    assign data_out[7] = data_in[3];\n\nendmodule\n```\n\nAnd here's a byte-level permutation module:\n\n```verilog\nmodule byte_permutation #(\n    parameter NUM_BYTES = 16\n)(\n    input wire clk,\n    input wire rst_n,\n    input wire enable,\n    input wire [NUM_BYTES*8-1:0] data_in,\n    input wire [NUM_BYTES*$clog2(NUM_BYTES)-1:0] perm_pattern,\n    output reg [NUM_BYTES*8-1:0] data_out,\n    output reg valid_out\n);\n\n    ",
            "Here's a synthesizable Verilog module that performs permutation on an input vector:\n\n```verilog\nmodule permutation #(\n    parameter WIDTH = 8,\n    parameter PERM_TABLE = 64'h76543210  // Default: no permutation\n)(\n    input  wire [WIDTH-1:0] data_in,\n    output wire [WIDTH-1:0] data_out\n);\n\n    genvar i;\n    generate\n        for (i = 0; i < WIDTH; i = i + 1) begin : perm_loop\n            assign data_out[i] = data_in[PERM_TABLE[i*4 +: 4]];\n        end\n    endgenerate\n\nendmodule\n```\n\nHere's a more flexible version with configurable permutation:\n\n```verilog\nmodule permutation_configurable #(\n    parameter WIDTH = 8\n)(\n    input  wire [WIDTH-1:0] data_in,\n    input  wire [WIDTH*$clog2(WIDTH)-1:0] perm_config,\n    output wire [WIDTH-1:0] data_out\n);\n\n    localparam INDEX_WIDTH = $clog2(WIDTH);\n    \n    genvar i;\n    generate\n        for (i = 0; i < WIDTH; i = i + 1) begin : perm_loop\n            wire [INDEX_WIDTH-1:0] src_index;\n            assign src_index = perm_config[i*INDEX_WIDTH +: INDEX_WIDTH];\n            assign data_out[i] = data_in[src_index];\n        end\n    endgenerate\n\nendmodule\n```\n\nExample usage with a fixed 8-bit permutation:\n\n```verilog\nmodule permutation_8bit_example (\n    input  wire [7:0] data_in,\n    output wire [7:0] data_out\n);\n\n    // Permutation: bit 7->0, 6->1, 5->2, 4->3, 3->4, 2->5, 1->6, 0->7\n    permutation #(\n        .WIDTH(8),\n        .PERM_TABLE(64'h01234567)  // Reverse bit order\n    ) perm_inst (\n        .data_in(data_in),\n        .data_out(data_out)\n    );\n\nendmodule\n```",
            "Here's a synthesizable Verilog module that performs permutation on input data:\n\n```verilog\nmodule permutation #(\n    parameter DATA_WIDTH = 8,\n    parameter NUM_ELEMENTS = 8\n)(\n    input wire clk,\n    input wire rst_n,\n    input wire enable,\n    input wire [DATA_WIDTH*NUM_ELEMENTS-1:0] data_in,\n    input wire [NUM_ELEMENTS*$clog2(NUM_ELEMENTS)-1:0] perm_pattern,\n    output reg [DATA_WIDTH*NUM_ELEMENTS-1:0] data_out,\n    output reg valid_out\n);\n\n    // Calculate index width\n    localparam INDEX_WIDTH = $clog2(NUM_ELEMENTS);\n    \n    // Internal registers\n    reg [DATA_WIDTH-1:0] data_array [0:NUM_ELEMENTS-1];\n    reg [DATA_WIDTH-1:0] permuted_array [0:NUM_ELEMENTS-1];\n    reg [INDEX_WIDTH-1:0] perm_indices [0:NUM_ELEMENTS-1];\n    \n    integer i;\n    \n    // Unpack input data and permutation pattern\n    always @(*) begin\n        for (i = 0; i < NUM_ELEMENTS; i = i + 1) begin\n            data_array[i] = data_in[i*DATA_WIDTH +: DATA_WIDTH];\n            perm_indices[i] = perm_pattern[i*INDEX_WIDTH +: INDEX_WIDTH];\n        end\n    end\n    \n    // Perform permutation\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            data_out <= {(DATA_WIDTH*NUM_ELEMENTS){1'b0}};\n            valid_out <= 1'b0;\n        end\n        else if (enable) begin\n            // Apply permutation\n            for (i = 0; i < NUM_ELEMENTS; i = i + 1) begin\n                permuted_array[i] <= data_array[perm_indices[i]];\n            end\n            \n            // Pack output data\n            for (i = 0; i < NUM_ELEMENTS; i = i + 1) begin\n                data_out[i*DATA_WIDTH +: DATA_WIDTH] <= data_array[perm_indices[i]];\n            end\n            \n            valid_out <= 1'b1;\n        end\n        else begin\n            valid_out <= 1'b0;\n        end\n    end\n\nendmodule\n```\n\nHere's also a fixed permutation module example (e.g., for cryptographic applications):\n\n```verilog\nmodule fixed_permutation_8bit (\n    input wire clk,\n    input wire rst_n,\n    input wire enable,\n    input wire [63:0] data_in,  // 8 bytes input\n    output reg [63:0] data_out,  // 8 bytes output\n    output reg valid_out\n);\n\n    // Fixed permutation pattern (example: bit reversal)\n    // Maps: 0->7, 1->6, 2->5, 3->4, 4->3, 5->2, 6->1, 7->0\n    \n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            data_out <= 64'b0;\n            valid_out <= 1'b0;\n        end\n        else if (enable) begin\n            // Apply fixed permutation\n            data_out[7:0]   <= data_in[63:56];  // Element 7 -> Position 0\n            data_out[15:8]  <= data_in[55:48];  // Element 6 -> Position 1\n            data_out[23:16] <= data_in[47:40];  // Element 5 -> Position 2\n            data_out[31:24] <= data_in[39:32];  // Element 4 -> Position 3\n            data_out[39:32] <= data_in[31:24];  // Element 3 -> Position 4\n            data_out[47:40] <= data_in[23:16];  // Element ",
            "Here's a synthesizable Verilog module that performs permutation on input data:\n\n```verilog\nmodule permutation #(\n    parameter DATA_WIDTH = 8,\n    parameter NUM_ELEMENTS = 8\n)(\n    input wire clk,\n    input wire rst_n,\n    input wire enable,\n    input wire [DATA_WIDTH*NUM_ELEMENTS-1:0] data_in,\n    input wire [NUM_ELEMENTS*$clog2(NUM_ELEMENTS)-1:0] perm_pattern,\n    output reg [DATA_WIDTH*NUM_ELEMENTS-1:0] data_out,\n    output reg valid_out\n);\n\n    // Calculate index width\n    localparam INDEX_WIDTH = $clog2(NUM_ELEMENTS);\n    \n    // Internal signals\n    reg [DATA_WIDTH-1:0] data_array [0:NUM_ELEMENTS-1];\n    reg [DATA_WIDTH-1:0] permuted_array [0:NUM_ELEMENTS-1];\n    reg [INDEX_WIDTH-1:0] perm_indices [0:NUM_ELEMENTS-1];\n    \n    integer i;\n    \n    // Unpack input data into array\n    always @(*) begin\n        for (i = 0; i < NUM_ELEMENTS; i = i + 1) begin\n            data_array[i] = data_in[i*DATA_WIDTH +: DATA_WIDTH];\n        end\n    end\n    \n    // Unpack permutation pattern\n    always @(*) begin\n        for (i = 0; i < NUM_ELEMENTS; i = i + 1) begin\n            perm_indices[i] = perm_pattern[i*INDEX_WIDTH +: INDEX_WIDTH];\n        end\n    end\n    \n    // Perform permutation\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            data_out <= {(DATA_WIDTH*NUM_ELEMENTS){1'b0}};\n            valid_out <= 1'b0;\n        end\n        else if (enable) begin\n            // Apply permutation\n            for (i = 0; i < NUM_ELEMENTS; i = i + 1) begin\n                permuted_array[i] <= data_array[perm_indices[i]];\n            end\n            \n            // Pack output data\n            for (i = 0; i < NUM_ELEMENTS; i = i + 1) begin\n                data_out[i*DATA_WIDTH +: DATA_WIDTH] <= permuted_array[i];\n            end\n            \n            valid_out <= 1'b1;\n        end\n        else begin\n            valid_out <= 1'b0;\n        end\n    end\n\nendmodule\n```\n\nHere's also a fixed permutation example (like for cryptographic S-boxes):\n\n```verilog\nmodule fixed_permutation_8bit (\n    input wire [7:0] data_in,\n    output wire [7:0] data_out\n);\n\n    // Example: bit permutation pattern\n    // Output bit 0 <- Input bit 3\n    // Output bit 1 <- Input bit 7\n    // Output bit 2 <- Input bit 1\n    // Output bit 3 <- Input bit 5\n    // Output bit 4 <- Input bit 2\n    // Output bit 5 <- Input bit 6\n    // Output bit 6 <- Input bit 0\n    // Output bit 7 <- Input bit 4\n    \n    assign data_out[0] = data_in[3];\n    assign data_out[1] = data_in[7];\n    assign data_out[2] = data_in[1];\n    assign data_out[3] = data_in[5];\n    assign data_out[4] = data_in[2];\n    assign data_out[5] = data_in[6];\n    assign data_out[6] = data_in[0];\n    assign data_out[7] = data_in[4];\n\nendmodule\n```\n\nAnd here's a byte-level permutation module:\n\n```verilog\nmodule byte_permutation #(\n    parameter NUM_BYTES = 16\n)(\n    input wire clk,\n    input wire rst_n,\n    input",
            "Here's a synthesizable Verilog module that performs permutation on input data:\n\n```verilog\nmodule permutation #(\n    parameter DATA_WIDTH = 8,\n    parameter NUM_ELEMENTS = 8\n)(\n    input wire clk,\n    input wire rst_n,\n    input wire enable,\n    input wire [DATA_WIDTH*NUM_ELEMENTS-1:0] data_in,\n    input wire [NUM_ELEMENTS*$clog2(NUM_ELEMENTS)-1:0] perm_pattern,\n    output reg [DATA_WIDTH*NUM_ELEMENTS-1:0] data_out,\n    output reg valid_out\n);\n\n    // Calculate index width\n    localparam INDEX_WIDTH = $clog2(NUM_ELEMENTS);\n    \n    // Internal signals\n    reg [DATA_WIDTH-1:0] data_array [0:NUM_ELEMENTS-1];\n    reg [DATA_WIDTH-1:0] permuted_array [0:NUM_ELEMENTS-1];\n    reg [INDEX_WIDTH-1:0] perm_indices [0:NUM_ELEMENTS-1];\n    \n    integer i;\n    \n    // Unpack input data into array\n    always @(*) begin\n        for (i = 0; i < NUM_ELEMENTS; i = i + 1) begin\n            data_array[i] = data_in[i*DATA_WIDTH +: DATA_WIDTH];\n        end\n    end\n    \n    // Unpack permutation pattern\n    always @(*) begin\n        for (i = 0; i < NUM_ELEMENTS; i = i + 1) begin\n            perm_indices[i] = perm_pattern[i*INDEX_WIDTH +: INDEX_WIDTH];\n        end\n    end\n    \n    // Perform permutation\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            valid_out <= 1'b0;\n            data_out <= {(DATA_WIDTH*NUM_ELEMENTS){1'b0}};\n        end\n        else if (enable) begin\n            // Apply permutation\n            for (i = 0; i < NUM_ELEMENTS; i = i + 1) begin\n                permuted_array[i] <= data_array[perm_indices[i]];\n            end\n            valid_out <= 1'b1;\n        end\n        else begin\n            valid_out <= 1'b0;\n        end\n    end\n    \n    // Pack output data\n    always @(*) begin\n        for (i = 0; i < NUM_ELEMENTS; i = i + 1) begin\n            data_out[i*DATA_WIDTH +: DATA_WIDTH] = permuted_array[i];\n        end\n    end\n\nendmodule\n```\n\nHere's also a fixed permutation example (like for cryptographic S-boxes):\n\n```verilog\nmodule fixed_permutation_8bit (\n    input wire [7:0] data_in,\n    output wire [7:0] data_out\n);\n\n    // Fixed bit permutation pattern\n    // Example: bit 0 -> bit 4, bit 1 -> bit 7, etc.\n    assign data_out[0] = data_in[4];\n    assign data_out[1] = data_in[7];\n    assign data_out[2] = data_in[1];\n    assign data_out[3] = data_in[6];\n    assign data_out[4] = data_in[0];\n    assign data_out[5] = data_in[2];\n    assign data_out[6] = data_in[5];\n    assign data_out[7] = data_in[3];\n\nendmodule\n```\n\nAnd here's a configurable bit-level permutation module:\n\n```verilog\nmodule bit_permutation #(\n    parameter WIDTH = 32\n)(\n    input wire clk,\n    input wire rst_n,\n    input wire [WIDTH-1:0] data_in,\n    input wire [WIDTH*$clog2(WIDTH)-1:0] perm_config,\n    output reg [WIDTH-1:0] data_out\n);\n\n    localparam INDEX_BITS = $clog2(WIDTH);\n    \n    integer i;",
            "Here's a synthesizable Verilog module that performs permutation on input data:\n\n```verilog\nmodule permutation #(\n    parameter DATA_WIDTH = 8,\n    parameter NUM_ELEMENTS = 8\n)(\n    input wire clk,\n    input wire rst_n,\n    input wire enable,\n    input wire [DATA_WIDTH*NUM_ELEMENTS-1:0] data_in,\n    input wire [NUM_ELEMENTS*$clog2(NUM_ELEMENTS)-1:0] perm_pattern,\n    output reg [DATA_WIDTH*NUM_ELEMENTS-1:0] data_out,\n    output reg valid_out\n);\n\n    // Calculate index width\n    localparam INDEX_WIDTH = $clog2(NUM_ELEMENTS);\n    \n    // Internal signals\n    reg [DATA_WIDTH-1:0] data_array [0:NUM_ELEMENTS-1];\n    reg [DATA_WIDTH-1:0] permuted_array [0:NUM_ELEMENTS-1];\n    reg [INDEX_WIDTH-1:0] perm_indices [0:NUM_ELEMENTS-1];\n    \n    integer i;\n    \n    // Unpack input data into array\n    always @(*) begin\n        for (i = 0; i < NUM_ELEMENTS; i = i + 1) begin\n            data_array[i] = data_in[i*DATA_WIDTH +: DATA_WIDTH];\n        end\n    end\n    \n    // Unpack permutation pattern\n    always @(*) begin\n        for (i = 0; i < NUM_ELEMENTS; i = i + 1) begin\n            perm_indices[i] = perm_pattern[i*INDEX_WIDTH +: INDEX_WIDTH];\n        end\n    end\n    \n    // Perform permutation\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            valid_out <= 1'b0;\n            data_out <= {(DATA_WIDTH*NUM_ELEMENTS){1'b0}};\n        end\n        else if (enable) begin\n            // Apply permutation\n            for (i = 0; i < NUM_ELEMENTS; i = i + 1) begin\n                permuted_array[i] <= data_array[perm_indices[i]];\n            end\n            valid_out <= 1'b1;\n        end\n        else begin\n            valid_out <= 1'b0;\n        end\n    end\n    \n    // Pack output data\n    always @(*) begin\n        for (i = 0; i < NUM_ELEMENTS; i = i + 1) begin\n            data_out[i*DATA_WIDTH +: DATA_WIDTH] = permuted_array[i];\n        end\n    end\n\nendmodule\n```\n\nHere's also a fixed permutation example (like for cryptographic S-boxes):\n\n```verilog\nmodule fixed_permutation_8bit (\n    input wire [7:0] data_in,\n    output wire [7:0] data_out\n);\n\n    // Fixed bit permutation pattern\n    // Example: bit 0 -> bit 4, bit 1 -> bit 7, etc.\n    assign data_out[0] = data_in[4];\n    assign data_out[1] = data_in[7];\n    assign data_out[2] = data_in[1];\n    assign data_out[3] = data_in[6];\n    assign data_out[4] = data_in[0];\n    assign data_out[5] = data_in[2];\n    assign data_out[6] = data_in[5];\n    assign data_out[7] = data_in[3];\n\nendmodule\n```\n\nAnd here's a configurable bit-level permutation module:\n\n```verilog\nmodule bit_permutation #(\n    parameter WIDTH = 32\n)(\n    input wire clk,\n    input wire rst_n,\n    input wire [WIDTH-1:0] data_in,\n    input wire [WIDTH*$clog2(WIDTH)-1:0] perm_config,\n    output reg [WIDTH-1:0] data_out\n);\n\n    localparam INDEX_WIDTH = $clog2(WIDTH);\n    \n    reg [INDEX_",
            "Here's a synthesizable Verilog module that performs permutation on input data:\n\n```verilog\nmodule permutation #(\n    parameter DATA_WIDTH = 8,\n    parameter NUM_ELEMENTS = 8\n)(\n    input wire clk,\n    input wire rst_n,\n    input wire enable,\n    input wire [DATA_WIDTH*NUM_ELEMENTS-1:0] data_in,\n    input wire [NUM_ELEMENTS*$clog2(NUM_ELEMENTS)-1:0] perm_indices,\n    output reg [DATA_WIDTH*NUM_ELEMENTS-1:0] data_out,\n    output reg valid_out\n);\n\n    // Calculate index width\n    localparam INDEX_WIDTH = $clog2(NUM_ELEMENTS);\n    \n    // Internal signals\n    reg [DATA_WIDTH-1:0] data_array [0:NUM_ELEMENTS-1];\n    reg [DATA_WIDTH-1:0] permuted_array [0:NUM_ELEMENTS-1];\n    reg [INDEX_WIDTH-1:0] index_array [0:NUM_ELEMENTS-1];\n    \n    integer i;\n    \n    // Unpack input data and indices\n    always @(*) begin\n        for (i = 0; i < NUM_ELEMENTS; i = i + 1) begin\n            data_array[i] = data_in[i*DATA_WIDTH +: DATA_WIDTH];\n            index_array[i] = perm_indices[i*INDEX_WIDTH +: INDEX_WIDTH];\n        end\n    end\n    \n    // Perform permutation\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            data_out <= {(DATA_WIDTH*NUM_ELEMENTS){1'b0}};\n            valid_out <= 1'b0;\n        end\n        else if (enable) begin\n            // Apply permutation based on indices\n            for (i = 0; i < NUM_ELEMENTS; i = i + 1) begin\n                if (index_array[i] < NUM_ELEMENTS) begin\n                    permuted_array[i] <= data_array[index_array[i]];\n                end\n                else begin\n                    permuted_array[i] <= {DATA_WIDTH{1'b0}};\n                end\n            end\n            \n            // Pack output data\n            for (i = 0; i < NUM_ELEMENTS; i = i + 1) begin\n                data_out[i*DATA_WIDTH +: DATA_WIDTH] <= permuted_array[i];\n            end\n            \n            valid_out <= 1'b1;\n        end\n        else begin\n            valid_out <= 1'b0;\n        end\n    end\n\nendmodule\n```\n\nHere's also a fixed permutation example (e.g., bit reversal):\n\n```verilog\nmodule fixed_permutation #(\n    parameter DATA_WIDTH = 8,\n    parameter NUM_ELEMENTS = 8\n)(\n    input wire clk,\n    input wire rst_n,\n    input wire enable,\n    input wire [DATA_WIDTH*NUM_ELEMENTS-1:0] data_in,\n    output reg [DATA_WIDTH*NUM_ELEMENTS-1:0] data_out,\n    output reg valid_out\n);\n\n    // Example: Bit-reversal permutation for 8 elements\n    // 0->0, 1->4, 2->2, 3->6, 4->1, 5->5, 6->3, 7->7\n    \n    reg [DATA_WIDTH-1:0] data_array [0:NUM_ELEMENTS-1];\n    integer i;\n    \n    // Unpack input data\n    always @(*) begin\n        for (i = 0; i < NUM_ELEMENTS; i = i + 1) begin\n            data_array[i] = data_in[i*DATA_WIDTH +: DATA_WIDTH];\n        end\n    end\n    \n    // Perform fixed permutation\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            data_out <= {(DATA_WIDTH*NUM_ELEMENTS){1'b0}};\n            valid_out <= 1'b0;",
            "Here's a synthesizable Verilog module that performs permutation on input data:\n\n```verilog\nmodule permutation #(\n    parameter DATA_WIDTH = 8,\n    parameter NUM_ELEMENTS = 8\n)(\n    input wire clk,\n    input wire rst_n,\n    input wire enable,\n    input wire [DATA_WIDTH*NUM_ELEMENTS-1:0] data_in,\n    input wire [NUM_ELEMENTS*$clog2(NUM_ELEMENTS)-1:0] perm_pattern,\n    output reg [DATA_WIDTH*NUM_ELEMENTS-1:0] data_out,\n    output reg valid_out\n);\n\n    // Calculate index width\n    localparam INDEX_WIDTH = $clog2(NUM_ELEMENTS);\n    \n    // Internal signals\n    reg [DATA_WIDTH-1:0] data_array [0:NUM_ELEMENTS-1];\n    reg [DATA_WIDTH-1:0] permuted_array [0:NUM_ELEMENTS-1];\n    reg [INDEX_WIDTH-1:0] perm_indices [0:NUM_ELEMENTS-1];\n    \n    integer i;\n    \n    // Unpack input data into array\n    always @(*) begin\n        for (i = 0; i < NUM_ELEMENTS; i = i + 1) begin\n            data_array[i] = data_in[i*DATA_WIDTH +: DATA_WIDTH];\n        end\n    end\n    \n    // Unpack permutation pattern\n    always @(*) begin\n        for (i = 0; i < NUM_ELEMENTS; i = i + 1) begin\n            perm_indices[i] = perm_pattern[i*INDEX_WIDTH +: INDEX_WIDTH];\n        end\n    end\n    \n    // Perform permutation\n    always @(*) begin\n        for (i = 0; i < NUM_ELEMENTS; i = i + 1) begin\n            permuted_array[i] = data_array[perm_indices[i]];\n        end\n    end\n    \n    // Pack output data\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            data_out <= {(DATA_WIDTH*NUM_ELEMENTS){1'b0}};\n            valid_out <= 1'b0;\n        end\n        else if (enable) begin\n            for (i = 0; i < NUM_ELEMENTS; i = i + 1) begin\n                data_out[i*DATA_WIDTH +: DATA_WIDTH] <= permuted_array[i];\n            end\n            valid_out <= 1'b1;\n        end\n        else begin\n            valid_out <= 1'b0;\n        end\n    end\n\nendmodule\n```\n\nHere's also a fixed permutation module example (e.g., for a specific permutation like bit reversal):\n\n```verilog\nmodule fixed_permutation_8x8 (\n    input wire clk,\n    input wire rst_n,\n    input wire enable,\n    input wire [63:0] data_in,  // 8 elements of 8 bits each\n    output reg [63:0] data_out,\n    output reg valid_out\n);\n\n    // Fixed permutation pattern (example: bit reversal)\n    // Maps: 0->7, 1->6, 2->5, 3->4, 4->3, 5->2, 6->1, 7->0\n    \n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            data_out <= 64'b0;\n            valid_out <= 1'b0;\n        end\n        else if (enable) begin\n            // Perform fixed permutation\n            data_out[7:0]   <= data_in[63:56];  // Element 7 -> Position 0\n            data_out[15:8]  <= data_in[55:48];  // Element 6 -> Position 1\n            data_out[23:16] <= data_in[47:40];  // Element 5 -> Position 2\n            data_out[31:24] <= data_in[39:32];  // Element 4 -> Position 3\n            data"
        ],
        "config": {
            "model": "claude-opus-4-20250514",
            "system_instruction": "You are a Verilog code generator. Output only synthesizable Verilog code.",
            "temperature": 0.2,
            "max_tokens": 1024,
            "samples": 10
        }
    },
    {
        "question": "Use a case statement to represent a 2 input AND gate in Verilog",
        "outputs": [
            "```verilog\nmodule and_gate_case (\n    input a,\n    input b,\n    output reg y\n);\n\nalways @(*) begin\n    case ({a, b})\n        2'b00: y = 1'b0;\n        2'b01: y = 1'b0;\n        2'b10: y = 1'b0;\n        2'b11: y = 1'b1;\n    endcase\nend\n\nendmodule\n```",
            "```verilog\nmodule and_gate_case (\n    input a,\n    input b,\n    output reg y\n);\n\nalways @(*) begin\n    case ({a, b})\n        2'b00: y = 1'b0;\n        2'b01: y = 1'b0;\n        2'b10: y = 1'b0;\n        2'b11: y = 1'b1;\n    endcase\nend\n\nendmodule\n```",
            "```verilog\nmodule and_gate (\n    input a,\n    input b,\n    output reg y\n);\n\nalways @(*) begin\n    case ({a, b})\n        2'b00: y = 1'b0;\n        2'b01: y = 1'b0;\n        2'b10: y = 1'b0;\n        2'b11: y = 1'b1;\n    endcase\nend\n\nendmodule\n```",
            "```verilog\nmodule and_gate_case (\n    input a,\n    input b,\n    output reg y\n);\n\nalways @(*) begin\n    case ({a, b})\n        2'b00: y = 1'b0;\n        2'b01: y = 1'b0;\n        2'b10: y = 1'b0;\n        2'b11: y = 1'b1;\n    endcase\nend\n\nendmodule\n```",
            "```verilog\nmodule and_gate_case (\n    input a,\n    input b,\n    output reg y\n);\n\nalways @(*) begin\n    case ({a, b})\n        2'b00: y = 1'b0;\n        2'b01: y = 1'b0;\n        2'b10: y = 1'b0;\n        2'b11: y = 1'b1;\n    endcase\nend\n\nendmodule\n```",
            "```verilog\nmodule and_gate (\n    input a,\n    input b,\n    output reg y\n);\n\nalways @(*) begin\n    case ({a, b})\n        2'b00: y = 1'b0;\n        2'b01: y = 1'b0;\n        2'b10: y = 1'b0;\n        2'b11: y = 1'b1;\n    endcase\nend\n\nendmodule\n```",
            "```verilog\nmodule and_gate_case (\n    input a,\n    input b,\n    output reg y\n);\n\nalways @(*) begin\n    case ({a, b})\n        2'b00: y = 1'b0;\n        2'b01: y = 1'b0;\n        2'b10: y = 1'b0;\n        2'b11: y = 1'b1;\n    endcase\nend\n\nendmodule\n```",
            "```verilog\nmodule and_gate_case (\n    input a,\n    input b,\n    output reg y\n);\n\nalways @(*) begin\n    case ({a, b})\n        2'b00: y = 1'b0;\n        2'b01: y = 1'b0;\n        2'b10: y = 1'b0;\n        2'b11: y = 1'b1;\n    endcase\nend\n\nendmodule\n```",
            "```verilog\nmodule and_gate_case (\n    input a,\n    input b,\n    output reg y\n);\n\nalways @(*) begin\n    case ({a, b})\n        2'b00: y = 1'b0;\n        2'b01: y = 1'b0;\n        2'b10: y = 1'b0;\n        2'b11: y = 1'b1;\n    endcase\nend\n\nendmodule\n```",
            "```verilog\nmodule and_gate_case (\n    input a,\n    input b,\n    output reg y\n);\n\nalways @(*) begin\n    case ({a, b})\n        2'b00: y = 1'b0;\n        2'b01: y = 1'b0;\n        2'b10: y = 1'b0;\n        2'b11: y = 1'b1;\n    endcase\nend\n\nendmodule\n```"
        ],
        "config": {
            "model": "claude-opus-4-20250514",
            "system_instruction": "You are a Verilog code generator. Output only synthesizable Verilog code.",
            "temperature": 0.2,
            "max_tokens": 1024,
            "samples": 10
        }
    },
    {
        "question": "Signed 8 bit adder with overflow detection in Verilog",
        "outputs": [
            "```verilog\nmodule signed_adder_8bit (\n    input signed [7:0] a,\n    input signed [7:0] b,\n    output signed [7:0] sum,\n    output overflow\n);\n\n    // Internal signals\n    wire [7:0] result;\n    wire carry_out;\n    \n    // Perform addition\n    assign {carry_out, result} = {a[7], a} + {b[7], b};\n    \n    // Assign sum output\n    assign sum = result;\n    \n    // Overflow detection for signed addition\n    // Overflow occurs when:\n    // - Two positive numbers add to give a negative result\n    // - Two negative numbers add to give a positive result\n    assign overflow = (a[7] == b[7]) && (result[7] != a[7]);\n\nendmodule\n```",
            "```verilog\nmodule signed_adder_8bit (\n    input signed [7:0] a,\n    input signed [7:0] b,\n    output signed [7:0] sum,\n    output overflow\n);\n\n    // Internal signals\n    wire [7:0] result;\n    wire carry_out;\n    \n    // Perform addition\n    assign {carry_out, result} = {a[7], a} + {b[7], b};\n    \n    // Assign sum output\n    assign sum = result;\n    \n    // Overflow detection for signed addition\n    // Overflow occurs when:\n    // - Two positive numbers add to give a negative result\n    // - Two negative numbers add to give a positive result\n    assign overflow = (a[7] == b[7]) && (result[7] != a[7]);\n\nendmodule\n```",
            "```verilog\nmodule signed_adder_8bit (\n    input signed [7:0] a,\n    input signed [7:0] b,\n    output signed [7:0] sum,\n    output overflow\n);\n\n    // Internal signals\n    wire [7:0] result;\n    wire carry_out;\n    \n    // Perform addition\n    assign {carry_out, result} = {a[7], a} + {b[7], b};\n    \n    // Assign sum output\n    assign sum = result;\n    \n    // Overflow detection for signed addition\n    // Overflow occurs when:\n    // - Two positive numbers add to give a negative result\n    // - Two negative numbers add to give a positive result\n    assign overflow = (a[7] == b[7]) && (result[7] != a[7]);\n\nendmodule\n```",
            "```verilog\nmodule signed_adder_8bit (\n    input signed [7:0] a,\n    input signed [7:0] b,\n    output signed [7:0] sum,\n    output overflow\n);\n\n    // Internal signals\n    wire [7:0] result;\n    wire carry_out;\n    \n    // Perform addition\n    assign {carry_out, result} = {a[7], a} + {b[7], b};\n    \n    // Assign sum output\n    assign sum = result;\n    \n    // Overflow detection for signed addition\n    // Overflow occurs when:\n    // - Two positive numbers add to give a negative result\n    // - Two negative numbers add to give a positive result\n    assign overflow = (a[7] == b[7]) && (result[7] != a[7]);\n\nendmodule\n```",
            "```verilog\nmodule signed_adder_8bit (\n    input signed [7:0] a,\n    input signed [7:0] b,\n    output signed [7:0] sum,\n    output overflow\n);\n\n    // Internal signals\n    wire [7:0] result;\n    wire carry_out;\n    \n    // Perform addition\n    assign {carry_out, result} = {a[7], a} + {b[7], b};\n    \n    // Assign sum output\n    assign sum = result;\n    \n    // Overflow detection for signed addition\n    // Overflow occurs when:\n    // - Two positive numbers add to give a negative result\n    // - Two negative numbers add to give a positive result\n    assign overflow = (a[7] == b[7]) && (result[7] != a[7]);\n\nendmodule\n```",
            "Here's a synthesizable Verilog code for a signed 8-bit adder with overflow detection:\n\n```verilog\nmodule signed_adder_8bit (\n    input  wire [7:0] a,\n    input  wire [7:0] b,\n    output wire [7:0] sum,\n    output wire       overflow\n);\n\n    // Internal signals\n    wire [7:0] result;\n    wire carry_out;\n    \n    // Perform addition\n    assign {carry_out, result} = {a[7], a} + {b[7], b};\n    \n    // Assign sum output\n    assign sum = result;\n    \n    // Overflow detection for signed addition\n    // Overflow occurs when:\n    // - Two positive numbers add to give a negative result\n    // - Two negative numbers add to give a positive result\n    assign overflow = (a[7] == b[7]) && (result[7] != a[7]);\n\nendmodule\n```\n\nAlternative implementation using explicit overflow detection:\n\n```verilog\nmodule signed_adder_8bit_v2 (\n    input  wire [7:0] a,\n    input  wire [7:0] b,\n    output wire [7:0] sum,\n    output wire       overflow\n);\n\n    // Perform addition\n    assign sum = a + b;\n    \n    // Overflow detection\n    // Check if signs of inputs are same but different from output\n    assign overflow = (~a[7] & ~b[7] & sum[7]) |  // Positive + Positive = Negative\n                      (a[7] & b[7] & ~sum[7]);     // Negative + Negative = Positive\n\nendmodule\n```",
            "```verilog\nmodule signed_adder_8bit (\n    input signed [7:0] a,\n    input signed [7:0] b,\n    output signed [7:0] sum,\n    output overflow\n);\n\n    // Perform addition\n    assign sum = a + b;\n    \n    // Overflow detection for signed addition\n    // Overflow occurs when:\n    // - Two positive numbers add to give a negative result\n    // - Two negative numbers add to give a positive result\n    assign overflow = (a[7] == b[7]) && (sum[7] != a[7]);\n\nendmodule\n```",
            "```verilog\nmodule signed_adder_8bit (\n    input signed [7:0] a,\n    input signed [7:0] b,\n    output signed [7:0] sum,\n    output overflow\n);\n\n    // Internal signals\n    wire [7:0] result;\n    wire carry_out;\n    \n    // Perform addition\n    assign {carry_out, result} = {a[7], a} + {b[7], b};\n    \n    // Assign sum output\n    assign sum = result;\n    \n    // Overflow detection for signed addition\n    // Overflow occurs when:\n    // - Two positive numbers add to give a negative result\n    // - Two negative numbers add to give a positive result\n    assign overflow = (a[7] == b[7]) && (result[7] != a[7]);\n\nendmodule\n```",
            "```verilog\nmodule signed_adder_8bit (\n    input signed [7:0] a,\n    input signed [7:0] b,\n    output signed [7:0] sum,\n    output overflow\n);\n\n    // Internal signals\n    wire [7:0] result;\n    wire carry_out;\n    \n    // Perform addition\n    assign {carry_out, result} = {a[7], a} + {b[7], b};\n    \n    // Assign sum output\n    assign sum = result;\n    \n    // Overflow detection for signed addition\n    // Overflow occurs when:\n    // - Two positive numbers add to give a negative result\n    // - Two negative numbers add to give a positive result\n    assign overflow = (a[7] == b[7]) && (result[7] != a[7]);\n\nendmodule\n```",
            "```verilog\nmodule signed_adder_8bit (\n    input signed [7:0] a,\n    input signed [7:0] b,\n    output signed [7:0] sum,\n    output overflow\n);\n\n    // Internal signals\n    wire [7:0] result;\n    wire carry_out;\n    \n    // Perform addition\n    assign {carry_out, result} = {a[7], a} + {b[7], b};\n    \n    // Assign sum output\n    assign sum = result;\n    \n    // Overflow detection for signed addition\n    // Overflow occurs when:\n    // - Two positive numbers add to give a negative result\n    // - Two negative numbers add to give a positive result\n    assign overflow = (a[7] == b[7]) && (result[7] != a[7]);\n\nendmodule\n```"
        ],
        "config": {
            "model": "claude-opus-4-20250514",
            "system_instruction": "You are a Verilog code generator. Output only synthesizable Verilog code.",
            "temperature": 0.2,
            "max_tokens": 1024,
            "samples": 10
        }
    },
    {
        "question": "Verilog module for an up-counter that uses an enable control",
        "outputs": [
            "```verilog\nmodule up_counter #(\n    parameter WIDTH = 8\n)(\n    input  wire             clk,\n    input  wire             rst_n,\n    input  wire             enable,\n    output reg [WIDTH-1:0]  count\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count <= {WIDTH{1'b0}};\n        end\n        else if (enable) begin\n            count <= count + 1'b1;\n        end\n    end\n\nendmodule\n```",
            "```verilog\nmodule up_counter #(\n    parameter WIDTH = 8\n)(\n    input  wire             clk,\n    input  wire             rst_n,\n    input  wire             enable,\n    output reg [WIDTH-1:0]  count\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count <= {WIDTH{1'b0}};\n        end\n        else if (enable) begin\n            count <= count + 1'b1;\n        end\n    end\n\nendmodule\n```",
            "```verilog\nmodule up_counter #(\n    parameter WIDTH = 8\n)(\n    input  wire             clk,\n    input  wire             rst_n,\n    input  wire             enable,\n    output reg [WIDTH-1:0]  count\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count <= {WIDTH{1'b0}};\n        end\n        else if (enable) begin\n            count <= count + 1'b1;\n        end\n    end\n\nendmodule\n```",
            "```verilog\nmodule up_counter #(\n    parameter WIDTH = 8\n)(\n    input  wire             clk,\n    input  wire             rst_n,\n    input  wire             enable,\n    output reg [WIDTH-1:0]  count\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count <= {WIDTH{1'b0}};\n        end\n        else if (enable) begin\n            count <= count + 1'b1;\n        end\n    end\n\nendmodule\n```",
            "```verilog\nmodule up_counter #(\n    parameter WIDTH = 8\n)(\n    input  wire             clk,\n    input  wire             rst_n,\n    input  wire             enable,\n    output reg [WIDTH-1:0]  count\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count <= {WIDTH{1'b0}};\n        end\n        else if (enable) begin\n            count <= count + 1'b1;\n        end\n    end\n\nendmodule\n```",
            "```verilog\nmodule up_counter #(\n    parameter WIDTH = 8\n)(\n    input  wire             clk,\n    input  wire             rst_n,\n    input  wire             enable,\n    output reg [WIDTH-1:0]  count\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count <= {WIDTH{1'b0}};\n        end\n        else if (enable) begin\n            count <= count + 1'b1;\n        end\n    end\n\nendmodule\n```",
            "```verilog\nmodule up_counter #(\n    parameter WIDTH = 8\n)(\n    input  wire             clk,\n    input  wire             rst_n,\n    input  wire             enable,\n    output reg [WIDTH-1:0]  count\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count <= {WIDTH{1'b0}};\n        end\n        else if (enable) begin\n            count <= count + 1'b1;\n        end\n    end\n\nendmodule\n```",
            "```verilog\nmodule up_counter #(\n    parameter WIDTH = 8\n)(\n    input  wire             clk,\n    input  wire             rst_n,\n    input  wire             enable,\n    output reg [WIDTH-1:0]  count\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count <= {WIDTH{1'b0}};\n        end\n        else if (enable) begin\n            count <= count + 1'b1;\n        end\n    end\n\nendmodule\n```",
            "```verilog\nmodule up_counter #(\n    parameter WIDTH = 8\n)(\n    input  wire             clk,\n    input  wire             rst_n,\n    input  wire             enable,\n    output reg [WIDTH-1:0]  count\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count <= {WIDTH{1'b0}};\n        end\n        else if (enable) begin\n            count <= count + 1'b1;\n        end\n    end\n\nendmodule\n```",
            "```verilog\nmodule up_counter #(\n    parameter WIDTH = 8\n)(\n    input  wire             clk,\n    input  wire             rst_n,\n    input  wire             enable,\n    output reg [WIDTH-1:0]  count\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count <= {WIDTH{1'b0}};\n        end\n        else if (enable) begin\n            count <= count + 1'b1;\n        end\n    end\n\nendmodule\n```"
        ],
        "config": {
            "model": "claude-opus-4-20250514",
            "system_instruction": "You are a Verilog code generator. Output only synthesizable Verilog code.",
            "temperature": 0.2,
            "max_tokens": 1024,
            "samples": 10
        }
    },
    {
        "question": "Implement a finite state machine that outputs high on detecting 101 in Verilog",
        "outputs": [
            "Here's a Verilog implementation of a finite state machine that detects the sequence \"101\":\n\n```verilog\nmodule sequence_detector_101 (\n    input wire clk,\n    input wire rst,\n    input wire in,\n    output reg out\n);\n\n    // State encoding\n    parameter S0 = 2'b00;  // Initial state\n    parameter S1 = 2'b01;  // Detected '1'\n    parameter S2 = 2'b10;  // Detected '10'\n    parameter S3 = 2'b11;  // Detected '101'\n\n    reg [1:0] current_state, next_state;\n\n    // State register\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            current_state <= S0;\n        else\n            current_state <= next_state;\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (current_state)\n            S0: begin\n                if (in)\n                    next_state = S1;\n                else\n                    next_state = S0;\n            end\n            \n            S1: begin\n                if (in)\n                    next_state = S1;\n                else\n                    next_state = S2;\n            end\n            \n            S2: begin\n                if (in)\n                    next_state = S3;\n                else\n                    next_state = S0;\n            end\n            \n            S3: begin\n                if (in)\n                    next_state = S1;\n                else\n                    next_state = S2;\n            end\n            \n            default: next_state = S0;\n        endcase\n    end\n\n    // Output logic\n    always @(*) begin\n        out = (current_state == S3);\n    end\n\nendmodule\n```\n\nThis FSM uses a Mealy machine approach where:\n- S0: Initial state, waiting for first '1'\n- S1: Detected '1', waiting for '0'\n- S2: Detected '10', waiting for '1'\n- S3: Detected '101', output goes high\n\nThe FSM handles overlapping sequences, so after detecting \"101\", it can immediately start detecting the next occurrence.",
            "Here's a Verilog implementation of a finite state machine that detects the sequence \"101\":\n\n```verilog\nmodule sequence_detector_101 (\n    input wire clk,\n    input wire rst,\n    input wire in,\n    output reg out\n);\n\n    // State encoding\n    parameter S0 = 2'b00;  // Initial state\n    parameter S1 = 2'b01;  // Detected '1'\n    parameter S2 = 2'b10;  // Detected '10'\n    parameter S3 = 2'b11;  // Detected '101'\n\n    reg [1:0] current_state, next_state;\n\n    // State register\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            current_state <= S0;\n        else\n            current_state <= next_state;\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (current_state)\n            S0: begin\n                if (in)\n                    next_state = S1;\n                else\n                    next_state = S0;\n            end\n            \n            S1: begin\n                if (in)\n                    next_state = S1;\n                else\n                    next_state = S2;\n            end\n            \n            S2: begin\n                if (in)\n                    next_state = S3;\n                else\n                    next_state = S0;\n            end\n            \n            S3: begin\n                if (in)\n                    next_state = S1;\n                else\n                    next_state = S2;\n            end\n            \n            default: next_state = S0;\n        endcase\n    end\n\n    // Output logic\n    always @(*) begin\n        out = (current_state == S3);\n    end\n\nendmodule\n```\n\nThis FSM works as follows:\n- **S0**: Initial state, waiting for '1'\n- **S1**: Detected '1', waiting for '0'\n- **S2**: Detected '10', waiting for '1'\n- **S3**: Detected '101', output goes high\n\nThe FSM handles overlapping sequences, meaning after detecting \"101\", it can immediately start detecting the next \"101\" sequence if the input continues appropriately.",
            "Here's a Verilog implementation of a finite state machine that detects the sequence \"101\":\n\n```verilog\nmodule sequence_detector_101 (\n    input wire clk,\n    input wire reset,\n    input wire data_in,\n    output reg detected\n);\n\n    // State encoding\n    parameter S0 = 2'b00;  // Initial state\n    parameter S1 = 2'b01;  // Detected '1'\n    parameter S2 = 2'b10;  // Detected '10'\n    parameter S3 = 2'b11;  // Detected '101'\n\n    reg [1:0] current_state, next_state;\n\n    // State register\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            current_state <= S0;\n        else\n            current_state <= next_state;\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (current_state)\n            S0: begin\n                if (data_in)\n                    next_state = S1;\n                else\n                    next_state = S0;\n            end\n            \n            S1: begin\n                if (data_in)\n                    next_state = S1;\n                else\n                    next_state = S2;\n            end\n            \n            S2: begin\n                if (data_in)\n                    next_state = S3;\n                else\n                    next_state = S0;\n            end\n            \n            S3: begin\n                if (data_in)\n                    next_state = S1;\n                else\n                    next_state = S2;\n            end\n            \n            default: next_state = S0;\n        endcase\n    end\n\n    // Output logic\n    always @(*) begin\n        detected = (current_state == S3);\n    end\n\nendmodule\n```\n\nThis FSM detects overlapping sequences of \"101\". The state machine has four states:\n- S0: Initial state (no pattern detected)\n- S1: '1' detected\n- S2: '10' detected\n- S3: '101' detected (output goes high)\n\nThe FSM allows for overlapping detection, meaning if the input is \"10101\", it will detect the pattern twice.",
            "Here's a Verilog implementation of a finite state machine that detects the sequence \"101\":\n\n```verilog\nmodule sequence_detector_101 (\n    input wire clk,\n    input wire rst,\n    input wire in,\n    output reg out\n);\n\n    // State encoding\n    parameter S0 = 2'b00;  // Initial state\n    parameter S1 = 2'b01;  // Detected '1'\n    parameter S2 = 2'b10;  // Detected '10'\n    parameter S3 = 2'b11;  // Detected '101'\n\n    reg [1:0] current_state, next_state;\n\n    // State register\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            current_state <= S0;\n        else\n            current_state <= next_state;\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (current_state)\n            S0: begin\n                if (in)\n                    next_state = S1;\n                else\n                    next_state = S0;\n            end\n            \n            S1: begin\n                if (in)\n                    next_state = S1;\n                else\n                    next_state = S2;\n            end\n            \n            S2: begin\n                if (in)\n                    next_state = S3;\n                else\n                    next_state = S0;\n            end\n            \n            S3: begin\n                if (in)\n                    next_state = S1;\n                else\n                    next_state = S2;\n            end\n            \n            default: next_state = S0;\n        endcase\n    end\n\n    // Output logic\n    always @(*) begin\n        out = (current_state == S3);\n    end\n\nendmodule\n```\n\nThis FSM works as follows:\n- **S0**: Initial state, waiting for '1'\n- **S1**: Detected '1', waiting for '0'\n- **S2**: Detected '10', waiting for '1'\n- **S3**: Detected '101', output is high\n\nThe FSM handles overlapping sequences, meaning after detecting \"101\", it can immediately start detecting the next \"101\" sequence if the input continues appropriately.",
            "Here's a Verilog implementation of a finite state machine that detects the sequence \"101\":\n\n```verilog\nmodule sequence_detector_101 (\n    input wire clk,\n    input wire rst,\n    input wire in,\n    output reg out\n);\n\n    // State encoding\n    parameter S0 = 2'b00;  // Initial state\n    parameter S1 = 2'b01;  // Detected '1'\n    parameter S2 = 2'b10;  // Detected '10'\n    parameter S3 = 2'b11;  // Detected '101'\n\n    reg [1:0] current_state, next_state;\n\n    // State register\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            current_state <= S0;\n        else\n            current_state <= next_state;\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (current_state)\n            S0: begin\n                if (in)\n                    next_state = S1;\n                else\n                    next_state = S0;\n            end\n            \n            S1: begin\n                if (in)\n                    next_state = S1;\n                else\n                    next_state = S2;\n            end\n            \n            S2: begin\n                if (in)\n                    next_state = S3;\n                else\n                    next_state = S0;\n            end\n            \n            S3: begin\n                if (in)\n                    next_state = S1;\n                else\n                    next_state = S2;\n            end\n            \n            default: next_state = S0;\n        endcase\n    end\n\n    // Output logic\n    always @(*) begin\n        out = (current_state == S3);\n    end\n\nendmodule\n```\n\nThis FSM works as follows:\n- **S0**: Initial state, waiting for '1'\n- **S1**: Detected '1', waiting for '0'\n- **S2**: Detected '10', waiting for '1'\n- **S3**: Detected '101', output is high\n\nThe FSM handles overlapping sequences, meaning after detecting \"101\", it can immediately start detecting the next \"101\" sequence if the input continues appropriately.",
            "Here's a Verilog implementation of a finite state machine that detects the sequence \"101\":\n\n```verilog\nmodule sequence_detector_101 (\n    input wire clk,\n    input wire reset,\n    input wire in,\n    output reg out\n);\n\n    // State encoding\n    parameter S0 = 2'b00;  // Initial state\n    parameter S1 = 2'b01;  // Detected '1'\n    parameter S2 = 2'b10;  // Detected '10'\n    parameter S3 = 2'b11;  // Detected '101'\n\n    reg [1:0] current_state, next_state;\n\n    // State register\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            current_state <= S0;\n        else\n            current_state <= next_state;\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (current_state)\n            S0: begin\n                if (in)\n                    next_state = S1;\n                else\n                    next_state = S0;\n            end\n            \n            S1: begin\n                if (in)\n                    next_state = S1;\n                else\n                    next_state = S2;\n            end\n            \n            S2: begin\n                if (in)\n                    next_state = S3;\n                else\n                    next_state = S0;\n            end\n            \n            S3: begin\n                if (in)\n                    next_state = S1;\n                else\n                    next_state = S2;\n            end\n            \n            default: next_state = S0;\n        endcase\n    end\n\n    // Output logic\n    always @(*) begin\n        out = (current_state == S3);\n    end\n\nendmodule\n```\n\nThis FSM works as follows:\n- **S0**: Initial state, waiting for '1'\n- **S1**: Detected '1', waiting for '0'\n- **S2**: Detected '10', waiting for '1'\n- **S3**: Detected '101', output is high\n\nThe FSM handles overlapping sequences, meaning after detecting \"101\", it can immediately start detecting the next \"101\" sequence if the input continues appropriately.",
            "Here's a Verilog implementation of a finite state machine that detects the sequence \"101\":\n\n```verilog\nmodule sequence_detector_101 (\n    input wire clk,\n    input wire rst,\n    input wire in,\n    output reg out\n);\n\n    // State encoding\n    parameter S0 = 2'b00;  // Initial state\n    parameter S1 = 2'b01;  // Detected '1'\n    parameter S2 = 2'b10;  // Detected '10'\n    parameter S3 = 2'b11;  // Detected '101'\n\n    reg [1:0] current_state, next_state;\n\n    // State register\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            current_state <= S0;\n        else\n            current_state <= next_state;\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (current_state)\n            S0: begin\n                if (in)\n                    next_state = S1;\n                else\n                    next_state = S0;\n            end\n            \n            S1: begin\n                if (in)\n                    next_state = S1;\n                else\n                    next_state = S2;\n            end\n            \n            S2: begin\n                if (in)\n                    next_state = S3;\n                else\n                    next_state = S0;\n            end\n            \n            S3: begin\n                if (in)\n                    next_state = S1;\n                else\n                    next_state = S2;\n            end\n            \n            default: next_state = S0;\n        endcase\n    end\n\n    // Output logic\n    always @(*) begin\n        out = (current_state == S3);\n    end\n\nendmodule\n```\n\nThis FSM works as follows:\n- **S0**: Initial state, waiting for '1'\n- **S1**: Detected '1', waiting for '0'\n- **S2**: Detected '10', waiting for '1'\n- **S3**: Detected '101', output goes high\n\nThe FSM handles overlapping sequences, meaning after detecting \"101\", it can immediately start detecting the next \"101\" sequence if the input continues appropriately.",
            "Here's a Verilog implementation of a finite state machine that detects the sequence \"101\":\n\n```verilog\nmodule sequence_detector_101 (\n    input wire clk,\n    input wire rst,\n    input wire in,\n    output reg out\n);\n\n    // State encoding\n    parameter S0 = 2'b00;  // Initial state\n    parameter S1 = 2'b01;  // Detected '1'\n    parameter S2 = 2'b10;  // Detected '10'\n    parameter S3 = 2'b11;  // Detected '101'\n\n    reg [1:0] current_state, next_state;\n\n    // State register\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            current_state <= S0;\n        else\n            current_state <= next_state;\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (current_state)\n            S0: begin\n                if (in)\n                    next_state = S1;\n                else\n                    next_state = S0;\n            end\n            \n            S1: begin\n                if (in)\n                    next_state = S1;\n                else\n                    next_state = S2;\n            end\n            \n            S2: begin\n                if (in)\n                    next_state = S3;\n                else\n                    next_state = S0;\n            end\n            \n            S3: begin\n                if (in)\n                    next_state = S1;\n                else\n                    next_state = S2;\n            end\n            \n            default: next_state = S0;\n        endcase\n    end\n\n    // Output logic\n    always @(*) begin\n        out = (current_state == S3);\n    end\n\nendmodule\n```\n\nThis FSM uses a Mealy machine approach where:\n- S0: Initial state, waiting for '1'\n- S1: Detected '1', waiting for '0'\n- S2: Detected '10', waiting for '1'\n- S3: Detected '101', output is high\n\nThe FSM handles overlapping sequences, so after detecting \"101\", it can immediately start detecting the next occurrence if the pattern continues.",
            "Here's a Verilog implementation of a finite state machine that detects the sequence \"101\":\n\n```verilog\nmodule sequence_detector_101 (\n    input wire clk,\n    input wire rst,\n    input wire in,\n    output reg out\n);\n\n    // State encoding\n    parameter S0 = 2'b00;  // Initial state\n    parameter S1 = 2'b01;  // Detected '1'\n    parameter S2 = 2'b10;  // Detected '10'\n    parameter S3 = 2'b11;  // Detected '101'\n\n    reg [1:0] current_state, next_state;\n\n    // State register\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            current_state <= S0;\n        else\n            current_state <= next_state;\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (current_state)\n            S0: begin\n                if (in)\n                    next_state = S1;\n                else\n                    next_state = S0;\n            end\n            \n            S1: begin\n                if (in)\n                    next_state = S1;\n                else\n                    next_state = S2;\n            end\n            \n            S2: begin\n                if (in)\n                    next_state = S3;\n                else\n                    next_state = S0;\n            end\n            \n            S3: begin\n                if (in)\n                    next_state = S1;\n                else\n                    next_state = S2;\n            end\n            \n            default: next_state = S0;\n        endcase\n    end\n\n    // Output logic\n    always @(*) begin\n        out = (current_state == S3);\n    end\n\nendmodule\n```\n\nThis FSM works as follows:\n- **S0**: Initial state, waiting for '1'\n- **S1**: Detected '1', waiting for '0'\n- **S2**: Detected '10', waiting for '1'\n- **S3**: Detected '101', output is high\n\nThe FSM handles overlapping sequences, so after detecting \"101\", it can immediately start detecting the next occurrence if the input continues with appropriate values.",
            "Here's a Verilog implementation of a finite state machine that detects the sequence \"101\":\n\n```verilog\nmodule sequence_detector_101 (\n    input wire clk,\n    input wire rst,\n    input wire in,\n    output reg out\n);\n\n    // State encoding\n    parameter S0 = 2'b00;  // Initial state\n    parameter S1 = 2'b01;  // Detected '1'\n    parameter S2 = 2'b10;  // Detected '10'\n    parameter S3 = 2'b11;  // Detected '101'\n\n    reg [1:0] current_state, next_state;\n\n    // State register\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            current_state <= S0;\n        else\n            current_state <= next_state;\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (current_state)\n            S0: begin\n                if (in)\n                    next_state = S1;\n                else\n                    next_state = S0;\n            end\n            \n            S1: begin\n                if (in)\n                    next_state = S1;\n                else\n                    next_state = S2;\n            end\n            \n            S2: begin\n                if (in)\n                    next_state = S3;\n                else\n                    next_state = S0;\n            end\n            \n            S3: begin\n                if (in)\n                    next_state = S1;\n                else\n                    next_state = S2;\n            end\n            \n            default: next_state = S0;\n        endcase\n    end\n\n    // Output logic\n    always @(*) begin\n        out = (current_state == S3);\n    end\n\nendmodule\n```\n\nThis FSM works as follows:\n- **S0**: Initial state, waiting for '1'\n- **S1**: Detected '1', waiting for '0'\n- **S2**: Detected '10', waiting for '1'\n- **S3**: Detected '101', output goes high\n\nThe FSM handles overlapping sequences, meaning after detecting \"101\", it can immediately start detecting the next \"101\" sequence if the input continues appropriately."
        ],
        "config": {
            "model": "claude-opus-4-20250514",
            "system_instruction": "You are a Verilog code generator. Output only synthesizable Verilog code.",
            "temperature": 0.2,
            "max_tokens": 1024,
            "samples": 10
        }
    },
    {
        "question": "Design an arithmetic shift register in Verilog with 64 bit width",
        "outputs": [
            "Here's a synthesizable Verilog implementation of a 64-bit arithmetic shift register:\n\n```verilog\nmodule arithmetic_shift_register (\n    input wire clk,\n    input wire rst_n,\n    input wire load,\n    input wire shift_enable,\n    input wire shift_direction,  // 0: right shift, 1: left shift\n    input wire [5:0] shift_amount,\n    input wire [63:0] data_in,\n    output reg [63:0] data_out\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            data_out <= 64'b0;\n        end\n        else if (load) begin\n            data_out <= data_in;\n        end\n        else if (shift_enable) begin\n            if (shift_direction) begin\n                // Arithmetic left shift\n                data_out <= data_out <<< shift_amount;\n            end\n            else begin\n                // Arithmetic right shift\n                data_out <= data_out >>> shift_amount;\n            end\n        end\n    end\n\nendmodule\n```\n\nAlternative implementation with single-bit shift per clock cycle:\n\n```verilog\nmodule arithmetic_shift_register_sequential (\n    input wire clk,\n    input wire rst_n,\n    input wire load,\n    input wire shift_enable,\n    input wire shift_direction,  // 0: right shift, 1: left shift\n    input wire [63:0] data_in,\n    output reg [63:0] data_out\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            data_out <= 64'b0;\n        end\n        else if (load) begin\n            data_out <= data_in;\n        end\n        else if (shift_enable) begin\n            if (shift_direction) begin\n                // Arithmetic left shift by 1\n                data_out <= {data_out[62:0], 1'b0};\n            end\n            else begin\n                // Arithmetic right shift by 1\n                data_out <= {data_out[63], data_out[63:1]};\n            end\n        end\n    end\n\nendmodule\n```",
            "Here's a synthesizable Verilog implementation of a 64-bit arithmetic shift register:\n\n```verilog\nmodule arithmetic_shift_register (\n    input wire clk,\n    input wire rst_n,\n    input wire load,\n    input wire shift_en,\n    input wire shift_dir,      // 0: left shift, 1: right shift\n    input wire [63:0] data_in,\n    output reg [63:0] data_out\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            data_out <= 64'b0;\n        end\n        else if (load) begin\n            data_out <= data_in;\n        end\n        else if (shift_en) begin\n            if (shift_dir) begin\n                // Arithmetic right shift - preserve sign bit\n                data_out <= {data_out[63], data_out[63:1]};\n            end\n            else begin\n                // Arithmetic left shift - fill with zeros\n                data_out <= {data_out[62:0], 1'b0};\n            end\n        end\n    end\n\nendmodule\n```\n\nThis arithmetic shift register includes:\n- 64-bit data width\n- Asynchronous active-low reset\n- Load capability for parallel data input\n- Shift enable control\n- Bidirectional shifting (left/right)\n- Arithmetic right shift preserves the sign bit (MSB)\n- Arithmetic left shift fills with zeros from the right",
            "Here's a synthesizable Verilog implementation of a 64-bit arithmetic shift register:\n\n```verilog\nmodule arithmetic_shift_register (\n    input wire clk,\n    input wire rst_n,\n    input wire load,\n    input wire shift_enable,\n    input wire shift_direction,  // 0: left shift, 1: right shift\n    input wire [63:0] data_in,\n    output reg [63:0] data_out\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            data_out <= 64'b0;\n        end\n        else if (load) begin\n            data_out <= data_in;\n        end\n        else if (shift_enable) begin\n            if (shift_direction) begin\n                // Arithmetic right shift - preserve sign bit\n                data_out <= {data_out[63], data_out[63:1]};\n            end\n            else begin\n                // Arithmetic left shift - fill with zeros\n                data_out <= {data_out[62:0], 1'b0};\n            end\n        end\n    end\n\nendmodule\n```\n\nThis arithmetic shift register includes:\n- 64-bit data width\n- Asynchronous active-low reset\n- Load capability for parallel data input\n- Shift enable control\n- Bidirectional shifting (left/right)\n- Arithmetic right shift preserves the sign bit (MSB)\n- Arithmetic left shift fills with zeros from the right",
            "Here's a synthesizable Verilog implementation of a 64-bit arithmetic shift register:\n\n```verilog\nmodule arithmetic_shift_register (\n    input wire clk,\n    input wire rst_n,\n    input wire load,\n    input wire shift_enable,\n    input wire shift_direction,  // 0: right shift, 1: left shift\n    input wire [5:0] shift_amount,\n    input wire [63:0] data_in,\n    output reg [63:0] data_out\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            data_out <= 64'b0;\n        end\n        else if (load) begin\n            data_out <= data_in;\n        end\n        else if (shift_enable) begin\n            if (shift_direction) begin\n                // Arithmetic left shift\n                data_out <= data_out <<< shift_amount;\n            end\n            else begin\n                // Arithmetic right shift\n                data_out <= data_out >>> shift_amount;\n            end\n        end\n    end\n\nendmodule\n```\n\nAlternative implementation with single-bit shift per clock cycle:\n\n```verilog\nmodule arithmetic_shift_register_sequential (\n    input wire clk,\n    input wire rst_n,\n    input wire load,\n    input wire shift_enable,\n    input wire shift_direction,  // 0: right shift, 1: left shift\n    input wire [63:0] data_in,\n    output reg [63:0] data_out\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            data_out <= 64'b0;\n        end\n        else if (load) begin\n            data_out <= data_in;\n        end\n        else if (shift_enable) begin\n            if (shift_direction) begin\n                // Arithmetic left shift by 1\n                data_out <= {data_out[62:0], 1'b0};\n            end\n            else begin\n                // Arithmetic right shift by 1\n                data_out <= {data_out[63], data_out[63:1]};\n            end\n        end\n    end\n\nendmodule\n```",
            "Here's a synthesizable Verilog implementation of a 64-bit arithmetic shift register:\n\n```verilog\nmodule arithmetic_shift_register (\n    input wire clk,\n    input wire rst_n,\n    input wire load,\n    input wire shift_enable,\n    input wire shift_direction,  // 0: left shift, 1: right shift\n    input wire [63:0] data_in,\n    output reg [63:0] data_out\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            data_out <= 64'b0;\n        end\n        else if (load) begin\n            data_out <= data_in;\n        end\n        else if (shift_enable) begin\n            if (shift_direction) begin\n                // Arithmetic right shift - preserve sign bit\n                data_out <= {data_out[63], data_out[63:1]};\n            end\n            else begin\n                // Arithmetic left shift - fill with zeros\n                data_out <= {data_out[62:0], 1'b0};\n            end\n        end\n    end\n\nendmodule\n```\n\nThis arithmetic shift register includes:\n- 64-bit data width\n- Asynchronous active-low reset\n- Load capability for parallel data input\n- Shift enable control\n- Bidirectional shifting (left/right)\n- Arithmetic right shift preserves the sign bit (MSB)\n- Arithmetic left shift fills with zeros from the right",
            "Here's a synthesizable Verilog implementation of a 64-bit arithmetic shift register:\n\n```verilog\nmodule arithmetic_shift_register (\n    input wire clk,\n    input wire rst_n,\n    input wire load,\n    input wire shift_enable,\n    input wire shift_direction,  // 0: left shift, 1: right shift\n    input wire [63:0] data_in,\n    output reg [63:0] data_out\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            data_out <= 64'b0;\n        end\n        else if (load) begin\n            data_out <= data_in;\n        end\n        else if (shift_enable) begin\n            if (shift_direction) begin\n                // Arithmetic right shift - preserve sign bit\n                data_out <= {data_out[63], data_out[63:1]};\n            end\n            else begin\n                // Arithmetic left shift - fill with zeros\n                data_out <= {data_out[62:0], 1'b0};\n            end\n        end\n    end\n\nendmodule\n```\n\nThis arithmetic shift register features:\n- 64-bit data width\n- Asynchronous active-low reset\n- Load capability for parallel data input\n- Shift enable control\n- Bidirectional shifting (left/right)\n- Arithmetic right shift preserves the sign bit (MSB)\n- Arithmetic left shift fills with zeros from the right",
            "Here's a synthesizable Verilog implementation of a 64-bit arithmetic shift register:\n\n```verilog\nmodule arithmetic_shift_register (\n    input wire clk,\n    input wire rst_n,\n    input wire load,\n    input wire shift_enable,\n    input wire shift_direction,  // 0: left shift, 1: right shift\n    input wire [63:0] data_in,\n    output reg [63:0] data_out\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            data_out <= 64'b0;\n        end\n        else if (load) begin\n            data_out <= data_in;\n        end\n        else if (shift_enable) begin\n            if (shift_direction) begin\n                // Arithmetic right shift - preserve sign bit\n                data_out <= {data_out[63], data_out[63:1]};\n            end\n            else begin\n                // Arithmetic left shift - fill with zeros\n                data_out <= {data_out[62:0], 1'b0};\n            end\n        end\n    end\n\nendmodule\n```\n\nThis arithmetic shift register includes:\n- 64-bit data width\n- Asynchronous active-low reset\n- Load capability for parallel data input\n- Shift enable control\n- Bidirectional shifting (left/right)\n- Arithmetic right shift preserves the sign bit (MSB)\n- Arithmetic left shift fills with zeros from the right",
            "Here's a synthesizable Verilog implementation of a 64-bit arithmetic shift register:\n\n```verilog\nmodule arithmetic_shift_register (\n    input wire clk,\n    input wire rst_n,\n    input wire load,\n    input wire shift_enable,\n    input wire shift_direction,  // 0: left shift, 1: right shift\n    input wire [63:0] data_in,\n    output reg [63:0] data_out\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            data_out <= 64'b0;\n        end\n        else if (load) begin\n            data_out <= data_in;\n        end\n        else if (shift_enable) begin\n            if (shift_direction) begin\n                // Arithmetic right shift - preserve sign bit\n                data_out <= {data_out[63], data_out[63:1]};\n            end\n            else begin\n                // Arithmetic left shift - fill with zeros\n                data_out <= {data_out[62:0], 1'b0};\n            end\n        end\n    end\n\nendmodule\n```\n\nThis arithmetic shift register includes:\n- 64-bit data width\n- Asynchronous active-low reset\n- Load capability for parallel data input\n- Shift enable control\n- Bidirectional shifting (left/right)\n- Arithmetic right shift preserves the sign bit (MSB)\n- Arithmetic left shift fills with zeros from the right",
            "Here's a synthesizable Verilog implementation of a 64-bit arithmetic shift register:\n\n```verilog\nmodule arithmetic_shift_register (\n    input wire clk,\n    input wire rst_n,\n    input wire load,\n    input wire shift_enable,\n    input wire shift_direction,  // 0: left shift, 1: right shift\n    input wire [63:0] data_in,\n    output reg [63:0] data_out\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            data_out <= 64'b0;\n        end\n        else if (load) begin\n            data_out <= data_in;\n        end\n        else if (shift_enable) begin\n            if (shift_direction) begin\n                // Arithmetic right shift - preserve sign bit\n                data_out <= {data_out[63], data_out[63:1]};\n            end\n            else begin\n                // Arithmetic left shift - fill with zeros\n                data_out <= {data_out[62:0], 1'b0};\n            end\n        end\n    end\n\nendmodule\n```\n\nThis arithmetic shift register features:\n- 64-bit data width\n- Asynchronous active-low reset\n- Load capability for parallel data input\n- Shift enable control\n- Bidirectional shifting (left/right)\n- Arithmetic right shift preserves the sign bit (MSB)\n- Arithmetic left shift fills with zeros from the right",
            "Here's a synthesizable Verilog implementation of a 64-bit arithmetic shift register:\n\n```verilog\nmodule arithmetic_shift_register (\n    input wire clk,\n    input wire rst_n,\n    input wire load,\n    input wire shift_enable,\n    input wire shift_direction,  // 0: right shift, 1: left shift\n    input wire [5:0] shift_amount,\n    input wire [63:0] data_in,\n    output reg [63:0] data_out\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            data_out <= 64'b0;\n        end\n        else if (load) begin\n            data_out <= data_in;\n        end\n        else if (shift_enable) begin\n            if (shift_direction) begin\n                // Arithmetic left shift\n                data_out <= data_out <<< shift_amount;\n            end\n            else begin\n                // Arithmetic right shift\n                data_out <= data_out >>> shift_amount;\n            end\n        end\n    end\n\nendmodule\n```\n\nAlternative implementation with single-bit shift per clock cycle:\n\n```verilog\nmodule arithmetic_shift_register_sequential (\n    input wire clk,\n    input wire rst_n,\n    input wire load,\n    input wire shift_enable,\n    input wire shift_direction,  // 0: right shift, 1: left shift\n    input wire [63:0] data_in,\n    output reg [63:0] data_out\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            data_out <= 64'b0;\n        end\n        else if (load) begin\n            data_out <= data_in;\n        end\n        else if (shift_enable) begin\n            if (shift_direction) begin\n                // Arithmetic left shift by 1\n                data_out <= {data_out[62:0], 1'b0};\n            end\n            else begin\n                // Arithmetic right shift by 1\n                data_out <= {data_out[63], data_out[63:1]};\n            end\n        end\n    end\n\nendmodule\n```"
        ],
        "config": {
            "model": "claude-opus-4-20250514",
            "system_instruction": "You are a Verilog code generator. Output only synthesizable Verilog code.",
            "temperature": 0.2,
            "max_tokens": 1024,
            "samples": 10
        }
    },
    {
        "question": "Design a finite state machine for ABRO sequence",
        "outputs": [
            "Here's a synthesizable Verilog implementation of an ABRO sequence detector FSM:\n\n```verilog\nmodule abro_fsm (\n    input wire clk,\n    input wire rst,\n    input wire A,\n    input wire B,\n    input wire R,\n    output reg O\n);\n\n    // State encoding\n    parameter IDLE = 3'b000;\n    parameter GOT_A = 3'b001;\n    parameter GOT_B = 3'b010;\n    parameter GOT_AB = 3'b011;\n\n    reg [2:0] current_state, next_state;\n\n    // State register\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            current_state <= IDLE;\n        else\n            current_state <= next_state;\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (current_state)\n            IDLE: begin\n                if (R)\n                    next_state = IDLE;\n                else if (A && !B)\n                    next_state = GOT_A;\n                else if (!A && B)\n                    next_state = GOT_B;\n                else if (A && B)\n                    next_state = GOT_AB;\n                else\n                    next_state = IDLE;\n            end\n            \n            GOT_A: begin\n                if (R)\n                    next_state = IDLE;\n                else if (B)\n                    next_state = GOT_AB;\n                else\n                    next_state = GOT_A;\n            end\n            \n            GOT_B: begin\n                if (R)\n                    next_state = IDLE;\n                else if (A)\n                    next_state = GOT_AB;\n                else\n                    next_state = GOT_B;\n            end\n            \n            GOT_AB: begin\n                if (R)\n                    next_state = IDLE;\n                else\n                    next_state = GOT_AB;\n            end\n            \n            default: next_state = IDLE;\n        endcase\n    end\n\n    // Output logic\n    always @(*) begin\n        O = (current_state == GOT_AB) && !R;\n    end\n\nendmodule\n```",
            "Here's a synthesizable Verilog implementation of an ABRO (A-B-Reset-Output) sequence detector FSM:\n\n```verilog\nmodule abro_fsm (\n    input  wire clk,\n    input  wire rst,\n    input  wire A,\n    input  wire B,\n    output reg  O\n);\n\n    // State encoding\n    localparam IDLE   = 2'b00;\n    localparam GOT_A  = 2'b01;\n    localparam GOT_B  = 2'b10;\n    localparam GOT_AB = 2'b11;\n\n    // State register\n    reg [1:0] current_state, next_state;\n\n    // State register update\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            current_state <= IDLE;\n        else\n            current_state <= next_state;\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (current_state)\n            IDLE: begin\n                if (A && !B)\n                    next_state = GOT_A;\n                else if (!A && B)\n                    next_state = GOT_B;\n                else if (A && B)\n                    next_state = GOT_AB;\n                else\n                    next_state = IDLE;\n            end\n            \n            GOT_A: begin\n                if (B)\n                    next_state = GOT_AB;\n                else\n                    next_state = GOT_A;\n            end\n            \n            GOT_B: begin\n                if (A)\n                    next_state = GOT_AB;\n                else\n                    next_state = GOT_B;\n            end\n            \n            GOT_AB: begin\n                next_state = IDLE;\n            end\n            \n            default: next_state = IDLE;\n        endcase\n    end\n\n    // Output logic\n    always @(*) begin\n        O = (current_state == GOT_AB);\n    end\n\nendmodule\n```\n\nThis FSM implements the ABRO sequence where:\n- The FSM waits for inputs A and B to occur (in any order)\n- Once both A and B have been received, output O is asserted\n- After asserting O, the FSM returns to the initial state\n- The reset signal brings the FSM back to the IDLE state\n\nThe states are:\n- IDLE: Initial state, waiting for A or B\n- GOT_A: Received A, waiting for B\n- GOT_B: Received B, waiting for A\n- GOT_AB: Received both A and B, assert output O",
            "Here's a synthesizable Verilog implementation of an ABRO (A-B-Reset-Output) sequence detector FSM:\n\n```verilog\nmodule abro_fsm (\n    input  wire clk,\n    input  wire rst,\n    input  wire A,\n    input  wire B,\n    output reg  O\n);\n\n    // State encoding\n    localparam IDLE   = 2'b00;\n    localparam GOT_A  = 2'b01;\n    localparam GOT_B  = 2'b10;\n    localparam GOT_AB = 2'b11;\n\n    // State register\n    reg [1:0] current_state, next_state;\n\n    // State register update\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            current_state <= IDLE;\n        else\n            current_state <= next_state;\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (current_state)\n            IDLE: begin\n                if (A && !B)\n                    next_state = GOT_A;\n                else if (!A && B)\n                    next_state = GOT_B;\n                else if (A && B)\n                    next_state = GOT_AB;\n                else\n                    next_state = IDLE;\n            end\n            \n            GOT_A: begin\n                if (B)\n                    next_state = GOT_AB;\n                else\n                    next_state = GOT_A;\n            end\n            \n            GOT_B: begin\n                if (A)\n                    next_state = GOT_AB;\n                else\n                    next_state = GOT_B;\n            end\n            \n            GOT_AB: begin\n                next_state = IDLE;\n            end\n            \n            default: next_state = IDLE;\n        endcase\n    end\n\n    // Output logic\n    always @(*) begin\n        O = (current_state == GOT_AB);\n    end\n\nendmodule\n```\n\nThis FSM implements the ABRO sequence where:\n- The FSM waits for inputs A and B to occur (in any order)\n- Once both A and B have been received, output O is asserted\n- The FSM then returns to the initial state\n- Reset signal brings the FSM back to IDLE state\n\nThe states are:\n- IDLE: Initial state, waiting for A or B\n- GOT_A: Received A, waiting for B\n- GOT_B: Received B, waiting for A\n- GOT_AB: Received both A and B, assert output O",
            "Here's a synthesizable Verilog implementation of an ABRO sequence detector FSM:\n\n```verilog\nmodule abro_fsm (\n    input wire clk,\n    input wire rst,\n    input wire A,\n    input wire B,\n    input wire R,\n    output reg O\n);\n\n    // State encoding\n    parameter IDLE = 3'b000;\n    parameter GOT_A = 3'b001;\n    parameter GOT_B = 3'b010;\n    parameter GOT_AB = 3'b011;\n\n    reg [2:0] current_state, next_state;\n\n    // State register\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            current_state <= IDLE;\n        else\n            current_state <= next_state;\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (current_state)\n            IDLE: begin\n                if (R)\n                    next_state = IDLE;\n                else if (A && !B)\n                    next_state = GOT_A;\n                else if (!A && B)\n                    next_state = GOT_B;\n                else if (A && B)\n                    next_state = GOT_AB;\n                else\n                    next_state = IDLE;\n            end\n            \n            GOT_A: begin\n                if (R)\n                    next_state = IDLE;\n                else if (B)\n                    next_state = GOT_AB;\n                else\n                    next_state = GOT_A;\n            end\n            \n            GOT_B: begin\n                if (R)\n                    next_state = IDLE;\n                else if (A)\n                    next_state = GOT_AB;\n                else\n                    next_state = GOT_B;\n            end\n            \n            GOT_AB: begin\n                if (R)\n                    next_state = IDLE;\n                else\n                    next_state = GOT_AB;\n            end\n            \n            default: next_state = IDLE;\n        endcase\n    end\n\n    // Output logic\n    always @(*) begin\n        O = (current_state == GOT_AB) && !R;\n    end\n\nendmodule\n```",
            "Here's a synthesizable Verilog implementation of an ABRO (A-B-Reset-Output) sequence detector FSM:\n\n```verilog\nmodule abro_fsm (\n    input  wire clk,\n    input  wire rst,\n    input  wire a,\n    input  wire b,\n    output reg  o\n);\n\n    // State encoding\n    localparam IDLE   = 2'b00;\n    localparam GOT_A  = 2'b01;\n    localparam GOT_B  = 2'b10;\n    localparam GOT_AB = 2'b11;\n\n    // State register\n    reg [1:0] current_state, next_state;\n\n    // State register update\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            current_state <= IDLE;\n        else\n            current_state <= next_state;\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (current_state)\n            IDLE: begin\n                if (a && !b)\n                    next_state = GOT_A;\n                else if (!a && b)\n                    next_state = GOT_B;\n                else if (a && b)\n                    next_state = GOT_AB;\n                else\n                    next_state = IDLE;\n            end\n            \n            GOT_A: begin\n                if (b)\n                    next_state = GOT_AB;\n                else\n                    next_state = GOT_A;\n            end\n            \n            GOT_B: begin\n                if (a)\n                    next_state = GOT_AB;\n                else\n                    next_state = GOT_B;\n            end\n            \n            GOT_AB: begin\n                next_state = IDLE;\n            end\n            \n            default: next_state = IDLE;\n        endcase\n    end\n\n    // Output logic\n    always @(*) begin\n        o = (current_state == GOT_AB);\n    end\n\nendmodule\n```\n\nThis FSM implements the ABRO sequence where:\n- The FSM waits for inputs A and B to occur (in any order)\n- Once both A and B have been received, output O is asserted\n- After asserting O, the FSM returns to the initial state\n- The reset signal brings the FSM back to the IDLE state\n\nThe states are:\n- IDLE: Initial state, waiting for A or B\n- GOT_A: Received A, waiting for B\n- GOT_B: Received B, waiting for A\n- GOT_AB: Received both A and B, assert output O",
            "Here's a synthesizable Verilog implementation of an ABRO sequence detector FSM:\n\n```verilog\nmodule abro_fsm (\n    input wire clk,\n    input wire rst,\n    input wire A,\n    input wire B,\n    input wire R,\n    output reg O\n);\n\n    // State encoding\n    parameter IDLE = 3'b000;\n    parameter GOT_A = 3'b001;\n    parameter GOT_B = 3'b010;\n    parameter GOT_AB = 3'b011;\n\n    reg [2:0] current_state, next_state;\n\n    // State register\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            current_state <= IDLE;\n        else\n            current_state <= next_state;\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (current_state)\n            IDLE: begin\n                if (R)\n                    next_state = IDLE;\n                else if (A && !B)\n                    next_state = GOT_A;\n                else if (!A && B)\n                    next_state = GOT_B;\n                else if (A && B)\n                    next_state = GOT_AB;\n                else\n                    next_state = IDLE;\n            end\n            \n            GOT_A: begin\n                if (R)\n                    next_state = IDLE;\n                else if (B)\n                    next_state = GOT_AB;\n                else\n                    next_state = GOT_A;\n            end\n            \n            GOT_B: begin\n                if (R)\n                    next_state = IDLE;\n                else if (A)\n                    next_state = GOT_AB;\n                else\n                    next_state = GOT_B;\n            end\n            \n            GOT_AB: begin\n                if (R)\n                    next_state = IDLE;\n                else\n                    next_state = GOT_AB;\n            end\n            \n            default: next_state = IDLE;\n        endcase\n    end\n\n    // Output logic\n    always @(*) begin\n        O = (current_state == GOT_AB) && !R;\n    end\n\nendmodule\n```",
            "Here's a synthesizable Verilog implementation of an ABRO sequence detector FSM:\n\n```verilog\nmodule abro_fsm (\n    input wire clk,\n    input wire rst,\n    input wire A,\n    input wire B,\n    input wire R,\n    output reg O\n);\n\n    // State encoding\n    parameter IDLE = 3'b000;\n    parameter GOT_A = 3'b001;\n    parameter GOT_B = 3'b010;\n    parameter GOT_AB = 3'b011;\n\n    reg [2:0] current_state, next_state;\n\n    // State register\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            current_state <= IDLE;\n        else\n            current_state <= next_state;\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (current_state)\n            IDLE: begin\n                if (R)\n                    next_state = IDLE;\n                else if (A && !B)\n                    next_state = GOT_A;\n                else if (!A && B)\n                    next_state = GOT_B;\n                else if (A && B)\n                    next_state = GOT_AB;\n                else\n                    next_state = IDLE;\n            end\n            \n            GOT_A: begin\n                if (R)\n                    next_state = IDLE;\n                else if (B)\n                    next_state = GOT_AB;\n                else\n                    next_state = GOT_A;\n            end\n            \n            GOT_B: begin\n                if (R)\n                    next_state = IDLE;\n                else if (A)\n                    next_state = GOT_AB;\n                else\n                    next_state = GOT_B;\n            end\n            \n            GOT_AB: begin\n                if (R)\n                    next_state = IDLE;\n                else\n                    next_state = GOT_AB;\n            end\n            \n            default: next_state = IDLE;\n        endcase\n    end\n\n    // Output logic\n    always @(*) begin\n        O = (current_state == GOT_AB) && !R;\n    end\n\nendmodule\n```",
            "Here's a synthesizable Verilog implementation of an ABRO (A-B-Reset-Output) sequence detector FSM:\n\n```verilog\nmodule abro_fsm (\n    input  wire clk,\n    input  wire rst,\n    input  wire a,\n    input  wire b,\n    output reg  o\n);\n\n    // State encoding\n    localparam IDLE   = 2'b00;\n    localparam GOT_A  = 2'b01;\n    localparam GOT_B  = 2'b10;\n    localparam GOT_AB = 2'b11;\n\n    // State register\n    reg [1:0] current_state, next_state;\n\n    // State register update\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            current_state <= IDLE;\n        else\n            current_state <= next_state;\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (current_state)\n            IDLE: begin\n                if (a && !b)\n                    next_state = GOT_A;\n                else if (!a && b)\n                    next_state = GOT_B;\n                else if (a && b)\n                    next_state = GOT_AB;\n                else\n                    next_state = IDLE;\n            end\n            \n            GOT_A: begin\n                if (b)\n                    next_state = GOT_AB;\n                else\n                    next_state = GOT_A;\n            end\n            \n            GOT_B: begin\n                if (a)\n                    next_state = GOT_AB;\n                else\n                    next_state = GOT_B;\n            end\n            \n            GOT_AB: begin\n                next_state = IDLE;\n            end\n            \n            default: next_state = IDLE;\n        endcase\n    end\n\n    // Output logic\n    always @(*) begin\n        o = (current_state == GOT_AB);\n    end\n\nendmodule\n```\n\nThis FSM implements the ABRO sequence where:\n- The FSM waits for inputs A and B to occur (in any order)\n- Once both A and B have been received, output O is asserted\n- After asserting O, the FSM returns to the initial state\n- The reset signal brings the FSM back to the IDLE state\n\nThe states are:\n- IDLE: Initial state, waiting for A or B\n- GOT_A: Received A, waiting for B\n- GOT_B: Received B, waiting for A\n- GOT_AB: Received both A and B, assert output O",
            "Here's a synthesizable Verilog code for an ABRO (A-B-Reset-Output) sequence detector FSM:\n\n```verilog\nmodule abro_fsm (\n    input wire clk,\n    input wire rst,\n    input wire a,\n    input wire b,\n    output reg o\n);\n\n    // State encoding\n    parameter IDLE = 2'b00;\n    parameter GOT_A = 2'b01;\n    parameter GOT_B = 2'b10;\n    parameter GOT_AB = 2'b11;\n\n    // State register\n    reg [1:0] current_state, next_state;\n\n    // State register update\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            current_state <= IDLE;\n        else\n            current_state <= next_state;\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (current_state)\n            IDLE: begin\n                if (a && !b)\n                    next_state = GOT_A;\n                else if (!a && b)\n                    next_state = GOT_B;\n                else if (a && b)\n                    next_state = GOT_AB;\n                else\n                    next_state = IDLE;\n            end\n            \n            GOT_A: begin\n                if (b)\n                    next_state = GOT_AB;\n                else\n                    next_state = GOT_A;\n            end\n            \n            GOT_B: begin\n                if (a)\n                    next_state = GOT_AB;\n                else\n                    next_state = GOT_B;\n            end\n            \n            GOT_AB: begin\n                next_state = IDLE;\n            end\n            \n            default: next_state = IDLE;\n        endcase\n    end\n\n    // Output logic\n    always @(*) begin\n        case (current_state)\n            GOT_AB: o = 1'b1;\n            default: o = 1'b0;\n        endcase\n    end\n\nendmodule\n```\n\nThis FSM implements the ABRO sequence where:\n- The FSM waits for inputs A and B to occur (in any order)\n- Once both A and B have been detected, output O is asserted\n- The FSM then returns to the initial state\n- Reset signal brings the FSM back to IDLE state\n\nThe states are:\n- IDLE: Initial state, waiting for A or B\n- GOT_A: A has been detected, waiting for B\n- GOT_B: B has been detected, waiting for A\n- GOT_AB: Both A and B detected, output O is high",
            "Here's a synthesizable Verilog implementation of an ABRO (A-B-Reset-Output) sequence detector FSM:\n\n```verilog\nmodule abro_fsm (\n    input  wire clk,\n    input  wire rst,\n    input  wire a,\n    input  wire b,\n    output reg  o\n);\n\n    // State encoding\n    localparam IDLE   = 2'b00;\n    localparam GOT_A  = 2'b01;\n    localparam GOT_B  = 2'b10;\n    localparam GOT_AB = 2'b11;\n\n    // State register\n    reg [1:0] current_state, next_state;\n\n    // State register update\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            current_state <= IDLE;\n        else\n            current_state <= next_state;\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (current_state)\n            IDLE: begin\n                if (a && !b)\n                    next_state = GOT_A;\n                else if (!a && b)\n                    next_state = GOT_B;\n                else if (a && b)\n                    next_state = GOT_AB;\n                else\n                    next_state = IDLE;\n            end\n            \n            GOT_A: begin\n                if (b)\n                    next_state = GOT_AB;\n                else\n                    next_state = GOT_A;\n            end\n            \n            GOT_B: begin\n                if (a)\n                    next_state = GOT_AB;\n                else\n                    next_state = GOT_B;\n            end\n            \n            GOT_AB: begin\n                next_state = IDLE;\n            end\n            \n            default: next_state = IDLE;\n        endcase\n    end\n\n    // Output logic\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            o <= 1'b0;\n        else if (current_state == GOT_AB)\n            o <= 1'b1;\n        else\n            o <= 1'b0;\n    end\n\nendmodule\n```\n\nThis FSM implements the ABRO sequence where:\n- The FSM waits for inputs A and B to occur (in any order)\n- Once both A and B have been received, output O is asserted\n- The FSM then returns to the initial state\n- Reset brings the FSM back to the initial state at any time\n\nThe states are:\n- IDLE: Initial state, waiting for A or B\n- GOT_A: Received A, waiting for B\n- GOT_B: Received B, waiting for A  \n- GOT_AB: Received both A and B, assert output"
        ],
        "config": {
            "model": "claude-opus-4-20250514",
            "system_instruction": "You are a Verilog code generator. Output only synthesizable Verilog code.",
            "temperature": 0.2,
            "max_tokens": 1024,
            "samples": 10
        }
    }
]