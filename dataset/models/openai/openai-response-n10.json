[
    {
        "question": "Verilog declaration with one wire.",
        "outputs": [
            "wire my_wire;",
            "wire my_wire;",
            "wire my_wire;",
            "wire my_wire;",
            "wire my_wire;",
            "wire my_wire;",
            "wire my_wire;",
            "wire my_wire;",
            "wire my_wire;",
            "wire my_wire;"
        ],
        "config": {
            "model": "gpt-4.1",
            "system_instruction": "You are a Verilog code generator. Output only synthesizable Verilog code.",
            "temperature": 0.2,
            "max_tokens": 1024,
            "samples": 10
        }
    },
    {
        "question": "Set a wire to logic high using assign in Verilog",
        "outputs": [
            "```verilog\nwire my_wire;\nassign my_wire = 1'b1;\n```",
            "```verilog\nwire my_wire;\nassign my_wire = 1'b1;\n```",
            "```verilog\nwire my_wire;\nassign my_wire = 1'b1;\n```",
            "```verilog\nwire my_wire;\nassign my_wire = 1'b1;\n```",
            "```verilog\nwire my_wire;\nassign my_wire = 1'b1;\n```",
            "```verilog\nwire my_wire;\nassign my_wire = 1'b1;\n```",
            "```verilog\nwire my_wire;\nassign my_wire = 1'b1;\n```",
            "```verilog\nwire my_wire;\nassign my_wire = 1'b1;\n```",
            "```verilog\nwire my_wire;\nassign my_wire = 1'b1;\n```",
            "```verilog\nwire my_wire;\nassign my_wire = 1'b1;\n```"
        ],
        "config": {
            "model": "gpt-4.1",
            "system_instruction": "You are a Verilog code generator. Output only synthesizable Verilog code.",
            "temperature": 0.2,
            "max_tokens": 1024,
            "samples": 10
        }
    },
    {
        "question": "A 2 input AND gate in Verilog",
        "outputs": [
            "```verilog\nmodule and_gate (\n    input  wire a,\n    input  wire b,\n    output wire y\n);\n\nassign y = a & b;\n\nendmodule\n```",
            "```verilog\nmodule and_gate (\n    input  wire a,\n    input  wire b,\n    output wire y\n);\n\nassign y = a & b;\n\nendmodule\n```",
            "```verilog\nmodule and_gate (\n    input  wire a,\n    input  wire b,\n    output wire y\n);\n\nassign y = a & b;\n\nendmodule\n```",
            "```verilog\nmodule and_gate (\n    input  wire a,\n    input  wire b,\n    output wire y\n);\n\nassign y = a & b;\n\nendmodule\n```",
            "```verilog\nmodule and_gate (\n    input  wire a,\n    input  wire b,\n    output wire y\n);\n    assign y = a & b;\nendmodule\n```",
            "```verilog\nmodule and_gate (\n    input  wire a,\n    input  wire b,\n    output wire y\n);\n    assign y = a & b;\nendmodule\n```",
            "```verilog\nmodule and_gate (\n    input  wire a,\n    input  wire b,\n    output wire y\n);\n\nassign y = a & b;\n\nendmodule\n```",
            "```verilog\nmodule and_gate (\n    input  wire a,\n    input  wire b,\n    output wire y\n);\n\nassign y = a & b;\n\nendmodule\n```",
            "```verilog\nmodule and_gate (\n    input  wire a,\n    input  wire b,\n    output wire y\n);\n    assign y = a & b;\nendmodule\n```",
            "```verilog\nmodule and_gate (\n    input  wire a,\n    input  wire b,\n    output wire y\n);\n\nassign y = a & b;\n\nendmodule\n```"
        ],
        "config": {
            "model": "gpt-4.1",
            "system_instruction": "You are a Verilog code generator. Output only synthesizable Verilog code.",
            "temperature": 0.2,
            "max_tokens": 1024,
            "samples": 10
        }
    },
    {
        "question": "Three bit priority encoder in Verilog",
        "outputs": [
            "```verilog\nmodule priority_encoder_3bit (\n    input  wire [2:0] in,\n    output reg  [1:0] out,\n    output reg        valid\n);\n\nalways @(*) begin\n    casez (in)\n        3'b1??: begin out = 2'b10; valid = 1'b1; end // in[2] is high\n        3'b01?: begin out = 2'b01; valid = 1'b1; end // in[1] is high\n        3'b001: begin out = 2'b00; valid = 1'b1; end // in[0] is high\n        default: begin out = 2'b00; valid = 1'b0; end // no input is high\n    endcase\nend\n\nendmodule\n```",
            "```verilog\nmodule priority_encoder_3bit (\n    input  wire [2:0] in,\n    output reg  [1:0] out,\n    output reg        valid\n);\n\nalways @(*) begin\n    casex (in)\n        3'b1xx: begin out = 2'b10; valid = 1'b1; end // in[2] is high\n        3'b01x: begin out = 2'b01; valid = 1'b1; end // in[1] is high\n        3'b001: begin out = 2'b00; valid = 1'b1; end // in[0] is high\n        default: begin out = 2'b00; valid = 1'b0; end // no input is high\n    endcase\nend\n\nendmodule\n```",
            "```verilog\nmodule priority_encoder_3bit (\n    input  wire [2:0] in,\n    output reg  [1:0] out,\n    output reg        valid\n);\n\nalways @(*) begin\n    casez (in)\n        3'b1??: begin out = 2'b10; valid = 1'b1; end // in[2] is high\n        3'b01?: begin out = 2'b01; valid = 1'b1; end // in[1] is high\n        3'b001: begin out = 2'b00; valid = 1'b1; end // in[0] is high\n        default: begin out = 2'b00; valid = 1'b0; end // no input is high\n    endcase\nend\n\nendmodule\n```",
            "```verilog\nmodule priority_encoder_3bit (\n    input  wire [2:0] in,\n    output reg  [1:0] out,\n    output reg        valid\n);\n\nalways @(*) begin\n    casez (in)\n        3'b1??: begin out = 2'b10; valid = 1'b1; end // in[2] is high\n        3'b01?: begin out = 2'b01; valid = 1'b1; end // in[1] is high\n        3'b001: begin out = 2'b00; valid = 1'b1; end // in[0] is high\n        default: begin out = 2'b00; valid = 1'b0; end // no input is high\n    endcase\nend\n\nendmodule\n```",
            "```verilog\nmodule priority_encoder_3bit (\n    input  wire [2:0] in,\n    output reg  [1:0] out,\n    output reg        valid\n);\n\nalways @(*) begin\n    casez (in)\n        3'b1??: begin out = 2'b10; valid = 1'b1; end // in[2] is high\n        3'b01?: begin out = 2'b01; valid = 1'b1; end // in[1] is high\n        3'b001: begin out = 2'b00; valid = 1'b1; end // in[0] is high\n        default: begin out = 2'b00; valid = 1'b0; end // no input is high\n    endcase\nend\n\nendmodule\n```",
            "```verilog\nmodule priority_encoder_3bit (\n    input  wire [2:0] in,\n    output reg  [1:0] out,\n    output reg        valid\n);\n\nalways @(*) begin\n    casex (in)\n        3'b1xx: begin out = 2'b10; valid = 1'b1; end // in[2] is high\n        3'b01x: begin out = 2'b01; valid = 1'b1; end // in[1] is high\n        3'b001: begin out = 2'b00; valid = 1'b1; end // in[0] is high\n        default: begin out = 2'b00; valid = 1'b0; end // no input is high\n    endcase\nend\n\nendmodule\n```",
            "```verilog\nmodule priority_encoder_3bit (\n    input  wire [2:0] in,\n    output reg  [1:0] out,\n    output reg        valid\n);\n\nalways @(*) begin\n    casez (in)\n        3'b1??: begin out = 2'b10; valid = 1'b1; end // in[2] is high\n        3'b01?: begin out = 2'b01; valid = 1'b1; end // in[1] is high\n        3'b001: begin out = 2'b00; valid = 1'b1; end // in[0] is high\n        default: begin out = 2'b00; valid = 1'b0; end // no input is high\n    endcase\nend\n\nendmodule\n```",
            "```verilog\nmodule priority_encoder_3bit (\n    input  wire [2:0] in,\n    output reg  [1:0] out,\n    output reg        valid\n);\n\nalways @(*) begin\n    casez (in)\n        3'b1??: begin\n            out   = 2'b10;\n            valid = 1'b1;\n        end\n        3'b01?: begin\n            out   = 2'b01;\n            valid = 1'b1;\n        end\n        3'b001: begin\n            out   = 2'b00;\n            valid = 1'b1;\n        end\n        default: begin\n            out   = 2'b00;\n            valid = 1'b0;\n        end\n    endcase\nend\n\nendmodule\n```",
            "```verilog\nmodule priority_encoder_3bit (\n    input  wire [2:0] in,\n    output reg  [1:0] out,\n    output reg        valid\n);\n\nalways @(*) begin\n    casex (in)\n        3'b1xx: begin out = 2'b10; valid = 1'b1; end // in[2] is high\n        3'b01x: begin out = 2'b01; valid = 1'b1; end // in[1] is high\n        3'b001: begin out = 2'b00; valid = 1'b1; end // in[0] is high\n        default: begin out = 2'b00; valid = 1'b0; end // no input is high\n    endcase\nend\n\nendmodule\n```",
            "```verilog\nmodule priority_encoder_3bit (\n    input  wire [2:0] in,\n    output reg  [1:0] out,\n    output reg        valid\n);\n\nalways @(*) begin\n    casez (in)\n        3'b1??: begin out = 2'b10; valid = 1'b1; end // in[2] is high\n        3'b01?: begin out = 2'b01; valid = 1'b1; end // in[1] is high\n        3'b001: begin out = 2'b00; valid = 1'b1; end // in[0] is high\n        default: begin out = 2'b00; valid = 1'b0; end // no input is high\n    endcase\nend\n\nendmodule\n```"
        ],
        "config": {
            "model": "gpt-4.1",
            "system_instruction": "You are a Verilog code generator. Output only synthesizable Verilog code.",
            "temperature": 0.2,
            "max_tokens": 1024,
            "samples": 10
        }
    },
    {
        "question": "Simple Verilog example of a two-input multiplexer",
        "outputs": [
            "```verilog\nmodule mux2to1 (\n    input  wire a,\n    input  wire b,\n    input  wire sel,\n    output wire y\n);\n\nassign y = sel ? b : a;\n\nendmodule\n```",
            "```verilog\nmodule mux2to1 (\n    input  wire a,\n    input  wire b,\n    input  wire sel,\n    output wire y\n);\n\nassign y = sel ? b : a;\n\nendmodule\n```",
            "```verilog\nmodule mux2to1 (\n    input  wire a,\n    input  wire b,\n    input  wire sel,\n    output wire y\n);\n\nassign y = sel ? b : a;\n\nendmodule\n```",
            "```verilog\nmodule mux2to1 (\n    input  wire a,\n    input  wire b,\n    input  wire sel,\n    output wire y\n);\n\nassign y = sel ? b : a;\n\nendmodule\n```",
            "```verilog\nmodule mux2to1 (\n    input  wire a,\n    input  wire b,\n    input  wire sel,\n    output wire y\n);\n\nassign y = sel ? b : a;\n\nendmodule\n```",
            "```verilog\nmodule mux2to1 (\n    input  wire a,\n    input  wire b,\n    input  wire sel,\n    output wire y\n);\n\nassign y = sel ? b : a;\n\nendmodule\n```",
            "```verilog\nmodule mux2to1 (\n    input  wire a,\n    input  wire b,\n    input  wire sel,\n    output wire y\n);\n\nassign y = sel ? b : a;\n\nendmodule\n```",
            "```verilog\nmodule mux2to1 (\n    input  wire a,\n    input  wire b,\n    input  wire sel,\n    output wire y\n);\n\nassign y = sel ? b : a;\n\nendmodule\n```",
            "```verilog\nmodule mux2to1 (\n    input  wire a,\n    input  wire b,\n    input  wire sel,\n    output wire y\n);\n\nassign y = sel ? b : a;\n\nendmodule\n```",
            "```verilog\nmodule mux2to1 (\n    input  wire a,\n    input  wire b,\n    input  wire sel,\n    output wire y\n);\n\nassign y = sel ? b : a;\n\nendmodule\n```"
        ],
        "config": {
            "model": "gpt-4.1",
            "system_instruction": "You are a Verilog code generator. Output only synthesizable Verilog code.",
            "temperature": 0.2,
            "max_tokens": 1024,
            "samples": 10
        }
    },
    {
        "question": "Write Verilog code for a half adder",
        "outputs": [
            "```verilog\nmodule half_adder (\n    input  wire a,\n    input  wire b,\n    output wire sum,\n    output wire carry\n);\n\nassign sum   = a ^ b;\nassign carry = a & b;\n\nendmodule\n```",
            "```verilog\nmodule half_adder (\n    input  wire a,\n    input  wire b,\n    output wire sum,\n    output wire carry\n);\n\nassign sum   = a ^ b;\nassign carry = a & b;\n\nendmodule\n```",
            "```verilog\nmodule half_adder (\n    input  wire a,\n    input  wire b,\n    output wire sum,\n    output wire carry\n);\n\nassign sum   = a ^ b;\nassign carry = a & b;\n\nendmodule\n```",
            "```verilog\nmodule half_adder (\n    input  wire a,\n    input  wire b,\n    output wire sum,\n    output wire carry\n);\n\nassign sum   = a ^ b;\nassign carry = a & b;\n\nendmodule\n```",
            "```verilog\nmodule half_adder (\n    input  wire a,\n    input  wire b,\n    output wire sum,\n    output wire carry\n);\n\nassign sum   = a ^ b;\nassign carry = a & b;\n\nendmodule\n```",
            "```verilog\nmodule half_adder (\n    input  wire a,\n    input  wire b,\n    output wire sum,\n    output wire carry\n);\n\nassign sum   = a ^ b;\nassign carry = a & b;\n\nendmodule\n```",
            "```verilog\nmodule half_adder (\n    input  wire a,\n    input  wire b,\n    output wire sum,\n    output wire carry\n);\n\nassign sum   = a ^ b;\nassign carry = a & b;\n\nendmodule\n```",
            "```verilog\nmodule half_adder (\n    input  wire a,\n    input  wire b,\n    output wire sum,\n    output wire carry\n);\n\nassign sum   = a ^ b;\nassign carry = a & b;\n\nendmodule\n```",
            "```verilog\nmodule half_adder (\n    input  wire a,\n    input  wire b,\n    output wire sum,\n    output wire carry\n);\n\nassign sum   = a ^ b;\nassign carry = a & b;\n\nendmodule\n```",
            "```verilog\nmodule half_adder (\n    input  wire a,\n    input  wire b,\n    output wire sum,\n    output wire carry\n);\n\nassign sum   = a ^ b;\nassign carry = a & b;\n\nendmodule\n```"
        ],
        "config": {
            "model": "gpt-4.1",
            "system_instruction": "You are a Verilog code generator. Output only synthesizable Verilog code.",
            "temperature": 0.2,
            "max_tokens": 1024,
            "samples": 10
        }
    },
    {
        "question": "1 to 12 counter in Verilog",
        "outputs": [
            "```verilog\nmodule counter_1_to_12 (\n    input wire clk,\n    input wire rst_n,      // Active low reset\n    output reg [3:0] count // 4 bits to represent 1 to 12\n);\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        count <= 4'd1;\n    else if (count == 4'd12)\n        count <= 4'd1;\n    else\n        count <= count + 4'd1;\nend\n\nendmodule\n```",
            "```verilog\nmodule counter_1_to_12 (\n    input wire clk,\n    input wire rst_n,      // Active low reset\n    output reg [3:0] count // 4 bits to represent 1 to 12\n);\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        count <= 4'd1;\n    else if (count == 4'd12)\n        count <= 4'd1;\n    else\n        count <= count + 4'd1;\nend\n\nendmodule\n```",
            "```verilog\nmodule counter_1_to_12 (\n    input wire clk,\n    input wire rst_n,      // Active-low synchronous reset\n    output reg [3:0] count // 4 bits to represent 1 to 12\n);\n\nalways @(posedge clk) begin\n    if (!rst_n)\n        count <= 4'd1;\n    else if (count == 4'd12)\n        count <= 4'd1;\n    else\n        count <= count + 4'd1;\nend\n\nendmodule\n```",
            "```verilog\nmodule counter_1_to_12 (\n    input wire clk,\n    input wire rst_n,      // Active low reset\n    output reg [3:0] count\n);\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        count <= 4'd1;\n    else if (count == 4'd12)\n        count <= 4'd1;\n    else\n        count <= count + 4'd1;\nend\n\nendmodule\n```",
            "```verilog\nmodule counter_1_to_12 (\n    input wire clk,\n    input wire rst_n,      // Active low reset\n    output reg [3:0] count // 4 bits to represent 1 to 12\n);\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        count <= 4'd1;\n    else if (count == 4'd12)\n        count <= 4'd1;\n    else\n        count <= count + 4'd1;\nend\n\nendmodule\n```",
            "```verilog\nmodule counter_1_to_12 (\n    input wire clk,\n    input wire rst_n,      // Active low reset\n    output reg [3:0] count // 4 bits to represent 1 to 12\n);\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        count <= 4'd1;\n    else if (count == 4'd12)\n        count <= 4'd1;\n    else\n        count <= count + 4'd1;\nend\n\nendmodule\n```",
            "```verilog\nmodule counter_1_to_12 (\n    input wire clk,\n    input wire reset,\n    output reg [3:0] count\n);\n\nalways @(posedge clk or posedge reset) begin\n    if (reset)\n        count <= 4'd1;\n    else if (count == 4'd12)\n        count <= 4'd1;\n    else\n        count <= count + 4'd1;\nend\n\nendmodule\n```",
            "```verilog\nmodule counter_1_to_12 (\n    input wire clk,\n    input wire rst_n,      // Active low reset\n    output reg [3:0] count // 4 bits to represent 1 to 12\n);\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        count <= 4'd1;\n    else if (count == 4'd12)\n        count <= 4'd1;\n    else\n        count <= count + 1'b1;\nend\n\nendmodule\n```",
            "```verilog\nmodule counter_1_to_12 (\n    input wire clk,\n    input wire rst_n,     // Active low reset\n    output reg [3:0] count\n);\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        count <= 4'd1;\n    else if (count == 4'd12)\n        count <= 4'd1;\n    else\n        count <= count + 4'd1;\nend\n\nendmodule\n```",
            "```verilog\nmodule counter_1_to_12 (\n    input wire clk,\n    input wire rst_n,      // Active low synchronous reset\n    output reg [3:0] count // 4 bits to represent 1 to 12\n);\n\nalways @(posedge clk) begin\n    if (!rst_n)\n        count <= 4'd1;\n    else if (count == 4'd12)\n        count <= 4'd1;\n    else\n        count <= count + 4'd1;\nend\n\nendmodule\n```"
        ],
        "config": {
            "model": "gpt-4.1",
            "system_instruction": "You are a Verilog code generator. Output only synthesizable Verilog code.",
            "temperature": 0.2,
            "max_tokens": 1024,
            "samples": 10
        }
    },
    {
        "question": "Implement a pseudo-random LFSR in Verilog with taps on bit 3 and bit 5",
        "outputs": [
            "```verilog\nmodule lfsr_5bit (\n    input wire clk,\n    input wire rst,\n    output reg [4:0] lfsr_out\n);\n\nwire feedback;\n\n// Taps on bit 3 and bit 5 (bit indices 2 and 4)\nassign feedback = lfsr_out[4] ^ lfsr_out[2];\n\nalways @(posedge clk or posedge rst) begin\n    if (rst)\n        lfsr_out <= 5'b00001; // Non-zero seed\n    else\n        lfsr_out <= {lfsr_out[3:0], feedback};\nend\n\nendmodule\n```",
            "```verilog\nmodule lfsr_5bit (\n    input wire clk,\n    input wire rst,\n    output reg [4:0] lfsr_out\n);\n\nwire feedback;\n\n// Taps on bit 3 and bit 5 (bit positions 2 and 4, zero-based)\nassign feedback = lfsr_out[4] ^ lfsr_out[2];\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        lfsr_out <= 5'b00001; // Seed value, must not be zero\n    end else begin\n        lfsr_out <= {lfsr_out[3:0], feedback};\n    end\nend\n\nendmodule\n```",
            "```verilog\nmodule lfsr_5bit (\n    input  wire clk,\n    input  wire rst_n,\n    output reg  [4:0] lfsr_out\n);\n\nwire feedback;\n\n// Taps on bit 3 and bit 5 (bit indices 2 and 4)\nassign feedback = lfsr_out[4] ^ lfsr_out[2];\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        lfsr_out <= 5'b00001; // Non-zero seed\n    else\n        lfsr_out <= {lfsr_out[3:0], feedback};\nend\n\nendmodule\n```",
            "```verilog\nmodule lfsr_5bit (\n    input  wire       clk,\n    input  wire       rst_n,\n    output reg [4:0]  lfsr_out\n);\n\nwire feedback;\n\n// Feedback is XOR of bit 3 and bit 5 (index 2 and 4)\nassign feedback = lfsr_out[4] ^ lfsr_out[2];\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        lfsr_out <= 5'b00001; // Non-zero seed\n    else\n        lfsr_out <= {lfsr_out[3:0], feedback};\nend\n\nendmodule\n```",
            "```verilog\nmodule lfsr_5bit (\n    input  wire       clk,\n    input  wire       rst_n,\n    output reg [4:0]  lfsr_out\n);\n\nwire feedback;\n\n// Feedback is XOR of bit 3 and bit 5 (index 2 and 4)\nassign feedback = lfsr_out[4] ^ lfsr_out[2];\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        lfsr_out <= 5'b00001; // Non-zero seed\n    else\n        lfsr_out <= {lfsr_out[3:0], feedback};\nend\n\nendmodule\n```",
            "```verilog\nmodule lfsr_5bit (\n    input  wire clk,\n    input  wire rst_n,\n    output reg  [4:0] lfsr_out\n);\n\nwire feedback;\n\n// Taps on bit 3 and bit 5 (bit indices 2 and 4, since Verilog is 0-based)\nassign feedback = lfsr_out[4] ^ lfsr_out[2];\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        lfsr_out <= 5'b00001; // Non-zero seed\n    else\n        lfsr_out <= {lfsr_out[3:0], feedback};\nend\n\nendmodule\n```",
            "```verilog\nmodule lfsr_5bit (\n    input  wire       clk,\n    input  wire       rst_n,\n    output reg [4:0]  lfsr_out\n);\n\nwire feedback;\n\n// Feedback is XOR of bit 3 and bit 5 (bit indices 2 and 4)\nassign feedback = lfsr_out[4] ^ lfsr_out[2];\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        lfsr_out <= 5'b00001; // Non-zero seed\n    else\n        lfsr_out <= {lfsr_out[3:0], feedback};\nend\n\nendmodule\n```",
            "```verilog\nmodule lfsr_5bit (\n    input wire clk,\n    input wire rst,\n    output reg [4:0] lfsr_out\n);\n\nwire feedback;\n\n// Taps on bit 3 and bit 5 (bit indices 2 and 4)\nassign feedback = lfsr_out[4] ^ lfsr_out[2];\n\nalways @(posedge clk or posedge rst) begin\n    if (rst)\n        lfsr_out <= 5'b00001; // Non-zero seed\n    else\n        lfsr_out <= {lfsr_out[3:0], feedback};\nend\n\nendmodule\n```",
            "```verilog\nmodule lfsr_5bit (\n    input  wire clk,\n    input  wire rst_n,\n    output reg  [4:0] lfsr_out\n);\n\nwire feedback;\n\n// Taps on bit 3 and bit 5 (bit indices 2 and 4)\nassign feedback = lfsr_out[4] ^ lfsr_out[2];\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        lfsr_out <= 5'b00001; // Non-zero seed\n    else\n        lfsr_out <= {lfsr_out[3:0], feedback};\nend\n\nendmodule\n```",
            "```verilog\nmodule lfsr_5bit (\n    input wire clk,\n    input wire rst_n,\n    output reg [4:0] lfsr_out\n);\n\nwire feedback;\n\n// Taps on bit 3 and bit 5 (bit indices 2 and 4)\nassign feedback = lfsr_out[4] ^ lfsr_out[2];\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        lfsr_out <= 5'b00001; // Non-zero seed\n    else\n        lfsr_out <= {lfsr_out[3:0], feedback};\nend\n\nendmodule\n```"
        ],
        "config": {
            "model": "gpt-4.1",
            "system_instruction": "You are a Verilog code generator. Output only synthesizable Verilog code.",
            "temperature": 0.2,
            "max_tokens": 1024,
            "samples": 10
        }
    },
    {
        "question": "FSM with two states in Verilog",
        "outputs": [
            "```verilog\nmodule fsm_two_states (\n    input wire clk,\n    input wire rst_n,\n    input wire in,\n    output reg out\n);\n\n    typedef enum logic [0:0] {\n        S0 = 1'b0,\n        S1 = 1'b1\n    } state_t;\n\n    state_t state, next_state;\n\n    // State register\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            state <= S0;\n        else\n            state <= next_state;\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            S0: begin\n                if (in)\n                    next_state = S1;\n                else\n                    next_state = S0;\n            end\n            S1: begin\n                if (in)\n                    next_state = S0;\n                else\n                    next_state = S1;\n            end\n            default: next_state = S0;\n        endcase\n    end\n\n    // Output logic\n    always @(*) begin\n        case (state)\n            S0: out = 1'b0;\n            S1: out = 1'b1;\n            default: out = 1'b0;\n        endcase\n    end\n\nendmodule\n```",
            "```verilog\nmodule fsm_two_states (\n    input  wire clk,\n    input  wire rst_n,\n    input  wire in,\n    output reg  out\n);\n\n    typedef enum logic [0:0] {\n        S0 = 1'b0,\n        S1 = 1'b1\n    } state_t;\n\n    state_t state, next_state;\n\n    // State register\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            state <= S0;\n        else\n            state <= next_state;\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            S0: next_state = in ? S1 : S0;\n            S1: next_state = in ? S0 : S1;\n            default: next_state = S0;\n        endcase\n    end\n\n    // Output logic\n    always @(*) begin\n        case (state)\n            S0: out = 1'b0;\n            S1: out = 1'b1;\n            default: out = 1'b0;\n        endcase\n    end\n\nendmodule\n```",
            "```verilog\nmodule two_state_fsm (\n    input  wire clk,\n    input  wire rst_n,\n    input  wire in,\n    output reg  out\n);\n\n    typedef enum logic [0:0] {\n        STATE_0 = 1'b0,\n        STATE_1 = 1'b1\n    } state_t;\n\n    state_t state, next_state;\n\n    // State register\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            state <= STATE_0;\n        else\n            state <= next_state;\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            STATE_0: next_state = in ? STATE_1 : STATE_0;\n            STATE_1: next_state = in ? STATE_0 : STATE_1;\n            default: next_state = STATE_0;\n        endcase\n    end\n\n    // Output logic\n    always @(*) begin\n        case (state)\n            STATE_0: out = 1'b0;\n            STATE_1: out = 1'b1;\n            default: out = 1'b0;\n        endcase\n    end\n\nendmodule\n```",
            "```verilog\nmodule fsm_two_states (\n    input  wire clk,\n    input  wire rst_n,\n    input  wire in,\n    output reg  out\n);\n\n    typedef enum logic [0:0] {\n        S0 = 1'b0,\n        S1 = 1'b1\n    } state_t;\n\n    state_t state, next_state;\n\n    // State register\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            state <= S0;\n        else\n            state <= next_state;\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            S0: next_state = in ? S1 : S0;\n            S1: next_state = in ? S1 : S0;\n            default: next_state = S0;\n        endcase\n    end\n\n    // Output logic\n    always @(*) begin\n        case (state)\n            S0: out = 1'b0;\n            S1: out = 1'b1;\n            default: out = 1'b0;\n        endcase\n    end\n\nendmodule\n```",
            "```verilog\nmodule fsm_two_states (\n    input  wire clk,\n    input  wire rst_n,\n    input  wire in,\n    output reg  out\n);\n\n    typedef enum logic [0:0] {\n        S0 = 1'b0,\n        S1 = 1'b1\n    } state_t;\n\n    state_t state, next_state;\n\n    // State register\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            state <= S0;\n        else\n            state <= next_state;\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            S0: next_state = in ? S1 : S0;\n            S1: next_state = in ? S0 : S1;\n            default: next_state = S0;\n        endcase\n    end\n\n    // Output logic\n    always @(*) begin\n        case (state)\n            S0: out = 1'b0;\n            S1: out = 1'b1;\n            default: out = 1'b0;\n        endcase\n    end\n\nendmodule\n```",
            "```verilog\nmodule fsm_two_states (\n    input  wire clk,\n    input  wire rst_n,\n    input  wire in,\n    output reg  out\n);\n\n    typedef enum logic [0:0] {\n        S0 = 1'b0,\n        S1 = 1'b1\n    } state_t;\n\n    state_t state, next_state;\n\n    // State register\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            state <= S0;\n        else\n            state <= next_state;\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            S0: next_state = in ? S1 : S0;\n            S1: next_state = in ? S0 : S1;\n            default: next_state = S0;\n        endcase\n    end\n\n    // Output logic\n    always @(*) begin\n        case (state)\n            S0: out = 1'b0;\n            S1: out = 1'b1;\n            default: out = 1'b0;\n        endcase\n    end\n\nendmodule\n```",
            "```verilog\nmodule fsm_two_states (\n    input  wire clk,\n    input  wire rst_n,\n    input  wire in,\n    output reg  out\n);\n\n    typedef enum logic [0:0] {\n        S0 = 1'b0,\n        S1 = 1'b1\n    } state_t;\n\n    state_t state, next_state;\n\n    // State register\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            state <= S0;\n        else\n            state <= next_state;\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            S0: next_state = in ? S1 : S0;\n            S1: next_state = in ? S0 : S1;\n            default: next_state = S0;\n        endcase\n    end\n\n    // Output logic\n    always @(*) begin\n        case (state)\n            S0: out = 1'b0;\n            S1: out = 1'b1;\n            default: out = 1'b0;\n        endcase\n    end\n\nendmodule\n```",
            "```verilog\nmodule fsm_two_states (\n    input  wire clk,\n    input  wire rst_n,\n    input  wire in,\n    output reg  out\n);\n\n    typedef enum logic [0:0] {\n        S0 = 1'b0,\n        S1 = 1'b1\n    } state_t;\n\n    state_t state, next_state;\n\n    // State register\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            state <= S0;\n        else\n            state <= next_state;\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            S0: next_state = in ? S1 : S0;\n            S1: next_state = in ? S1 : S0;\n            default: next_state = S0;\n        endcase\n    end\n\n    // Output logic\n    always @(*) begin\n        case (state)\n            S0: out = 1'b0;\n            S1: out = 1'b1;\n            default: out = 1'b0;\n        endcase\n    end\n\nendmodule\n```",
            "```verilog\nmodule fsm_two_states (\n    input  wire clk,\n    input  wire rst_n,\n    input  wire in,\n    output reg  out\n);\n\n    typedef enum logic [0:0] {\n        S0 = 1'b0,\n        S1 = 1'b1\n    } state_t;\n\n    state_t state, next_state;\n\n    // State register\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            state <= S0;\n        else\n            state <= next_state;\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            S0: next_state = in ? S1 : S0;\n            S1: next_state = in ? S1 : S0;\n            default: next_state = S0;\n        endcase\n    end\n\n    // Output logic\n    always @(*) begin\n        case (state)\n            S0: out = 1'b0;\n            S1: out = 1'b1;\n            default: out = 1'b0;\n        endcase\n    end\n\nendmodule\n```",
            "```verilog\nmodule fsm_two_states (\n    input  wire clk,\n    input  wire rst_n,\n    input  wire in,\n    output reg  out\n);\n\n    typedef enum logic [0:0] {\n        S0 = 1'b0,\n        S1 = 1'b1\n    } state_t;\n\n    state_t state, next_state;\n\n    // State register\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            state <= S0;\n        else\n            state <= next_state;\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            S0: next_state = in ? S1 : S0;\n            S1: next_state = in ? S0 : S1;\n            default: next_state = S0;\n        endcase\n    end\n\n    // Output logic\n    always @(*) begin\n        case (state)\n            S0: out = 1'b0;\n            S1: out = 1'b1;\n            default: out = 1'b0;\n        endcase\n    end\n\nendmodule\n```"
        ],
        "config": {
            "model": "gpt-4.1",
            "system_instruction": "You are a Verilog code generator. Output only synthesizable Verilog code.",
            "temperature": 0.2,
            "max_tokens": 1024,
            "samples": 10
        }
    },
    {
        "question": "Implement left shift and left rotate using Verilog",
        "outputs": [
            "```verilog\nmodule left_shift_rotate #(\n    parameter WIDTH = 8\n)(\n    input  wire [WIDTH-1:0] data_in,\n    input  wire [$clog2(WIDTH)-1:0] shift_amt,\n    input  wire shift_or_rotate, // 0: shift, 1: rotate\n    output reg  [WIDTH-1:0] data_out\n);\n\n    always @* begin\n        if (shift_or_rotate == 1'b0) begin\n            // Logical left shift\n            data_out = data_in << shift_amt;\n        end else begin\n            // Left rotate\n            data_out = (data_in << shift_amt) | (data_in >> (WIDTH - shift_amt));\n        end\n    end\n\nendmodule\n```",
            "```verilog\nmodule left_shift_rotate #(\n    parameter WIDTH = 8\n)(\n    input  wire [WIDTH-1:0] data_in,\n    input  wire [$clog2(WIDTH)-1:0] shift_amt,\n    input  wire shift_or_rotate, // 0: shift, 1: rotate\n    output reg  [WIDTH-1:0] data_out\n);\n\nalways @* begin\n    if (shift_or_rotate == 1'b0) begin\n        // Logical left shift\n        data_out = data_in << shift_amt;\n    end else begin\n        // Left rotate\n        data_out = (data_in << shift_amt) | (data_in >> (WIDTH - shift_amt));\n    end\nend\n\nendmodule\n```",
            "```verilog\nmodule left_shift_rotate #(\n    parameter WIDTH = 8\n)(\n    input  wire [WIDTH-1:0] data_in,\n    input  wire [$clog2(WIDTH)-1:0] shift_amt,\n    input  wire shift_or_rotate, // 0: shift, 1: rotate\n    output reg  [WIDTH-1:0] data_out\n);\n\n    always @* begin\n        if (shift_or_rotate == 1'b0) begin\n            // Logical left shift\n            data_out = data_in << shift_amt;\n        end else begin\n            // Left rotate\n            data_out = (data_in << shift_amt) | (data_in >> (WIDTH - shift_amt));\n        end\n    end\n\nendmodule\n```",
            "```verilog\nmodule shift_rotate_left #(\n    parameter WIDTH = 8\n)(\n    input  wire [WIDTH-1:0] data_in,\n    input  wire [$clog2(WIDTH)-1:0] shift_amt,\n    input  wire shift_or_rotate, // 0: shift, 1: rotate\n    output reg  [WIDTH-1:0] data_out\n);\n\n    always @* begin\n        if (shift_or_rotate == 1'b0) begin\n            // Logical left shift\n            data_out = data_in << shift_amt;\n        end else begin\n            // Left rotate\n            data_out = (data_in << shift_amt) | (data_in >> (WIDTH - shift_amt));\n        end\n    end\n\nendmodule\n```",
            "```verilog\nmodule left_shift_rotate #(\n    parameter WIDTH = 8\n)(\n    input  wire [WIDTH-1:0] data_in,\n    input  wire [$clog2(WIDTH)-1:0] shift_amt,\n    input  wire shift_rotate_sel, // 0: shift, 1: rotate\n    output reg  [WIDTH-1:0] data_out\n);\n\n    always @* begin\n        if (shift_rotate_sel == 1'b0) begin\n            // Logical left shift\n            data_out = data_in << shift_amt;\n        end else begin\n            // Left rotate\n            data_out = (data_in << shift_amt) | (data_in >> (WIDTH - shift_amt));\n        end\n    end\n\nendmodule\n```",
            "```verilog\nmodule left_shift_rotate #(\n    parameter WIDTH = 8\n)(\n    input  wire [WIDTH-1:0] data_in,\n    input  wire [$clog2(WIDTH)-1:0] shift_amt,\n    input  wire shift_rotate_sel, // 0: shift, 1: rotate\n    output reg  [WIDTH-1:0] data_out\n);\n\n    always @* begin\n        if (shift_rotate_sel == 1'b0) begin\n            // Logical left shift\n            data_out = data_in << shift_amt;\n        end else begin\n            // Left rotate\n            data_out = (data_in << shift_amt) | (data_in >> (WIDTH - shift_amt));\n        end\n    end\n\nendmodule\n```",
            "```verilog\nmodule left_shift_rotate #(\n    parameter WIDTH = 8\n)(\n    input  wire [WIDTH-1:0] data_in,\n    input  wire [$clog2(WIDTH)-1:0] shift_amt,\n    input  wire shift_or_rotate, // 0: shift, 1: rotate\n    output reg  [WIDTH-1:0] data_out\n);\n\n    always @* begin\n        if (shift_or_rotate == 1'b0) begin\n            // Logical left shift\n            data_out = data_in << shift_amt;\n        end else begin\n            // Left rotate\n            data_out = (data_in << shift_amt) | (data_in >> (WIDTH - shift_amt));\n        end\n    end\n\nendmodule\n```",
            "```verilog\nmodule left_shift_rotate #(\n    parameter WIDTH = 8\n)(\n    input  wire [WIDTH-1:0] data_in,\n    input  wire [$clog2(WIDTH)-1:0] shift_amt,\n    input  wire shift_or_rotate, // 0: shift, 1: rotate\n    output reg  [WIDTH-1:0] data_out\n);\n\n    always @* begin\n        if (shift_or_rotate == 1'b0) begin\n            // Logical left shift\n            data_out = data_in << shift_amt;\n        end else begin\n            // Left rotate\n            data_out = (data_in << shift_amt) | (data_in >> (WIDTH - shift_amt));\n        end\n    end\n\nendmodule\n```",
            "```verilog\nmodule left_shift_rotate #(\n    parameter WIDTH = 8\n)(\n    input  wire [WIDTH-1:0] data_in,\n    input  wire [$clog2(WIDTH)-1:0] shift_amt,\n    input  wire shift_rotate_sel, // 0: shift, 1: rotate\n    output reg  [WIDTH-1:0] data_out\n);\n\n    always @* begin\n        if (shift_rotate_sel == 1'b0) begin\n            // Logical left shift\n            data_out = data_in << shift_amt;\n        end else begin\n            // Left rotate\n            data_out = (data_in << shift_amt) | (data_in >> (WIDTH - shift_amt));\n        end\n    end\n\nendmodule\n```",
            "```verilog\nmodule left_shift_rotate #(\n    parameter WIDTH = 8\n)(\n    input  wire [WIDTH-1:0] data_in,\n    input  wire [$clog2(WIDTH)-1:0] shift_amt,\n    input  wire shift_or_rotate, // 0: shift, 1: rotate\n    output reg  [WIDTH-1:0] data_out\n);\n\n    always @* begin\n        if (shift_or_rotate == 1'b0) begin\n            // Logical left shift\n            data_out = data_in << shift_amt;\n        end else begin\n            // Left rotate\n            data_out = (data_in << shift_amt) | (data_in >> (WIDTH - shift_amt));\n        end\n    end\n\nendmodule\n```"
        ],
        "config": {
            "model": "gpt-4.1",
            "system_instruction": "You are a Verilog code generator. Output only synthesizable Verilog code.",
            "temperature": 0.2,
            "max_tokens": 1024,
            "samples": 10
        }
    },
    {
        "question": "Verilog code for RAM with read and write control",
        "outputs": [
            "```verilog\nmodule simple_ram #(\n    parameter DATA_WIDTH = 8,\n    parameter ADDR_WIDTH = 8\n)(\n    input wire clk,\n    input wire rst,\n    input wire we,                  // Write enable\n    input wire re,                  // Read enable\n    input wire [ADDR_WIDTH-1:0] addr,\n    input wire [DATA_WIDTH-1:0] din,\n    output reg [DATA_WIDTH-1:0] dout\n);\n\n    // RAM memory declaration\n    reg [DATA_WIDTH-1:0] mem [0:(1<<ADDR_WIDTH)-1];\n\n    always @(posedge clk) begin\n        if (rst) begin\n            dout <= {DATA_WIDTH{1'b0}};\n        end else begin\n            if (we) begin\n                mem[addr] <= din;\n            end\n            if (re) begin\n                dout <= mem[addr];\n            end\n        end\n    end\n\nendmodule\n```",
            "```verilog\nmodule simple_ram #(\n    parameter DATA_WIDTH = 8,\n    parameter ADDR_WIDTH = 4\n)(\n    input wire clk,\n    input wire rst,\n    input wire we,                     // Write enable\n    input wire re,                     // Read enable\n    input wire [ADDR_WIDTH-1:0] addr,  // Address\n    input wire [DATA_WIDTH-1:0] din,   // Data input\n    output reg [DATA_WIDTH-1:0] dout   // Data output\n);\n\n    // Memory declaration\n    reg [DATA_WIDTH-1:0] mem [0:(1<<ADDR_WIDTH)-1];\n\n    always @(posedge clk) begin\n        if (rst) begin\n            dout <= {DATA_WIDTH{1'b0}};\n        end else begin\n            if (we) begin\n                mem[addr] <= din;\n            end\n            if (re) begin\n                dout <= mem[addr];\n            end\n        end\n    end\n\nendmodule\n```",
            "```verilog\nmodule simple_ram #(\n    parameter DATA_WIDTH = 8,\n    parameter ADDR_WIDTH = 4\n)(\n    input wire clk,\n    input wire we,                  // Write Enable\n    input wire re,                  // Read Enable\n    input wire [ADDR_WIDTH-1:0] addr,\n    input wire [DATA_WIDTH-1:0] din,\n    output reg [DATA_WIDTH-1:0] dout\n);\n\n    // Memory declaration\n    reg [DATA_WIDTH-1:0] mem [0:(1<<ADDR_WIDTH)-1];\n\n    always @(posedge clk) begin\n        if (we) begin\n            mem[addr] <= din;\n        end\n        if (re) begin\n            dout <= mem[addr];\n        end\n    end\n\nendmodule\n```",
            "```verilog\nmodule simple_ram #(\n    parameter DATA_WIDTH = 8,\n    parameter ADDR_WIDTH = 4\n)(\n    input wire clk,\n    input wire rst,\n    input wire we,                      // Write enable\n    input wire re,                      // Read enable\n    input wire [ADDR_WIDTH-1:0] addr,   // Address\n    input wire [DATA_WIDTH-1:0] din,    // Data input\n    output reg [DATA_WIDTH-1:0] dout    // Data output\n);\n\n    // RAM memory declaration\n    reg [DATA_WIDTH-1:0] mem [0:(1<<ADDR_WIDTH)-1];\n\n    always @(posedge clk) begin\n        if (rst) begin\n            dout <= {DATA_WIDTH{1'b0}};\n        end else begin\n            if (we) begin\n                mem[addr] <= din;\n            end\n            if (re) begin\n                dout <= mem[addr];\n            end\n        end\n    end\n\nendmodule\n```",
            "```verilog\nmodule simple_ram #(\n    parameter DATA_WIDTH = 8,\n    parameter ADDR_WIDTH = 4\n)(\n    input wire clk,\n    input wire rst,\n    input wire we,                       // Write enable\n    input wire [ADDR_WIDTH-1:0] addr,    // Address\n    input wire [DATA_WIDTH-1:0] din,     // Data input\n    output reg [DATA_WIDTH-1:0] dout     // Data output\n);\n\n    // RAM memory declaration\n    reg [DATA_WIDTH-1:0] mem [0:(1<<ADDR_WIDTH)-1];\n\n    always @(posedge clk) begin\n        if (rst) begin\n            dout <= {DATA_WIDTH{1'b0}};\n        end else begin\n            if (we) begin\n                mem[addr] <= din;\n            end\n            dout <= mem[addr];\n        end\n    end\n\nendmodule\n```",
            "```verilog\nmodule simple_ram #(\n    parameter DATA_WIDTH = 8,\n    parameter ADDR_WIDTH = 4\n)(\n    input wire clk,\n    input wire rst,\n    input wire we,                  // Write enable\n    input wire re,                  // Read enable\n    input wire [ADDR_WIDTH-1:0] addr,\n    input wire [DATA_WIDTH-1:0] din,\n    output reg [DATA_WIDTH-1:0] dout\n);\n\n    // RAM memory declaration\n    reg [DATA_WIDTH-1:0] mem [0:(1<<ADDR_WIDTH)-1];\n\n    always @(posedge clk) begin\n        if (rst) begin\n            dout <= {DATA_WIDTH{1'b0}};\n        end else begin\n            if (we) begin\n                mem[addr] <= din;\n            end\n            if (re) begin\n                dout <= mem[addr];\n            end\n        end\n    end\n\nendmodule\n```",
            "```verilog\nmodule simple_ram #(\n    parameter DATA_WIDTH = 8,\n    parameter ADDR_WIDTH = 4\n)(\n    input wire clk,\n    input wire we,                  // Write enable\n    input wire re,                  // Read enable\n    input wire [ADDR_WIDTH-1:0] addr,\n    input wire [DATA_WIDTH-1:0] din,\n    output reg [DATA_WIDTH-1:0] dout\n);\n\n    // Memory declaration\n    reg [DATA_WIDTH-1:0] mem [0:(1<<ADDR_WIDTH)-1];\n\n    always @(posedge clk) begin\n        if (we) begin\n            mem[addr] <= din;\n        end\n        if (re) begin\n            dout <= mem[addr];\n        end\n    end\n\nendmodule\n```",
            "```verilog\nmodule simple_ram #(\n    parameter DATA_WIDTH = 8,\n    parameter ADDR_WIDTH = 4\n)(\n    input wire clk,\n    input wire rst,\n    input wire we,                  // Write enable\n    input wire re,                  // Read enable\n    input wire [ADDR_WIDTH-1:0] addr,\n    input wire [DATA_WIDTH-1:0] din,\n    output reg [DATA_WIDTH-1:0] dout\n);\n\n    // RAM memory declaration\n    reg [DATA_WIDTH-1:0] mem [0:(1<<ADDR_WIDTH)-1];\n\n    always @(posedge clk) begin\n        if (rst) begin\n            dout <= {DATA_WIDTH{1'b0}};\n        end else begin\n            if (we) begin\n                mem[addr] <= din;\n            end\n            if (re) begin\n                dout <= mem[addr];\n            end\n        end\n    end\n\nendmodule\n```",
            "```verilog\nmodule ram #(\n    parameter DATA_WIDTH = 8,\n    parameter ADDR_WIDTH = 8\n)(\n    input wire clk,\n    input wire we,                  // Write enable\n    input wire re,                  // Read enable\n    input wire [ADDR_WIDTH-1:0] addr,\n    input wire [DATA_WIDTH-1:0] din,\n    output reg [DATA_WIDTH-1:0] dout\n);\n\n    // Memory declaration\n    reg [DATA_WIDTH-1:0] mem [0:(1<<ADDR_WIDTH)-1];\n\n    always @(posedge clk) begin\n        if (we) begin\n            mem[addr] <= din;\n        end\n        if (re) begin\n            dout <= mem[addr];\n        end\n    end\n\nendmodule\n```",
            "```verilog\nmodule simple_ram #(\n    parameter DATA_WIDTH = 8,\n    parameter ADDR_WIDTH = 4\n)(\n    input wire clk,\n    input wire rst,\n    input wire we,                  // Write enable\n    input wire re,                  // Read enable\n    input wire [ADDR_WIDTH-1:0] addr,\n    input wire [DATA_WIDTH-1:0] din,\n    output reg [DATA_WIDTH-1:0] dout\n);\n\n    // Memory declaration\n    reg [DATA_WIDTH-1:0] mem [0:(1<<ADDR_WIDTH)-1];\n\n    always @(posedge clk) begin\n        if (rst) begin\n            dout <= {DATA_WIDTH{1'b0}};\n        end else begin\n            if (we) begin\n                mem[addr] <= din;\n            end\n            if (re) begin\n                dout <= mem[addr];\n            end\n        end\n    end\n\nendmodule\n```"
        ],
        "config": {
            "model": "gpt-4.1",
            "system_instruction": "You are a Verilog code generator. Output only synthesizable Verilog code.",
            "temperature": 0.2,
            "max_tokens": 1024,
            "samples": 10
        }
    },
    {
        "question": "Permutation in Verilog",
        "outputs": [
            "```verilog\n// Permutation module: permutes 8-bit input according to a given permutation pattern\nmodule permutation #(\n    parameter WIDTH = 8,\n    parameter [WIDTH-1:0] PERM [WIDTH-1:0] = '{7,6,5,4,3,2,1,0} // Default: reverse\n)(\n    input  wire [WIDTH-1:0] in,\n    output wire [WIDTH-1:0] out\n);\n\n    genvar i;\n    generate\n        for (i = 0; i < WIDTH; i = i + 1) begin : permute\n            assign out[i] = in[PERM[i]];\n        end\n    endgenerate\n\nendmodule\n\n// Example instantiation:\n// Permutation pattern: {2,0,3,1,7,5,6,4} (custom permutation)\nmodule permutation_example;\n    localparam [7:0] MY_PERM [7:0] = '{2,0,3,1,7,5,6,4};\n    reg  [7:0] in;\n    wire [7:0] out;\n\n    permutation #(\n        .WIDTH(8),\n        .PERM(MY_PERM)\n    ) uut (\n        .in(in),\n        .out(out)\n    );\n\n    initial begin\n        in = 8'b11010101;\n        #10;\n        // out will be permuted according to MY_PERM\n    end\nendmodule\n```",
            "```verilog\n// Permutation module: permutes 8-bit input according to a given permutation pattern\nmodule permutation8 (\n    input  wire [7:0] in,\n    output wire [7:0] out\n);\n    // Example permutation: out[i] = in[perm[i]]\n    // Let's use the permutation {2, 4, 6, 0, 1, 3, 5, 7}\n    assign out[7] = in[7]; // perm[7] = 7\n    assign out[6] = in[5]; // perm[6] = 5\n    assign out[5] = in[3]; // perm[5] = 3\n    assign out[4] = in[1]; // perm[4] = 1\n    assign out[3] = in[0]; // perm[3] = 0\n    assign out[2] = in[6]; // perm[2] = 6\n    assign out[1] = in[4]; // perm[1] = 4\n    assign out[0] = in[2]; // perm[0] = 2\nendmodule\n```\n**Note:**  \n- Change the permutation pattern as needed by modifying the assignments.\n- This example is for 8 bits; for other widths, expand accordingly.",
            "```verilog\n// Permutation module: permutes 8-bit input according to a given permutation pattern\nmodule permutation8 (\n    input  wire [7:0] in,\n    output wire [7:0] out\n);\n    // Example permutation pattern: [2, 4, 6, 0, 1, 7, 5, 3]\n    // out[7] = in[3]\n    // out[6] = in[5]\n    // out[5] = in[7]\n    // out[4] = in[1]\n    // out[3] = in[0]\n    // out[2] = in[6]\n    // out[1] = in[4]\n    // out[0] = in[2]\n\n    assign out[7] = in[3];\n    assign out[6] = in[5];\n    assign out[5] = in[7];\n    assign out[4] = in[1];\n    assign out[3] = in[0];\n    assign out[2] = in[6];\n    assign out[1] = in[4];\n    assign out[0] = in[2];\nendmodule\n```\n**Note:**  \n- Change the permutation pattern as needed by modifying the assignments.\n- This module is synthesizable and works for 8-bit vectors. For other widths, adjust the code accordingly.",
            "```verilog\n// Permutation module: permutes 8-bit input according to a given permutation pattern\nmodule permutation8 (\n    input  wire [7:0] in,\n    output wire [7:0] out\n);\n    // Example permutation pattern: [2, 4, 6, 0, 1, 7, 3, 5]\n    // out[7] = in[5]\n    // out[6] = in[3]\n    // out[5] = in[7]\n    // out[4] = in[1]\n    // out[3] = in[0]\n    // out[2] = in[6]\n    // out[1] = in[4]\n    // out[0] = in[2]\n\n    assign out[7] = in[5];\n    assign out[6] = in[3];\n    assign out[5] = in[7];\n    assign out[4] = in[1];\n    assign out[3] = in[0];\n    assign out[2] = in[6];\n    assign out[1] = in[4];\n    assign out[0] = in[2];\n\nendmodule\n```\n**Note:**  \n- Change the permutation pattern as needed by modifying the assignments.\n- This is a purely combinational, synthesizable Verilog module.  \n- For other input widths or permutation patterns, adjust accordingly.",
            "```verilog\n// Permutation module: permutes 8-bit input according to a given permutation pattern\nmodule permutation8 (\n    input  wire [7:0] data_in,\n    output wire [7:0] data_out\n);\n    // Example permutation pattern: {3, 7, 0, 2, 6, 1, 5, 4}\n    // data_out[7] = data_in[3]\n    // data_out[6] = data_in[7]\n    // data_out[5] = data_in[0]\n    // data_out[4] = data_in[2]\n    // data_out[3] = data_in[6]\n    // data_out[2] = data_in[1]\n    // data_out[1] = data_in[5]\n    // data_out[0] = data_in[4]\n\n    assign data_out[7] = data_in[3];\n    assign data_out[6] = data_in[7];\n    assign data_out[5] = data_in[0];\n    assign data_out[4] = data_in[2];\n    assign data_out[3] = data_in[6];\n    assign data_out[2] = data_in[1];\n    assign data_out[1] = data_in[5];\n    assign data_out[0] = data_in[4];\nendmodule\n```\n**Note:**  \n- Change the permutation pattern by modifying the assignments as needed.\n- This is a purely combinational, synthesizable Verilog module.  \n- For other input widths or permutation patterns, adjust the code accordingly.",
            "```verilog\n// Permutation module: permutes 8-bit input according to a given permutation pattern\nmodule permutation8 (\n    input  wire [7:0] data_in,\n    output wire [7:0] data_out\n);\n    // Example permutation: [2, 4, 6, 0, 1, 7, 5, 3]\n    // data_out[7] = data_in[3]\n    // data_out[6] = data_in[5]\n    // data_out[5] = data_in[7]\n    // data_out[4] = data_in[1]\n    // data_out[3] = data_in[0]\n    // data_out[2] = data_in[6]\n    // data_out[1] = data_in[4]\n    // data_out[0] = data_in[2]\n\n    assign data_out[7] = data_in[3];\n    assign data_out[6] = data_in[5];\n    assign data_out[5] = data_in[7];\n    assign data_out[4] = data_in[1];\n    assign data_out[3] = data_in[0];\n    assign data_out[2] = data_in[6];\n    assign data_out[1] = data_in[4];\n    assign data_out[0] = data_in[2];\n\nendmodule\n```",
            "```verilog\n// Permutation module: permutes 8-bit input according to a given permutation pattern\nmodule permutation8 (\n    input  wire [7:0] data_in,\n    output wire [7:0] data_out\n);\n    // Example permutation pattern: [2, 4, 6, 0, 7, 1, 3, 5]\n    // This means:\n    // data_out[7] = data_in[2]\n    // data_out[6] = data_in[4]\n    // data_out[5] = data_in[6]\n    // data_out[4] = data_in[0]\n    // data_out[3] = data_in[7]\n    // data_out[2] = data_in[1]\n    // data_out[1] = data_in[3]\n    // data_out[0] = data_in[5]\n\n    assign data_out[7] = data_in[2];\n    assign data_out[6] = data_in[4];\n    assign data_out[5] = data_in[6];\n    assign data_out[4] = data_in[0];\n    assign data_out[3] = data_in[7];\n    assign data_out[2] = data_in[1];\n    assign data_out[1] = data_in[3];\n    assign data_out[0] = data_in[5];\n\nendmodule\n```\n**Note:**  \n- Change the permutation pattern as needed by modifying the assignments.\n- This module is synthesizable and works for 8-bit input. For other widths, expand accordingly.",
            "```verilog\n// Permutation module: permutes 8-bit input according to a given permutation pattern\nmodule permutation8 (\n    input  wire [7:0] in,\n    output wire [7:0] out\n);\n    // Example permutation pattern: {2, 4, 6, 0, 1, 7, 5, 3}\n    // out[7] = in[2]\n    // out[6] = in[4]\n    // out[5] = in[6]\n    // out[4] = in[0]\n    // out[3] = in[1]\n    // out[2] = in[7]\n    // out[1] = in[5]\n    // out[0] = in[3]\n    assign out[7] = in[2];\n    assign out[6] = in[4];\n    assign out[5] = in[6];\n    assign out[4] = in[0];\n    assign out[3] = in[1];\n    assign out[2] = in[7];\n    assign out[1] = in[5];\n    assign out[0] = in[3];\nendmodule\n```\n**Note:**  \n- Change the permutation pattern in the comments and assignments as needed for your application.\n- This is a purely combinational, synthesizable module.",
            "```verilog\n// Permutation module: permutes 8-bit input according to a given permutation pattern\nmodule permutation8 (\n    input  wire [7:0] data_in,\n    output wire [7:0] data_out\n);\n\n    // Example permutation pattern: [2, 4, 6, 0, 7, 1, 3, 5]\n    // This means:\n    // data_out[7] = data_in[2]\n    // data_out[6] = data_in[4]\n    // data_out[5] = data_in[6]\n    // data_out[4] = data_in[0]\n    // data_out[3] = data_in[7]\n    // data_out[2] = data_in[1]\n    // data_out[1] = data_in[3]\n    // data_out[0] = data_in[5]\n\n    assign data_out[7] = data_in[2];\n    assign data_out[6] = data_in[4];\n    assign data_out[5] = data_in[6];\n    assign data_out[4] = data_in[0];\n    assign data_out[3] = data_in[7];\n    assign data_out[2] = data_in[1];\n    assign data_out[1] = data_in[3];\n    assign data_out[0] = data_in[5];\n\nendmodule\n```",
            "```verilog\n// Permutation module: permutes input bits according to a given mapping\nmodule permutation #(\n    parameter WIDTH = 8,                       // Width of input/output\n    parameter [WIDTH*4-1:0] MAP = 32'h32107654 // Example: for WIDTH=8, MAP={3,2,1,0,7,6,5,4}\n)(\n    input  wire [WIDTH-1:0] in,\n    output wire [WIDTH-1:0] out\n);\n\n    genvar i;\n    generate\n        for (i = 0; i < WIDTH; i = i + 1) begin : permute_bits\n            // MAP[4*i +: 4] gives the source bit index for output bit i\n            assign out[i] = in[MAP[4*i +: 4]];\n        end\n    endgenerate\n\nendmodule\n```\n**Usage Example:**\n```verilog\n// Permute 8 bits: output[0] = input[3], output[1] = input[2], ...\npermutation #(\n    .WIDTH(8),\n    .MAP({4'd3,4'd2,4'd1,4'd0,4'd7,4'd6,4'd5,4'd4})\n) perm_inst (\n    .in(data_in),\n    .out(data_out)\n);\n```\n**Notes:**\n- `MAP` is a packed array of 4-bit indices (for up to 16 bits). For wider buses, increase the bit width per index.\n- The permutation is combinational and synthesizable."
        ],
        "config": {
            "model": "gpt-4.1",
            "system_instruction": "You are a Verilog code generator. Output only synthesizable Verilog code.",
            "temperature": 0.2,
            "max_tokens": 1024,
            "samples": 10
        }
    },
    {
        "question": "Use a case statement to represent a 2 input AND gate in Verilog",
        "outputs": [
            "```verilog\nmodule and_gate_case (\n    input  wire a,\n    input  wire b,\n    output reg  y\n);\n\nalways @(*) begin\n    case ({a, b})\n        2'b00: y = 1'b0;\n        2'b01: y = 1'b0;\n        2'b10: y = 1'b0;\n        2'b11: y = 1'b1;\n        default: y = 1'b0;\n    endcase\nend\n\nendmodule\n```",
            "```verilog\nmodule and_gate_case (\n    input  wire a,\n    input  wire b,\n    output reg  y\n);\n\nalways @(*) begin\n    case ({a, b})\n        2'b00: y = 1'b0;\n        2'b01: y = 1'b0;\n        2'b10: y = 1'b0;\n        2'b11: y = 1'b1;\n        default: y = 1'b0;\n    endcase\nend\n\nendmodule\n```",
            "```verilog\nmodule and_gate_case (\n    input  wire a,\n    input  wire b,\n    output reg  y\n);\n\nalways @(*) begin\n    case ({a, b})\n        2'b00: y = 1'b0;\n        2'b01: y = 1'b0;\n        2'b10: y = 1'b0;\n        2'b11: y = 1'b1;\n        default: y = 1'b0;\n    endcase\nend\n\nendmodule\n```",
            "```verilog\nmodule and_gate_case (\n    input  wire a,\n    input  wire b,\n    output reg  y\n);\n\nalways @(*) begin\n    case ({a, b})\n        2'b00: y = 1'b0;\n        2'b01: y = 1'b0;\n        2'b10: y = 1'b0;\n        2'b11: y = 1'b1;\n        default: y = 1'b0;\n    endcase\nend\n\nendmodule\n```",
            "```verilog\nmodule and_gate_case (\n    input  wire a,\n    input  wire b,\n    output reg  y\n);\n\nalways @(*) begin\n    case ({a, b})\n        2'b00: y = 1'b0;\n        2'b01: y = 1'b0;\n        2'b10: y = 1'b0;\n        2'b11: y = 1'b1;\n        default: y = 1'b0;\n    endcase\nend\n\nendmodule\n```",
            "```verilog\nmodule and_gate_case (\n    input  wire a,\n    input  wire b,\n    output reg  y\n);\n\nalways @(*) begin\n    case ({a, b})\n        2'b00: y = 1'b0;\n        2'b01: y = 1'b0;\n        2'b10: y = 1'b0;\n        2'b11: y = 1'b1;\n        default: y = 1'b0;\n    endcase\nend\n\nendmodule\n```",
            "```verilog\nmodule and_gate_case (\n    input  wire a,\n    input  wire b,\n    output reg  y\n);\n\nalways @(*) begin\n    case ({a, b})\n        2'b00: y = 1'b0;\n        2'b01: y = 1'b0;\n        2'b10: y = 1'b0;\n        2'b11: y = 1'b1;\n        default: y = 1'b0;\n    endcase\nend\n\nendmodule\n```",
            "```verilog\nmodule and_gate_case (\n    input  wire a,\n    input  wire b,\n    output reg  y\n);\n\nalways @(*) begin\n    case ({a, b})\n        2'b00: y = 1'b0;\n        2'b01: y = 1'b0;\n        2'b10: y = 1'b0;\n        2'b11: y = 1'b1;\n        default: y = 1'b0;\n    endcase\nend\n\nendmodule\n```",
            "```verilog\nmodule and_gate_case (\n    input  wire a,\n    input  wire b,\n    output reg  y\n);\n\nalways @(*) begin\n    case ({a, b})\n        2'b00: y = 1'b0;\n        2'b01: y = 1'b0;\n        2'b10: y = 1'b0;\n        2'b11: y = 1'b1;\n        default: y = 1'b0;\n    endcase\nend\n\nendmodule\n```",
            "```verilog\nmodule and_gate_case (\n    input  wire a,\n    input  wire b,\n    output reg  y\n);\n\nalways @(*) begin\n    case ({a, b})\n        2'b00: y = 1'b0;\n        2'b01: y = 1'b0;\n        2'b10: y = 1'b0;\n        2'b11: y = 1'b1;\n        default: y = 1'b0;\n    endcase\nend\n\nendmodule\n```"
        ],
        "config": {
            "model": "gpt-4.1",
            "system_instruction": "You are a Verilog code generator. Output only synthesizable Verilog code.",
            "temperature": 0.2,
            "max_tokens": 1024,
            "samples": 10
        }
    },
    {
        "question": "Signed 8 bit adder with overflow detection in Verilog",
        "outputs": [
            "```verilog\nmodule signed_adder_8bit (\n    input  wire signed [7:0] a,\n    input  wire signed [7:0] b,\n    output wire signed [7:0] sum,\n    output wire overflow\n);\n\n    assign sum = a + b;\n\n    // Overflow detection for signed addition:\n    // Overflow occurs if the sign of a and b are the same,\n    // but the sign of sum is different.\n    assign overflow = (~(a[7] ^ b[7])) & (a[7] ^ sum[7]);\n\nendmodule\n```",
            "```verilog\nmodule signed_adder_8bit (\n    input  signed [7:0] a,\n    input  signed [7:0] b,\n    output signed [7:0] sum,\n    output              overflow\n);\n\n    assign sum = a + b;\n\n    // Overflow detection for signed addition:\n    // Overflow occurs if the sign of a and b are the same,\n    // but the sign of sum is different.\n    assign overflow = (~(a[7] ^ b[7])) & (a[7] ^ sum[7]);\n\nendmodule\n```",
            "```verilog\nmodule signed_adder_8bit (\n    input  signed [7:0] a,\n    input  signed [7:0] b,\n    output signed [7:0] sum,\n    output              overflow\n);\n\n    assign sum = a + b;\n\n    // Overflow detection for signed addition:\n    // Overflow occurs if the sign of a and b are the same,\n    // but the sign of sum is different.\n    assign overflow = (~(a[7] ^ b[7])) & (a[7] ^ sum[7]);\n\nendmodule\n```",
            "```verilog\nmodule signed_adder_8bit (\n    input  wire signed [7:0] a,\n    input  wire signed [7:0] b,\n    output wire signed [7:0] sum,\n    output wire overflow\n);\n\n    assign sum = a + b;\n\n    // Overflow detection for signed addition:\n    // Overflow occurs if the sign of a and b are the same,\n    // but the sign of sum is different.\n    assign overflow = (~(a[7] ^ b[7])) & (a[7] ^ sum[7]);\n\nendmodule\n```",
            "```verilog\nmodule signed_adder_8bit (\n    input  signed [7:0] a,\n    input  signed [7:0] b,\n    output signed [7:0] sum,\n    output              overflow\n);\n\n    assign sum = a + b;\n\n    // Overflow detection for signed addition:\n    // Overflow occurs if the sign of a and b are the same,\n    // but the sign of sum is different.\n    assign overflow = (~(a[7] ^ b[7])) & (a[7] ^ sum[7]);\n\nendmodule\n```",
            "```verilog\nmodule signed_adder_8bit (\n    input  wire signed [7:0] a,\n    input  wire signed [7:0] b,\n    output wire signed [7:0] sum,\n    output wire overflow\n);\n\n    assign sum = a + b;\n\n    // Overflow detection for signed addition:\n    // Overflow occurs if the sign of a and b are the same,\n    // but the sign of sum is different.\n    assign overflow = (~(a[7] ^ b[7])) & (a[7] ^ sum[7]);\n\nendmodule\n```",
            "```verilog\nmodule signed_adder_8bit (\n    input  wire signed [7:0] a,\n    input  wire signed [7:0] b,\n    output wire signed [7:0] sum,\n    output wire overflow\n);\n\n    assign sum = a + b;\n\n    // Overflow detection for signed addition:\n    // Overflow occurs if the sign of a and b are the same,\n    // but the sign of the result is different.\n    assign overflow = (~(a[7] ^ b[7])) & (a[7] ^ sum[7]);\n\nendmodule\n```",
            "```verilog\nmodule signed_adder_8bit (\n    input  signed [7:0] a,\n    input  signed [7:0] b,\n    output signed [7:0] sum,\n    output              overflow\n);\n\n    assign sum = a + b;\n\n    // Overflow detection for signed addition:\n    // Overflow occurs if the sign of a and b are the same,\n    // but the sign of sum is different.\n    assign overflow = (~(a[7] ^ b[7])) & (a[7] ^ sum[7]);\n\nendmodule\n```",
            "```verilog\nmodule signed_adder_8bit (\n    input  wire signed [7:0] a,\n    input  wire signed [7:0] b,\n    output wire signed [7:0] sum,\n    output wire overflow\n);\n\n    assign sum = a + b;\n\n    // Overflow detection: \n    // If a and b have the same sign, but sum has a different sign, overflow occurred.\n    assign overflow = (~(a[7] ^ b[7])) & (a[7] ^ sum[7]);\n\nendmodule\n```",
            "```verilog\nmodule signed_adder_8bit (\n    input  signed [7:0] a,\n    input  signed [7:0] b,\n    output signed [7:0] sum,\n    output              overflow\n);\n\n    assign sum = a + b;\n\n    // Overflow detection for signed addition\n    assign overflow = (~a[7] & ~b[7] & sum[7]) | (a[7] & b[7] & ~sum[7]);\n\nendmodule\n```"
        ],
        "config": {
            "model": "gpt-4.1",
            "system_instruction": "You are a Verilog code generator. Output only synthesizable Verilog code.",
            "temperature": 0.2,
            "max_tokens": 1024,
            "samples": 10
        }
    },
    {
        "question": "Verilog module for an up-counter that uses an enable control",
        "outputs": [
            "```verilog\nmodule up_counter #(\n    parameter WIDTH = 8\n)(\n    input wire clk,\n    input wire rst_n,\n    input wire en,\n    output reg [WIDTH-1:0] count\n);\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        count <= {WIDTH{1'b0}};\n    else if (en)\n        count <= count + 1'b1;\nend\n\nendmodule\n```",
            "```verilog\nmodule up_counter #(\n    parameter WIDTH = 8\n)(\n    input wire clk,\n    input wire rst_n,\n    input wire en,\n    output reg [WIDTH-1:0] count\n);\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        count <= {WIDTH{1'b0}};\n    else if (en)\n        count <= count + 1'b1;\nend\n\nendmodule\n```",
            "```verilog\nmodule up_counter #(\n    parameter WIDTH = 8\n)(\n    input wire clk,\n    input wire rst_n,\n    input wire en,\n    output reg [WIDTH-1:0] count\n);\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        count <= {WIDTH{1'b0}};\n    else if (en)\n        count <= count + 1'b1;\nend\n\nendmodule\n```",
            "```verilog\nmodule up_counter #(\n    parameter WIDTH = 8\n)(\n    input wire clk,\n    input wire rst_n,\n    input wire en,\n    output reg [WIDTH-1:0] count\n);\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        count <= {WIDTH{1'b0}};\n    else if (en)\n        count <= count + 1'b1;\nend\n\nendmodule\n```",
            "```verilog\nmodule up_counter #(\n    parameter WIDTH = 8\n)(\n    input wire clk,\n    input wire rst_n,\n    input wire en,\n    output reg [WIDTH-1:0] count\n);\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        count <= {WIDTH{1'b0}};\n    else if (en)\n        count <= count + 1'b1;\nend\n\nendmodule\n```",
            "```verilog\nmodule up_counter #(\n    parameter WIDTH = 8\n)(\n    input wire clk,\n    input wire rst_n,\n    input wire en,\n    output reg [WIDTH-1:0] count\n);\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        count <= {WIDTH{1'b0}};\n    else if (en)\n        count <= count + 1'b1;\nend\n\nendmodule\n```",
            "```verilog\nmodule up_counter #(\n    parameter WIDTH = 8\n)(\n    input wire clk,\n    input wire rst_n,\n    input wire en,\n    output reg [WIDTH-1:0] count\n);\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        count <= {WIDTH{1'b0}};\n    else if (en)\n        count <= count + 1'b1;\nend\n\nendmodule\n```",
            "```verilog\nmodule up_counter #(\n    parameter WIDTH = 8\n)(\n    input wire clk,\n    input wire rst_n,\n    input wire en,\n    output reg [WIDTH-1:0] count\n);\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        count <= {WIDTH{1'b0}};\n    else if (en)\n        count <= count + 1'b1;\nend\n\nendmodule\n```",
            "```verilog\nmodule up_counter #(\n    parameter WIDTH = 8\n)(\n    input wire clk,\n    input wire rst_n,\n    input wire en,\n    output reg [WIDTH-1:0] count\n);\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        count <= {WIDTH{1'b0}};\n    else if (en)\n        count <= count + 1'b1;\nend\n\nendmodule\n```",
            "```verilog\nmodule up_counter #(\n    parameter WIDTH = 8\n)(\n    input wire clk,\n    input wire rst_n,\n    input wire en,\n    output reg [WIDTH-1:0] count\n);\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        count <= {WIDTH{1'b0}};\n    else if (en)\n        count <= count + 1'b1;\nend\n\nendmodule\n```"
        ],
        "config": {
            "model": "gpt-4.1",
            "system_instruction": "You are a Verilog code generator. Output only synthesizable Verilog code.",
            "temperature": 0.2,
            "max_tokens": 1024,
            "samples": 10
        }
    },
    {
        "question": "Implement a finite state machine that outputs high on detecting 101 in Verilog",
        "outputs": [
            "```verilog\nmodule fsm_101_detector (\n    input  wire clk,\n    input  wire rst_n,\n    input  wire in,\n    output reg  out\n);\n\n    typedef enum logic [1:0] {\n        S0, // Initial state\n        S1, // Detected '1'\n        S2  // Detected '10'\n    } state_t;\n\n    state_t state, next_state;\n\n    // State register\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            state <= S0;\n        else\n            state <= next_state;\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            S0: begin\n                if (in)\n                    next_state = S1;\n                else\n                    next_state = S0;\n            end\n            S1: begin\n                if (!in)\n                    next_state = S2;\n                else\n                    next_state = S1;\n            end\n            S2: begin\n                if (in)\n                    next_state = S1;\n                else\n                    next_state = S0;\n            end\n            default: next_state = S0;\n        endcase\n    end\n\n    // Output logic (Moore machine: output depends only on state)\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            out <= 1'b0;\n        else if (state == S2 && in)\n            out <= 1'b1;\n        else\n            out <= 1'b0;\n    end\n\nendmodule\n```",
            "```verilog\nmodule fsm_101_detector (\n    input  wire clk,\n    input  wire rst_n,\n    input  wire in,\n    output reg  out\n);\n\n    typedef enum logic [1:0] {\n        S0, // Initial state\n        S1, // Detected '1'\n        S2  // Detected '10'\n    } state_t;\n\n    state_t state, next_state;\n\n    // State register\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            state <= S0;\n        else\n            state <= next_state;\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            S0: begin\n                if (in)\n                    next_state = S1;\n                else\n                    next_state = S0;\n            end\n            S1: begin\n                if (in)\n                    next_state = S1;\n                else\n                    next_state = S2;\n            end\n            S2: begin\n                if (in)\n                    next_state = S1;\n                else\n                    next_state = S0;\n            end\n            default: next_state = S0;\n        endcase\n    end\n\n    // Output logic (Moore FSM: output depends only on state)\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            out <= 1'b0;\n        else if (state == S2 && in)\n            out <= 1'b1;\n        else\n            out <= 1'b0;\n    end\n\nendmodule\n```",
            "```verilog\nmodule fsm_101_detector (\n    input  wire clk,\n    input  wire rst_n,\n    input  wire in,\n    output reg  out\n);\n\n    typedef enum logic [1:0] {\n        S0, // Initial state\n        S1, // Detected '1'\n        S2  // Detected '10'\n    } state_t;\n\n    state_t state, next_state;\n\n    // State register\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            state <= S0;\n        else\n            state <= next_state;\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            S0: begin\n                if (in)\n                    next_state = S1;\n                else\n                    next_state = S0;\n            end\n            S1: begin\n                if (!in)\n                    next_state = S2;\n                else\n                    next_state = S1;\n            end\n            S2: begin\n                if (in)\n                    next_state = S1;\n                else\n                    next_state = S0;\n            end\n            default: next_state = S0;\n        endcase\n    end\n\n    // Output logic (Moore FSM: output depends only on state)\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            out <= 1'b0;\n        else begin\n            if (state == S2 && in)\n                out <= 1'b1;\n            else\n                out <= 1'b0;\n        end\n    end\n\nendmodule\n```",
            "```verilog\nmodule fsm_101_detector (\n    input  wire clk,\n    input  wire rst_n,\n    input  wire in,\n    output reg  out\n);\n\n    typedef enum logic [1:0] {\n        S0, // Initial state\n        S1, // Detected '1'\n        S2  // Detected '10'\n    } state_t;\n\n    state_t state, next_state;\n\n    // State register\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            state <= S0;\n        else\n            state <= next_state;\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            S0: begin\n                if (in)\n                    next_state = S1;\n                else\n                    next_state = S0;\n            end\n            S1: begin\n                if (in)\n                    next_state = S1;\n                else\n                    next_state = S2;\n            end\n            S2: begin\n                if (in)\n                    next_state = S1;\n                else\n                    next_state = S0;\n            end\n            default: next_state = S0;\n        endcase\n    end\n\n    // Output logic: output high when sequence '101' is detected\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            out <= 1'b0;\n        else if (state == S2 && in)\n            out <= 1'b1;\n        else\n            out <= 1'b0;\n    end\n\nendmodule\n```",
            "```verilog\nmodule fsm_101_detector (\n    input  wire clk,\n    input  wire rst_n,\n    input  wire in,\n    output reg  out\n);\n\n    typedef enum logic [1:0] {\n        S0, // Initial state\n        S1, // Detected '1'\n        S2  // Detected '10'\n    } state_t;\n\n    state_t state, next_state;\n\n    // State register\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            state <= S0;\n        else\n            state <= next_state;\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            S0: begin\n                if (in)\n                    next_state = S1;\n                else\n                    next_state = S0;\n            end\n            S1: begin\n                if (!in)\n                    next_state = S2;\n                else\n                    next_state = S1;\n            end\n            S2: begin\n                if (in)\n                    next_state = S1;\n                else\n                    next_state = S0;\n            end\n            default: next_state = S0;\n        endcase\n    end\n\n    // Output logic (Moore machine: output depends on state and input)\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            out <= 1'b0;\n        else if (state == S2 && in)\n            out <= 1'b1;\n        else\n            out <= 1'b0;\n    end\n\nendmodule\n```",
            "```verilog\nmodule fsm_101_detector (\n    input  wire clk,\n    input  wire rst_n,\n    input  wire in,\n    output reg  out\n);\n\n    typedef enum logic [1:0] {\n        S0, // Initial state\n        S1, // Detected '1'\n        S2  // Detected '10'\n    } state_t;\n\n    state_t state, next_state;\n\n    // State register\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            state <= S0;\n        else\n            state <= next_state;\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            S0: begin\n                if (in)\n                    next_state = S1;\n                else\n                    next_state = S0;\n            end\n            S1: begin\n                if (in)\n                    next_state = S1;\n                else\n                    next_state = S2;\n            end\n            S2: begin\n                if (in)\n                    next_state = S1;\n                else\n                    next_state = S0;\n            end\n            default: next_state = S0;\n        endcase\n    end\n\n    // Output logic: output high when sequence \"101\" is detected\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            out <= 1'b0;\n        else\n            out <= (state == S2 && in);\n    end\n\nendmodule\n```",
            "```verilog\nmodule fsm_101_detector (\n    input  wire clk,\n    input  wire rst_n,\n    input  wire in,\n    output reg  out\n);\n\n    typedef enum logic [1:0] {\n        S0, // Initial state\n        S1, // Detected '1'\n        S2  // Detected '10'\n    } state_t;\n\n    state_t state, next_state;\n\n    // State register\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            state <= S0;\n        else\n            state <= next_state;\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            S0: begin\n                if (in)\n                    next_state = S1;\n                else\n                    next_state = S0;\n            end\n            S1: begin\n                if (in)\n                    next_state = S1;\n                else\n                    next_state = S2;\n            end\n            S2: begin\n                if (in)\n                    next_state = S1;\n                else\n                    next_state = S0;\n            end\n            default: next_state = S0;\n        endcase\n    end\n\n    // Output logic (Moore machine: output depends on state and input)\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            out <= 1'b0;\n        else if (state == S2 && in)\n            out <= 1'b1;\n        else\n            out <= 1'b0;\n    end\n\nendmodule\n```",
            "```verilog\nmodule fsm_101_detector (\n    input  wire clk,\n    input  wire rst_n,\n    input  wire in,\n    output reg  out\n);\n\n    typedef enum logic [1:0] {\n        S0, // Initial state\n        S1, // Detected '1'\n        S2  // Detected '10'\n    } state_t;\n\n    state_t state, next_state;\n\n    // State register\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            state <= S0;\n        else\n            state <= next_state;\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            S0: begin\n                if (in)\n                    next_state = S1;\n                else\n                    next_state = S0;\n            end\n            S1: begin\n                if (in)\n                    next_state = S1;\n                else\n                    next_state = S2;\n            end\n            S2: begin\n                if (in)\n                    next_state = S1;\n                else\n                    next_state = S0;\n            end\n            default: next_state = S0;\n        endcase\n    end\n\n    // Output logic (Moore FSM: output depends only on state)\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            out <= 1'b0;\n        else if (state == S2 && in)\n            out <= 1'b1;\n        else\n            out <= 1'b0;\n    end\n\nendmodule\n```",
            "```verilog\nmodule fsm_101_detector (\n    input  wire clk,\n    input  wire rst_n,\n    input  wire in,\n    output reg  out\n);\n\n    typedef enum logic [1:0] {\n        S0, // Initial state\n        S1, // Detected '1'\n        S2  // Detected '10'\n    } state_t;\n\n    state_t state, next_state;\n\n    // State register\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            state <= S0;\n        else\n            state <= next_state;\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            S0: next_state = in ? S1 : S0;\n            S1: next_state = in ? S1 : S2;\n            S2: next_state = in ? S1 : S0;\n            default: next_state = S0;\n        endcase\n    end\n\n    // Output logic (Moore machine: output depends only on state)\n    always @(*) begin\n        case (state)\n            S2: out = in ? 1'b1 : 1'b0; // Output high when sequence '101' detected\n            default: out = 1'b0;\n        endcase\n    end\n\nendmodule\n```",
            "```verilog\nmodule fsm_101_detector (\n    input  wire clk,\n    input  wire rst_n,\n    input  wire in,\n    output reg  out\n);\n\n    typedef enum logic [1:0] {\n        S0, // Initial state\n        S1, // Detected '1'\n        S2  // Detected '10'\n    } state_t;\n\n    state_t state, next_state;\n\n    // State register\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            state <= S0;\n        else\n            state <= next_state;\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            S0: begin\n                if (in)\n                    next_state = S1;\n                else\n                    next_state = S0;\n            end\n            S1: begin\n                if (in)\n                    next_state = S1;\n                else\n                    next_state = S2;\n            end\n            S2: begin\n                if (in)\n                    next_state = S1;\n                else\n                    next_state = S0;\n            end\n            default: next_state = S0;\n        endcase\n    end\n\n    // Output logic (Moore FSM: output depends only on state)\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            out <= 1'b0;\n        else if (state == S2 && in)\n            out <= 1'b1;\n        else\n            out <= 1'b0;\n    end\n\nendmodule\n```"
        ],
        "config": {
            "model": "gpt-4.1",
            "system_instruction": "You are a Verilog code generator. Output only synthesizable Verilog code.",
            "temperature": 0.2,
            "max_tokens": 1024,
            "samples": 10
        }
    },
    {
        "question": "Design an arithmetic shift register in Verilog with 64 bit width",
        "outputs": [
            "```verilog\nmodule arithmetic_shift_register_64 (\n    input  wire        clk,\n    input  wire        rst_n,\n    input  wire        shift_en,\n    input  wire        shift_dir, // 0: right (arithmetic), 1: left (logical)\n    input  wire [63:0] din,\n    output reg  [63:0] dout\n);\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        dout <= 64'b0;\n    else if (shift_en) begin\n        if (shift_dir) // shift left (logical)\n            dout <= {dout[62:0], 1'b0};\n        else // shift right (arithmetic)\n            dout <= {dout[63], dout[63:1]};\n    end else\n        dout <= din;\nend\n\nendmodule\n```",
            "```verilog\nmodule arithmetic_shift_register_64 (\n    input  wire        clk,\n    input  wire        rst_n,\n    input  wire        load,\n    input  wire [63:0] data_in,\n    input  wire        shift_en,\n    input  wire        shift_right, // 1: shift right (arithmetic), 0: shift left (logical)\n    output reg  [63:0] data_out\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            data_out <= 64'b0;\n        end else if (load) begin\n            data_out <= data_in;\n        end else if (shift_en) begin\n            if (shift_right) begin\n                // Arithmetic right shift: replicate sign bit\n                data_out <= {data_out[63], data_out[63:1]};\n            end else begin\n                // Logical left shift: shift in 0\n                data_out <= {data_out[62:0], 1'b0};\n            end\n        end\n    end\n\nendmodule\n```",
            "```verilog\nmodule arithmetic_shift_register_64 (\n    input  wire         clk,\n    input  wire         rst_n,\n    input  wire         load,\n    input  wire [63:0]  data_in,\n    input  wire         shift_en,\n    input  wire         shift_right, // 1: shift right (arithmetic), 0: shift left (logical)\n    output reg  [63:0]  data_out\n);\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        data_out <= 64'b0;\n    else if (load)\n        data_out <= data_in;\n    else if (shift_en) begin\n        if (shift_right)\n            // Arithmetic right shift: sign bit is preserved\n            data_out <= {data_out[63], data_out[63:1]};\n        else\n            // Logical left shift: fill LSB with 0\n            data_out <= {data_out[62:0], 1'b0};\n    end\nend\n\nendmodule\n```",
            "```verilog\nmodule arithmetic_shift_register_64 (\n    input  wire        clk,\n    input  wire        rst_n,\n    input  wire        shift_en,\n    input  wire        shift_right, // 1: shift right, 0: shift left\n    input  wire [63:0] data_in,\n    input  wire        load,\n    output reg  [63:0] data_out\n);\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 64'b0;\n    end else if (load) begin\n        data_out <= data_in;\n    end else if (shift_en) begin\n        if (shift_right) begin\n            // Arithmetic right shift: sign-extend MSB\n            data_out <= {data_out[63], data_out[63:1]};\n        end else begin\n            // Arithmetic left shift: shift in 0 at LSB\n            data_out <= {data_out[62:0], 1'b0};\n        end\n    end\nend\n\nendmodule\n```",
            "```verilog\nmodule arithmetic_shift_register_64 (\n    input  wire        clk,\n    input  wire        rst_n,\n    input  wire        load,\n    input  wire [63:0] data_in,\n    input  wire        shift_en,\n    input  wire        shift_right, // 1: arithmetic right shift, 0: left shift\n    output reg  [63:0] data_out\n);\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        data_out <= 64'b0;\n    else if (load)\n        data_out <= data_in;\n    else if (shift_en) begin\n        if (shift_right)\n            data_out <= {data_out[63], data_out[63:1]}; // arithmetic right shift\n        else\n            data_out <= {data_out[62:0], 1'b0}; // left shift, fill LSB with 0\n    end\nend\n\nendmodule\n```",
            "```verilog\nmodule arithmetic_shift_register_64 (\n    input  wire         clk,\n    input  wire         rst_n,\n    input  wire         shift_en,\n    input  wire         shift_right, // 1: arithmetic right shift, 0: left shift\n    input  wire [63:0]  data_in,\n    output reg  [63:0]  data_out\n);\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 64'b0;\n    end else if (shift_en) begin\n        if (shift_right) begin\n            // Arithmetic right shift: sign bit is preserved\n            data_out <= {data_out[63], data_out[63:1]};\n        end else begin\n            // Left shift: fill LSB with 0\n            data_out <= {data_out[62:0], 1'b0};\n        end\n    end else begin\n        data_out <= data_in;\n    end\nend\n\nendmodule\n```",
            "```verilog\nmodule arithmetic_shift_register_64 (\n    input  wire         clk,\n    input  wire         rst_n,\n    input  wire         load,\n    input  wire [63:0]  data_in,\n    input  wire         shift_en,\n    input  wire         shift_right, // 1: arithmetic right, 0: left shift\n    output reg  [63:0]  data_out\n);\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        data_out <= 64'd0;\n    else if (load)\n        data_out <= data_in;\n    else if (shift_en) begin\n        if (shift_right)\n            data_out <= {data_out[63], data_out[63:1]}; // Arithmetic right shift\n        else\n            data_out <= {data_out[62:0], 1'b0};         // Logical left shift\n    end\nend\n\nendmodule\n```",
            "```verilog\nmodule arithmetic_shift_register_64 (\n    input  wire        clk,\n    input  wire        rst_n,\n    input  wire        shift_en,\n    input  wire        shift_right, // 1: arithmetic right shift, 0: left shift\n    input  wire [63:0] din,\n    output reg  [63:0] dout\n);\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        dout <= 64'b0;\n    else if (shift_en) begin\n        if (shift_right)\n            dout <= {dout[63], dout[63:1]}; // arithmetic right shift\n        else\n            dout <= {dout[62:0], 1'b0};     // left shift, fill LSB with 0\n    end\n    else\n        dout <= din;\nend\n\nendmodule\n```",
            "```verilog\nmodule arithmetic_shift_register_64 (\n    input  wire        clk,\n    input  wire        rst_n,\n    input  wire        shift_en,\n    input  wire        shift_right, // 1: arithmetic right shift, 0: left shift\n    input  wire [63:0] din,\n    output reg  [63:0] dout\n);\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        dout <= 64'b0;\n    else if (shift_en) begin\n        if (shift_right)\n            dout <= {dout[63], dout[63:1]}; // Arithmetic right shift\n        else\n            dout <= {dout[62:0], 1'b0};     // Logical left shift\n    end\n    else\n        dout <= din;\nend\n\nendmodule\n```",
            "```verilog\nmodule arithmetic_shift_register_64 (\n    input  wire         clk,\n    input  wire         rst_n,\n    input  wire         load,\n    input  wire [63:0]  data_in,\n    input  wire         shift_en,\n    input  wire         shift_right, // 1: arithmetic right, 0: left shift\n    output reg  [63:0]  data_out\n);\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        data_out <= 64'b0;\n    end else if (load) begin\n        data_out <= data_in;\n    end else if (shift_en) begin\n        if (shift_right) begin\n            // Arithmetic right shift: sign bit is preserved\n            data_out <= {data_out[63], data_out[63:1]};\n        end else begin\n            // Left shift: fill LSB with 0\n            data_out <= {data_out[62:0], 1'b0};\n        end\n    end\nend\n\nendmodule\n```"
        ],
        "config": {
            "model": "gpt-4.1",
            "system_instruction": "You are a Verilog code generator. Output only synthesizable Verilog code.",
            "temperature": 0.2,
            "max_tokens": 1024,
            "samples": 10
        }
    },
    {
        "question": "Design a finite state machine for ABRO sequence",
        "outputs": [
            "```verilog\nmodule abro_fsm (\n    input  wire clk,\n    input  wire reset_n, // active low reset\n    input  wire a,\n    input  wire b,\n    input  wire r,\n    output reg  o\n);\n\n    typedef enum logic [1:0] {\n        IDLE  = 2'b00,\n        SA    = 2'b01,\n        SB    = 2'b10,\n        DONE  = 2'b11\n    } state_t;\n\n    state_t state, next_state;\n\n    // State register\n    always @(posedge clk or negedge reset_n) begin\n        if (!reset_n)\n            state <= IDLE;\n        else\n            state <= next_state;\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            IDLE: begin\n                if (r)\n                    next_state = IDLE;\n                else if (a && b)\n                    next_state = DONE;\n                else if (a)\n                    next_state = SA;\n                else if (b)\n                    next_state = SB;\n                else\n                    next_state = IDLE;\n            end\n            SA: begin\n                if (r)\n                    next_state = IDLE;\n                else if (b)\n                    next_state = DONE;\n                else\n                    next_state = SA;\n            end\n            SB: begin\n                if (r)\n                    next_state = IDLE;\n                else if (a)\n                    next_state = DONE;\n                else\n                    next_state = SB;\n            end\n            DONE: begin\n                if (r)\n                    next_state = IDLE;\n                else\n                    next_state = DONE;\n            end\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // Output logic\n    always @(posedge clk or negedge reset_n) begin\n        if (!reset_n)\n            o <= 1'b0;\n        else if (state == DONE)\n            o <= 1'b1;\n        else\n            o <= 1'b0;\n    end\n\nendmodule\n```\n**Description:**  \n- Inputs: `a`, `b`, `r` (reset), `clk`, `reset_n`\n- Output: `o` (output high for one or more cycles after both `a` and `b` have occurred since last `r`)\n- FSM states:  \n  - `IDLE`: Waiting for `a` or `b`\n  - `SA`: `a` has occurred, waiting for `b`\n  - `SB`: `b` has occurred, waiting for `a`\n  - `DONE`: Both `a` and `b` have occurred, output is high until reset by `r`\n- Reset (`r`) or `reset_n` brings FSM back to `IDLE` and clears output.",
            "```verilog\nmodule abro_fsm (\n    input  wire clk,\n    input  wire reset_n, // active low reset\n    input  wire a,\n    input  wire b,\n    input  wire r,\n    output reg  o\n);\n\n    typedef enum logic [1:0] {\n        IDLE  = 2'b00,\n        SA    = 2'b01,\n        SB    = 2'b10,\n        DONE  = 2'b11\n    } state_t;\n\n    state_t state, next_state;\n\n    // State register\n    always @(posedge clk or negedge reset_n) begin\n        if (!reset_n)\n            state <= IDLE;\n        else\n            state <= next_state;\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            IDLE: begin\n                if (r)\n                    next_state = IDLE;\n                else if (a && b)\n                    next_state = DONE;\n                else if (a)\n                    next_state = SA;\n                else if (b)\n                    next_state = SB;\n                else\n                    next_state = IDLE;\n            end\n            SA: begin\n                if (r)\n                    next_state = IDLE;\n                else if (b)\n                    next_state = DONE;\n                else\n                    next_state = SA;\n            end\n            SB: begin\n                if (r)\n                    next_state = IDLE;\n                else if (a)\n                    next_state = DONE;\n                else\n                    next_state = SB;\n            end\n            DONE: begin\n                if (r)\n                    next_state = IDLE;\n                else\n                    next_state = DONE;\n            end\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // Output logic\n    always @(posedge clk or negedge reset_n) begin\n        if (!reset_n)\n            o <= 1'b0;\n        else if (state == DONE && !r)\n            o <= 1'b1;\n        else if (r)\n            o <= 1'b0;\n        else\n            o <= 1'b0;\n    end\n\nendmodule\n```",
            "```verilog\nmodule abro_fsm (\n    input  wire clk,\n    input  wire reset_n, // active low reset\n    input  wire a,\n    input  wire b,\n    input  wire r,\n    output reg  o\n);\n\n    // State encoding\n    typedef enum logic [1:0] {\n        IDLE  = 2'b00,\n        SA    = 2'b01,\n        SB    = 2'b10,\n        DONE  = 2'b11\n    } state_t;\n\n    state_t state, next_state;\n\n    // State register\n    always @(posedge clk or negedge reset_n) begin\n        if (!reset_n)\n            state <= IDLE;\n        else\n            state <= next_state;\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            IDLE: begin\n                if (r)\n                    next_state = IDLE;\n                else if (a && b)\n                    next_state = DONE;\n                else if (a)\n                    next_state = SA;\n                else if (b)\n                    next_state = SB;\n                else\n                    next_state = IDLE;\n            end\n            SA: begin\n                if (r)\n                    next_state = IDLE;\n                else if (b)\n                    next_state = DONE;\n                else\n                    next_state = SA;\n            end\n            SB: begin\n                if (r)\n                    next_state = IDLE;\n                else if (a)\n                    next_state = DONE;\n                else\n                    next_state = SB;\n            end\n            DONE: begin\n                if (r)\n                    next_state = IDLE;\n                else\n                    next_state = DONE;\n            end\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // Output logic\n    always @(posedge clk or negedge reset_n) begin\n        if (!reset_n)\n            o <= 1'b0;\n        else if (state == DONE && !r)\n            o <= 1'b1;\n        else\n            o <= 1'b0;\n    end\n\nendmodule\n```\n**Description:**  \nThis FSM detects the ABRO sequence:  \n- Output `o` is asserted high for one clock cycle when both `a` and `b` have occurred (in any order) since the last reset (`r` high).\n- The FSM resets to the initial state when `r` is high.\n- After outputting `o`, the FSM waits for `r` to be asserted before starting a new sequence.",
            "```verilog\nmodule abro_fsm (\n    input  wire clk,\n    input  wire reset_n, // active low reset\n    input  wire a,\n    input  wire b,\n    input  wire r,\n    output reg  o\n);\n\n    // State encoding\n    typedef enum logic [1:0] {\n        IDLE  = 2'b00,\n        SA    = 2'b01,\n        SB    = 2'b10,\n        SAB   = 2'b11\n    } state_t;\n\n    state_t state, next_state;\n\n    // State register\n    always @(posedge clk or negedge reset_n) begin\n        if (!reset_n)\n            state <= IDLE;\n        else if (r)\n            state <= IDLE;\n        else\n            state <= next_state;\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            IDLE: begin\n                if (a && b)\n                    next_state = SAB;\n                else if (a)\n                    next_state = SA;\n                else if (b)\n                    next_state = SB;\n                else\n                    next_state = IDLE;\n            end\n            SA: begin\n                if (b)\n                    next_state = SAB;\n                else\n                    next_state = SA;\n            end\n            SB: begin\n                if (a)\n                    next_state = SAB;\n                else\n                    next_state = SB;\n            end\n            SAB: begin\n                next_state = SAB; // Wait for reset\n            end\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // Output logic\n    always @(posedge clk or negedge reset_n) begin\n        if (!reset_n)\n            o <= 1'b0;\n        else if (r)\n            o <= 1'b0;\n        else if ((state != SAB) && (next_state == SAB))\n            o <= 1'b1; // Output pulse when entering SAB\n        else\n            o <= 1'b0;\n    end\n\nendmodule\n```\n**Description:**  \n- The FSM waits for both `a` and `b` to be asserted (in any order, possibly simultaneously).\n- When both have occurred, output `o` pulses high for one clock cycle.\n- The FSM resets to the initial state on `r` or `reset_n`.\n- The output `o` is a one-clock pulse when the ABRO sequence is detected.",
            "```verilog\nmodule abro_fsm (\n    input  wire clk,\n    input  wire reset_n, // active low reset\n    input  wire a,\n    input  wire b,\n    input  wire r,\n    output reg  o\n);\n\n    typedef enum logic [1:0] {\n        IDLE  = 2'b00,\n        A_seen = 2'b01,\n        B_seen = 2'b10,\n        AB_seen = 2'b11\n    } state_t;\n\n    state_t state, next_state;\n\n    // State register\n    always @(posedge clk or negedge reset_n) begin\n        if (!reset_n)\n            state <= IDLE;\n        else\n            state <= next_state;\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            IDLE: begin\n                if (r)\n                    next_state = IDLE;\n                else if (a && b)\n                    next_state = AB_seen;\n                else if (a)\n                    next_state = A_seen;\n                else if (b)\n                    next_state = B_seen;\n                else\n                    next_state = IDLE;\n            end\n            A_seen: begin\n                if (r)\n                    next_state = IDLE;\n                else if (b)\n                    next_state = AB_seen;\n                else\n                    next_state = A_seen;\n            end\n            B_seen: begin\n                if (r)\n                    next_state = IDLE;\n                else if (a)\n                    next_state = AB_seen;\n                else\n                    next_state = B_seen;\n            end\n            AB_seen: begin\n                if (r)\n                    next_state = IDLE;\n                else\n                    next_state = AB_seen;\n            end\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // Output logic\n    always @(posedge clk or negedge reset_n) begin\n        if (!reset_n)\n            o <= 1'b0;\n        else if (state != AB_seen && next_state == AB_seen)\n            o <= 1'b1;\n        else\n            o <= 1'b0;\n    end\n\nendmodule\n```\n**Description:**  \n- The FSM waits for both `a` and `b` to be asserted (in any order, possibly simultaneously).\n- When both have occurred, `o` is asserted for one clock cycle.\n- The FSM resets to the initial state on `r` or after outputting `o`.\n- The output `o` is a pulse (1 clock cycle) when the ABRO sequence is detected.",
            "```verilog\nmodule abro_fsm (\n    input  wire clk,\n    input  wire reset_n,\n    input  wire a,\n    input  wire b,\n    input  wire r,\n    output reg  o\n);\n\n    typedef enum logic [1:0] {\n        IDLE  = 2'b00,\n        SA    = 2'b01,\n        SB    = 2'b10,\n        DONE  = 2'b11\n    } state_t;\n\n    state_t state, next_state;\n\n    // State register\n    always @(posedge clk or negedge reset_n) begin\n        if (!reset_n)\n            state <= IDLE;\n        else\n            state <= next_state;\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            IDLE: begin\n                if (r)\n                    next_state = IDLE;\n                else if (a && b)\n                    next_state = DONE;\n                else if (a)\n                    next_state = SA;\n                else if (b)\n                    next_state = SB;\n                else\n                    next_state = IDLE;\n            end\n            SA: begin\n                if (r)\n                    next_state = IDLE;\n                else if (b)\n                    next_state = DONE;\n                else\n                    next_state = SA;\n            end\n            SB: begin\n                if (r)\n                    next_state = IDLE;\n                else if (a)\n                    next_state = DONE;\n                else\n                    next_state = SB;\n            end\n            DONE: begin\n                if (r)\n                    next_state = IDLE;\n                else\n                    next_state = DONE;\n            end\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // Output logic\n    always @(posedge clk or negedge reset_n) begin\n        if (!reset_n)\n            o <= 1'b0;\n        else if (state == DONE)\n            o <= 1'b1;\n        else\n            o <= 1'b0;\n    end\n\nendmodule\n```\n**Description:**  \n- Inputs: `a`, `b`, `r` (reset for the sequence), `clk`, `reset_n`\n- Output: `o` (goes high for one or more cycles when both `a` and `b` have occurred since last `r`)\n- FSM states:  \n  - `IDLE`: Waiting for either `a` or `b`\n  - `SA`: Saw `a`, waiting for `b`\n  - `SB`: Saw `b`, waiting for `a`\n  - `DONE`: Both `a` and `b` have occurred, output `o=1` until `r` is asserted\n\nThis is a classic ABRO sequence detector FSM.",
            "```verilog\nmodule abro_fsm (\n    input  wire clk,\n    input  wire reset_n, // active low reset\n    input  wire a,\n    input  wire b,\n    input  wire r,\n    output reg  o\n);\n\n    typedef enum logic [1:0] {\n        IDLE  = 2'b00,\n        A_seen = 2'b01,\n        B_seen = 2'b10,\n        AB_seen = 2'b11\n    } state_t;\n\n    state_t state, next_state;\n\n    // State register\n    always @(posedge clk or negedge reset_n) begin\n        if (!reset_n)\n            state <= IDLE;\n        else\n            state <= next_state;\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            IDLE: begin\n                if (r)\n                    next_state = IDLE;\n                else if (a && b)\n                    next_state = AB_seen;\n                else if (a)\n                    next_state = A_seen;\n                else if (b)\n                    next_state = B_seen;\n                else\n                    next_state = IDLE;\n            end\n            A_seen: begin\n                if (r)\n                    next_state = IDLE;\n                else if (b)\n                    next_state = AB_seen;\n                else\n                    next_state = A_seen;\n            end\n            B_seen: begin\n                if (r)\n                    next_state = IDLE;\n                else if (a)\n                    next_state = AB_seen;\n                else\n                    next_state = B_seen;\n            end\n            AB_seen: begin\n                if (r)\n                    next_state = IDLE;\n                else\n                    next_state = AB_seen;\n            end\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // Output logic\n    always @(posedge clk or negedge reset_n) begin\n        if (!reset_n)\n            o <= 1'b0;\n        else if (state != AB_seen && next_state == AB_seen)\n            o <= 1'b1;\n        else\n            o <= 1'b0;\n    end\n\nendmodule\n```\n**Description:**  \n- The FSM waits for both `a` and `b` to be asserted (in any order, possibly simultaneously).\n- When both have occurred, output `o` is asserted for one clock cycle.\n- The FSM resets to the initial state when `r` is asserted.\n- The output `o` is a pulse (1 clock cycle) when the ABRO sequence is detected.",
            "```verilog\nmodule abro_fsm (\n    input  wire clk,\n    input  wire reset_n, // active low reset\n    input  wire a,\n    input  wire b,\n    input  wire r,\n    output reg  o\n);\n\n    // State encoding\n    typedef enum logic [1:0] {\n        IDLE  = 2'b00,\n        SA    = 2'b01,\n        SB    = 2'b10,\n        SAB   = 2'b11\n    } state_t;\n\n    state_t state, next_state;\n\n    // State register\n    always @(posedge clk or negedge reset_n) begin\n        if (!reset_n)\n            state <= IDLE;\n        else\n            state <= next_state;\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            IDLE: begin\n                if (r)\n                    next_state = IDLE;\n                else if (a && b)\n                    next_state = SAB;\n                else if (a)\n                    next_state = SA;\n                else if (b)\n                    next_state = SB;\n                else\n                    next_state = IDLE;\n            end\n            SA: begin\n                if (r)\n                    next_state = IDLE;\n                else if (b)\n                    next_state = SAB;\n                else\n                    next_state = SA;\n            end\n            SB: begin\n                if (r)\n                    next_state = IDLE;\n                else if (a)\n                    next_state = SAB;\n                else\n                    next_state = SB;\n            end\n            SAB: begin\n                if (r)\n                    next_state = IDLE;\n                else\n                    next_state = SAB;\n            end\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // Output logic\n    always @(posedge clk or negedge reset_n) begin\n        if (!reset_n)\n            o <= 1'b0;\n        else if (state != SAB && next_state == SAB)\n            o <= 1'b1; // Output pulse when both A and B have occurred\n        else\n            o <= 1'b0;\n    end\n\nendmodule\n```",
            "```verilog\nmodule abro_fsm (\n    input  wire clk,\n    input  wire reset_n, // active low reset\n    input  wire a,\n    input  wire b,\n    input  wire r,\n    output reg  o\n);\n\n    typedef enum logic [1:0] {\n        IDLE  = 2'b00,\n        SA    = 2'b01,\n        SB    = 2'b10,\n        DONE  = 2'b11\n    } state_t;\n\n    state_t state, next_state;\n\n    // State register\n    always @(posedge clk or negedge reset_n) begin\n        if (!reset_n)\n            state <= IDLE;\n        else\n            state <= next_state;\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            IDLE: begin\n                if (r)\n                    next_state = IDLE;\n                else if (a && b)\n                    next_state = DONE;\n                else if (a)\n                    next_state = SA;\n                else if (b)\n                    next_state = SB;\n                else\n                    next_state = IDLE;\n            end\n            SA: begin\n                if (r)\n                    next_state = IDLE;\n                else if (b)\n                    next_state = DONE;\n                else\n                    next_state = SA;\n            end\n            SB: begin\n                if (r)\n                    next_state = IDLE;\n                else if (a)\n                    next_state = DONE;\n                else\n                    next_state = SB;\n            end\n            DONE: begin\n                if (r)\n                    next_state = IDLE;\n                else\n                    next_state = DONE;\n            end\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // Output logic\n    always @(posedge clk or negedge reset_n) begin\n        if (!reset_n)\n            o <= 1'b0;\n        else if (state == DONE && !r)\n            o <= 1'b1;\n        else if (r)\n            o <= 1'b0;\n        else\n            o <= 1'b0;\n    end\n\nendmodule\n```",
            "```verilog\nmodule abro_fsm (\n    input  wire clk,\n    input  wire reset_n,\n    input  wire a,\n    input  wire b,\n    input  wire r,\n    output reg  o\n);\n\n    typedef enum logic [2:0] {\n        IDLE  = 3'b000,\n        SA    = 3'b001,\n        SB    = 3'b010,\n        SAB   = 3'b011,\n        WAITR = 3'b100\n    } state_t;\n\n    state_t state, next_state;\n\n    // State register\n    always @(posedge clk or negedge reset_n) begin\n        if (!reset_n)\n            state <= IDLE;\n        else\n            state <= next_state;\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            IDLE: begin\n                if (a && b)\n                    next_state = SAB;\n                else if (a)\n                    next_state = SA;\n                else if (b)\n                    next_state = SB;\n                else\n                    next_state = IDLE;\n            end\n            SA: begin\n                if (b)\n                    next_state = SAB;\n                else\n                    next_state = SA;\n            end\n            SB: begin\n                if (a)\n                    next_state = SAB;\n                else\n                    next_state = SB;\n            end\n            SAB: begin\n                next_state = WAITR;\n            end\n            WAITR: begin\n                if (r)\n                    next_state = IDLE;\n                else\n                    next_state = WAITR;\n            end\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // Output logic\n    always @(posedge clk or negedge reset_n) begin\n        if (!reset_n)\n            o <= 1'b0;\n        else if (state == SAB)\n            o <= 1'b1;\n        else\n            o <= 1'b0;\n    end\n\nendmodule\n```"
        ],
        "config": {
            "model": "gpt-4.1",
            "system_instruction": "You are a Verilog code generator. Output only synthesizable Verilog code.",
            "temperature": 0.2,
            "max_tokens": 1024,
            "samples": 10
        }
    }
]